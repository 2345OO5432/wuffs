#ifndef WUFFS_GIF_H
#define WUFFS_GIF_H

// Code generated by wuffs-c. DO NOT EDIT.

#ifndef WUFFS_BASE_HEADER_H
#define WUFFS_BASE_HEADER_H

// Copyright 2017 The Wuffs Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <stdbool.h>
#include <stdint.h>
#include <string.h>

// Wuffs requires a word size of at least 32 bits because it assumes that
// converting a u32 to usize will never overflow. For example, the size of a
// decoded image is often represented, explicitly or implicitly in an image
// file, as a u32, and it is convenient to compare that to a buffer size.
//
// Similarly, the word size is at most 64 bits because it assumes that
// converting a usize to u64 will never overflow.
#if __WORDSIZE < 32
#error "Wuffs requires a word size of at least 32 bits"
#elif __WORDSIZE > 64
#error "Wuffs requires a word size of at most 64 bits"
#endif

// WUFFS_VERSION is the major.minor version number as a uint32. The major
// number is the high 16 bits. The minor number is the low 16 bits.
//
// The intention is to bump the version number at least on every API / ABI
// backwards incompatible change.
//
// For now, the API and ABI are simply unstable and can change at any time.
//
// TODO: don't hard code this in base-header.h.
#define WUFFS_VERSION (0x00001)

// ---------------- I/O

// wuffs_base__slice_u8 is a 1-dimensional buffer (a pointer and length).
//
// A value with all fields NULL or zero is a valid, empty slice.
typedef struct {
  uint8_t* ptr;
  size_t len;
} wuffs_base__slice_u8;

// wuffs_base__buf1 is a 1-dimensional buffer (a pointer and length), plus
// additional indexes into that buffer, plus an opened / closed flag.
//
// A value with all fields NULL or zero is a valid, empty buffer.
typedef struct {
  uint8_t* ptr;  // Pointer.
  size_t len;    // Length.
  size_t wi;     // Write index. Invariant: wi <= len.
  size_t ri;     // Read  index. Invariant: ri <= wi.
  bool closed;   // No further writes are expected.
} wuffs_base__buf1;

// wuffs_base__limit1 provides a limited view of a 1-dimensional byte stream:
// its first N bytes. That N can be greater than a buffer's current read or
// write capacity. N decreases naturally over time as bytes are read from or
// written to the stream.
//
// A value with all fields NULL or zero is a valid, unlimited view.
typedef struct wuffs_base__limit1 {
  uint64_t* ptr_to_len;             // Pointer to N.
  struct wuffs_base__limit1* next;  // Linked list of limits.
} wuffs_base__limit1;

typedef struct {
  // TODO: move buf into private_impl? As it is, it looks like users can modify
  // the buf field to point to a different buffer, which can turn the limit and
  // mark fields into dangling pointers.
  wuffs_base__buf1* buf;
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so.
  struct {
    wuffs_base__limit1 limit;
    uint8_t* mark;
  } private_impl;
} wuffs_base__reader1;

typedef struct {
  // TODO: move buf into private_impl? As it is, it looks like users can modify
  // the buf field to point to a different buffer, which can turn the limit and
  // mark fields into dangling pointers.
  wuffs_base__buf1* buf;
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so.
  struct {
    wuffs_base__limit1 limit;
    uint8_t* mark;
  } private_impl;
} wuffs_base__writer1;

// ---------------- Images

typedef struct {
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so.
  struct {
    uint32_t flags;
    uint32_t w;
    uint32_t h;
    // TODO: color model, including both packed RGBA and planar,
    // chroma-subsampled YCbCr.
  } private_impl;
} wuffs_base__image_config;

static inline void wuffs_base__image_config__invalidate(
    wuffs_base__image_config* c) {
  if (c) {
    *c = ((wuffs_base__image_config){});
  }
}

static inline bool wuffs_base__image_config__valid(
    wuffs_base__image_config* c) {
  if (!c || !(c->private_impl.flags & 1)) {
    return false;
  }
  uint64_t wh = ((uint64_t)c->private_impl.w) * ((uint64_t)c->private_impl.h);
  // TODO: handle things other than 1 byte per pixel.
  return wh <= ((uint64_t)SIZE_MAX);
}

static inline uint32_t wuffs_base__image_config__width(
    wuffs_base__image_config* c) {
  return wuffs_base__image_config__valid(c) ? c->private_impl.w : 0;
}

static inline uint32_t wuffs_base__image_config__height(
    wuffs_base__image_config* c) {
  return wuffs_base__image_config__valid(c) ? c->private_impl.h : 0;
}

// TODO: this is the right API for planar (not packed) pixbufs? Should it allow
// decoding into a color model different from the format's intrinsic one? For
// example, decoding a JPEG image straight to RGBA instead of to YCbCr?
static inline size_t wuffs_base__image_config__pixbuf_size(
    wuffs_base__image_config* c) {
  if (wuffs_base__image_config__valid(c)) {
    uint64_t wh = ((uint64_t)c->private_impl.w) * ((uint64_t)c->private_impl.h);
    // TODO: handle things other than 1 byte per pixel.
    return (size_t)wh;
  }
  return 0;
}

static inline void wuffs_base__image_config__initialize(
    wuffs_base__image_config* c,
    uint32_t width,
    uint32_t height,
    uint32_t TODO_color_model) {
  if (!c) {
    return;
  }
  c->private_impl.flags = 1;
  c->private_impl.w = width;
  c->private_impl.h = height;
  // TODO: color model.
}

#endif  // WUFFS_BASE_HEADER_H

// ---------------- Use Declarations

#ifdef __cplusplus
extern "C" {
#endif

// ---------------- Status Codes

// Status codes are int32_t values:
//  - the sign bit indicates a non-recoverable status code: an error
//  - bits 10-30 hold the packageid: a namespace
//  - bits 8-9 are reserved
//  - bits 0-7 are a package-namespaced numeric code
//
// Do not manipulate these bits directly. Use the API functions such as
// wuffs_gif__status__is_error instead.
typedef int32_t wuffs_gif__status;

#define wuffs_gif__packageid 1017222  // 0x000F8586

#define WUFFS_GIF__STATUS_OK 0                                   // 0x00000000
#define WUFFS_GIF__ERROR_BAD_WUFFS_VERSION -2147483647           // 0x80000001
#define WUFFS_GIF__ERROR_BAD_RECEIVER -2147483646                // 0x80000002
#define WUFFS_GIF__ERROR_BAD_ARGUMENT -2147483645                // 0x80000003
#define WUFFS_GIF__ERROR_INITIALIZER_NOT_CALLED -2147483644      // 0x80000004
#define WUFFS_GIF__ERROR_INVALID_I_O_OPERATION -2147483643       // 0x80000005
#define WUFFS_GIF__ERROR_CLOSED_FOR_WRITES -2147483642           // 0x80000006
#define WUFFS_GIF__ERROR_UNEXPECTED_EOF -2147483641              // 0x80000007
#define WUFFS_GIF__SUSPENSION_SHORT_READ 8                       // 0x00000008
#define WUFFS_GIF__SUSPENSION_SHORT_WRITE 9                      // 0x00000009
#define WUFFS_GIF__ERROR_CANNOT_RETURN_A_SUSPENSION -2147483638  // 0x8000000A
#define WUFFS_GIF__ERROR_INVALID_CALL_SEQUENCE -2147483637       // 0x8000000B
#define WUFFS_GIF__SUSPENSION_END_OF_DATA 12                     // 0x0000000C

#define WUFFS_GIF__ERROR_BAD_GIF_BLOCK -1105848320            // 0xBE161800
#define WUFFS_GIF__ERROR_BAD_GIF_EXTENSION_LABEL -1105848319  // 0xBE161801
#define WUFFS_GIF__ERROR_BAD_GIF_HEADER -1105848318           // 0xBE161802
#define WUFFS_GIF__ERROR_BAD_LZW_LITERAL_WIDTH -1105848317    // 0xBE161803
#define WUFFS_GIF__ERROR_INTERNAL_ERROR_INCONSISTENT_LIMITED_READ \
  -1105848316                                                      // 0xBE161804
#define WUFFS_GIF__ERROR_LZW_CODE_IS_OUT_OF_RANGE -1105848315      // 0xBE161805
#define WUFFS_GIF__ERROR_LZW_PREFIX_CHAIN_IS_CYCLICAL -1105848314  // 0xBE161806

bool wuffs_gif__status__is_error(wuffs_gif__status s);

const char* wuffs_gif__status__string(wuffs_gif__status s);

// ---------------- Public Consts

// ---------------- Structs

typedef struct {
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so. Instead, use the
  // wuffs_gif__lzw_decoder__etc functions.
  //
  // In C++, these fields would be "private", but C does not support that.
  //
  // It is a struct, not a struct*, so that it can be stack allocated.
  struct {
    wuffs_gif__status status;
    uint32_t magic;

    uint32_t f_literal_width;
    uint8_t f_stack[4096];
    uint8_t f_suffixes[4096];
    uint16_t f_prefixes[4096];

    struct {
      uint32_t coro_susp_point;
      uint32_t v_clear_code;
      uint32_t v_end_code;
      uint32_t v_save_code;
      uint32_t v_prev_code;
      uint32_t v_width;
      uint32_t v_bits;
      uint32_t v_n_bits;
      uint32_t v_code;
      uint32_t v_s;
      uint32_t v_c;
      uint64_t v_n_copied;
    } c_decode[1];
  } private_impl;
} wuffs_gif__lzw_decoder;

typedef struct {
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so. Instead, use the
  // wuffs_gif__decoder__etc functions.
  //
  // In C++, these fields would be "private", but C does not support that.
  //
  // It is a struct, not a struct*, so that it can be stack allocated.
  struct {
    wuffs_gif__status status;
    uint32_t magic;

    uint32_t f_width;
    uint32_t f_height;
    uint8_t f_call_sequence;
    uint8_t f_background_color_index;
    uint8_t f_block_type;
    bool f_peek_block_type;
    bool f_have_gct;
    bool f_have_lct;
    bool f_interlace;
    bool f_seen_num_loops;
    uint32_t f_num_loops;
    uint32_t f_frame_top;
    uint32_t f_frame_left;
    uint32_t f_frame_width;
    uint32_t f_frame_height;
    uint8_t f_gct[768];
    uint8_t f_lct[768];
    wuffs_gif__lzw_decoder f_lzw;

    struct {
      uint32_t coro_susp_point;
    } c_decode_config[1];
    struct {
      uint32_t coro_susp_point;
    } c_decode_frame[1];
    struct {
      uint32_t coro_susp_point;
      uint8_t v_c[6];
      uint32_t v_i;
    } c_decode_header[1];
    struct {
      uint32_t coro_susp_point;
      uint8_t v_c[7];
      uint32_t v_i;
      uint32_t v_gct_size;
    } c_decode_lsd[1];
    struct {
      uint32_t coro_susp_point;
      uint8_t v_label;
    } c_decode_extension[1];
    struct {
      uint32_t coro_susp_point;
      uint8_t v_block_size;
      uint64_t scratch;
    } c_skip_blocks[1];
    struct {
      uint32_t coro_susp_point;
      uint8_t v_c;
      uint8_t v_block_size;
      bool v_not_animexts;
      bool v_not_netscape;
      uint64_t scratch;
    } c_decode_ae[1];
    struct {
      uint32_t coro_susp_point;
      uint8_t v_flags;
      uint32_t v_lct_size;
      uint32_t v_i;
      uint8_t v_lw;
      uint64_t v_block_size;
      wuffs_gif__status v_z;
      uint64_t scratch;
    } c_decode_id[1];
  } private_impl;
} wuffs_gif__decoder;

// ---------------- Public Initializer Prototypes

// wuffs_gif__decoder__initialize is an initializer function.
//
// It should be called before any other wuffs_gif__decoder__* function.
//
// Pass WUFFS_VERSION and 0 for wuffs_version and for_internal_use_only.
void wuffs_gif__decoder__initialize(wuffs_gif__decoder* self,
                                    uint32_t wuffs_version,
                                    uint32_t for_internal_use_only);

// ---------------- Public Function Prototypes

wuffs_gif__status wuffs_gif__decoder__decode_config(
    wuffs_gif__decoder* self,
    wuffs_base__image_config* a_dst,
    wuffs_base__reader1 a_src);

wuffs_gif__status wuffs_gif__decoder__decode_frame(wuffs_gif__decoder* self,
                                                   wuffs_base__writer1 a_dst,
                                                   wuffs_base__reader1 a_src);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif  // WUFFS_GIF_H

// C HEADER ENDS HERE.

#ifndef WUFFS_BASE_IMPL_H
#define WUFFS_BASE_IMPL_H

// Copyright 2017 The Wuffs Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// wuffs_base__empty_struct is used when a Wuffs function returns an empty
// struct. In C, if a function f returns void, you can't say "x = f()", but in
// Wuffs, if a function g returns empty, you can say "y = g()".
typedef struct {
} wuffs_base__empty_struct;

#define WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(x) (void)(x)

// WUFFS_BASE__MAGIC is a magic number to check that initializers are called.
// It's not foolproof, given C doesn't automatically zero memory before use,
// but it should catch 99.99% of cases.
//
// Its (non-zero) value is arbitrary, based on md5sum("wuffs").
#define WUFFS_BASE__MAGIC (0x3CCB6C71U)

// WUFFS_BASE__ALREADY_ZEROED is passed from a container struct's initializer
// to a containee struct's initializer when the container has already zeroed
// the containee's memory.
//
// Its (non-zero) value is arbitrary, based on md5sum("zeroed").
#define WUFFS_BASE__ALREADY_ZEROED (0x68602EF1U)

// Denote intentional fallthroughs for -Wimplicit-fallthrough.
//
// The order matters here. Clang also defines "__GNUC__".
#if defined(__clang__) && __cplusplus >= 201103L
#define WUFFS_BASE__FALLTHROUGH [[clang::fallthrough]]
#elif !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 7)
#define WUFFS_BASE__FALLTHROUGH __attribute__((fallthrough))
#else
#define WUFFS_BASE__FALLTHROUGH
#endif

// Use switch cases for coroutine suspension points, similar to the technique
// in https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html
//
// We use trivial macros instead of an explicit assignment and case statement
// so that clang-format doesn't get confused by the unusual "case"s.
#define WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0 case 0:;
#define WUFFS_BASE__COROUTINE_SUSPENSION_POINT(n) \
  coro_susp_point = n;                            \
  WUFFS_BASE__FALLTHROUGH;                        \
  case n:;

#define WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(n) \
  if (status < 0) {                                             \
    goto exit;                                                  \
  } else if (status == 0) {                                     \
    goto ok;                                                    \
  }                                                             \
  coro_susp_point = n;                                          \
  goto suspend;                                                 \
  case n:;

// Clang also defines "__GNUC__".
#if defined(__GNUC__)
#define WUFFS_BASE__LIKELY(expr) (__builtin_expect(!!(expr), 1))
#define WUFFS_BASE__UNLIKELY(expr) (__builtin_expect(!!(expr), 0))
#else
#define WUFFS_BASE__LIKELY(expr) (expr)
#define WUFFS_BASE__UNLIKELY(expr) (expr)
#endif

// Uncomment this #include for printf-debugging.
// #include <stdio.h>

// ---------------- Static Inline Functions
//
// The helpers below are functions, instead of macros, because their arguments
// can be an expression that we shouldn't evaluate more than once.
//
// They are in base-impl.h and hence copy/pasted into every generated C file,
// instead of being in some "base.c" file, since a design goal is that users of
// the generated C code can often just #include a single .c file, such as
// "gif.c", without having to additionally include or otherwise build and link
// a "base.c" file.
//
// They are static, so that linking multiple wuffs .o files won't complain about
// duplicate function definitions.
//
// They are explicitly marked inline, even if modern compilers don't use the
// inline attribute to guide optimizations such as inlining, to avoid the
// -Wunused-function warning, and we like to compile with -Wall -Werror.

static inline uint16_t wuffs_base__load_u16be(uint8_t* p) {
  return ((uint16_t)(p[0]) << 8) | ((uint16_t)(p[1]) << 0);
}

static inline uint16_t wuffs_base__load_u16le(uint8_t* p) {
  return ((uint16_t)(p[0]) << 0) | ((uint16_t)(p[1]) << 8);
}

static inline uint32_t wuffs_base__load_u32be(uint8_t* p) {
  return ((uint32_t)(p[0]) << 24) | ((uint32_t)(p[1]) << 16) |
         ((uint32_t)(p[2]) << 8) | ((uint32_t)(p[3]) << 0);
}

static inline uint32_t wuffs_base__load_u32le(uint8_t* p) {
  return ((uint32_t)(p[0]) << 0) | ((uint32_t)(p[1]) << 8) |
         ((uint32_t)(p[2]) << 16) | ((uint32_t)(p[3]) << 24);
}

static inline wuffs_base__slice_u8 wuffs_base__slice_u8__subslice_i(
    wuffs_base__slice_u8 s,
    uint64_t i) {
  if ((i <= SIZE_MAX) && (i <= s.len)) {
    return ((wuffs_base__slice_u8){
        .ptr = s.ptr + i,
        .len = s.len - i,
    });
  }
  return ((wuffs_base__slice_u8){});
}

static inline wuffs_base__slice_u8 wuffs_base__slice_u8__subslice_j(
    wuffs_base__slice_u8 s,
    uint64_t j) {
  if ((j <= SIZE_MAX) && (j <= s.len)) {
    return ((wuffs_base__slice_u8){.ptr = s.ptr, .len = j});
  }
  return ((wuffs_base__slice_u8){});
}

static inline wuffs_base__slice_u8 wuffs_base__slice_u8__subslice_ij(
    wuffs_base__slice_u8 s,
    uint64_t i,
    uint64_t j) {
  if ((i <= j) && (j <= SIZE_MAX) && (j <= s.len)) {
    return ((wuffs_base__slice_u8){
        .ptr = s.ptr + i,
        .len = j - i,
    });
  }
  return ((wuffs_base__slice_u8){});
}

// wuffs_base__slice_u8__prefix returns up to the first up_to bytes of s.
static inline wuffs_base__slice_u8 wuffs_base__slice_u8__prefix(
    wuffs_base__slice_u8 s,
    uint64_t up_to) {
  if ((uint64_t)(s.len) > up_to) {
    s.len = up_to;
  }
  return s;
}

// wuffs_base__slice_u8__suffix returns up to the last up_to bytes of s.
static inline wuffs_base__slice_u8 wuffs_base__slice_u8_suffix(
    wuffs_base__slice_u8 s,
    uint64_t up_to) {
  if ((uint64_t)(s.len) > up_to) {
    s.ptr += (uint64_t)(s.len) - up_to;
    s.len = up_to;
  }
  return s;
}

// wuffs_base__slice_u8__copy_from_slice calls memmove(dst.ptr, src.ptr,
// length) where length is the minimum of dst.len and src.len.
//
// Passing a wuffs_base__slice_u8 with all fields NULL or zero (a valid, empty
// slice) is valid and results in a no-op.
static inline uint64_t wuffs_base__slice_u8__copy_from_slice(
    wuffs_base__slice_u8 dst,
    wuffs_base__slice_u8 src) {
  size_t length = dst.len < src.len ? dst.len : src.len;
  if (length > 0) {
    memmove(dst.ptr, src.ptr, length);
  }
  return length;
}

static inline uint32_t wuffs_base__writer1__copy_from_history32(
    uint8_t** ptr_ptr,
    uint8_t* start,  // May be NULL, meaning an unmarked writer1.
    uint8_t* end,
    uint32_t distance,
    uint32_t length) {
  if (!start || !distance) {
    return 0;
  }
  uint8_t* ptr = *ptr_ptr;
  if ((size_t)(ptr - start) < (size_t)(distance)) {
    return 0;
  }
  start = ptr - distance;
  size_t n = end - ptr;
  if ((size_t)(length) > n) {
    length = n;
  } else {
    n = length;
  }
  // TODO: unrolling by 3 seems best for the std/deflate benchmarks, but that
  // is mostly because 3 is the minimum length for the deflate format. This
  // function implementation shouldn't overfit to that one format. Perhaps the
  // copy_from_history32 Wuffs method should also take an unroll hint argument,
  // and the cgen can look if that argument is the constant expression '3'.
  //
  // See also wuffs_base__writer1__copy_from_history32__bco below.
  //
  // Alternatively, or additionally, have a sloppy_copy_from_history32 method
  // that copies 8 bytes at a time, possibly writing more than length bytes?
  for (; n >= 3; n -= 3) {
    *ptr++ = *start++;
    *ptr++ = *start++;
    *ptr++ = *start++;
  }
  for (; n; n--) {
    *ptr++ = *start++;
  }
  *ptr_ptr = ptr;
  return length;
}

// wuffs_base__writer1__copy_from_history32__bco is a Bounds Check Optimized
// version of the wuffs_base__writer1__copy_from_history32 function above. The
// caller needs to prove that:
//  - start    != NULL
//  - distance != 0
//  - distance <= (*ptr_ptr - start)
//  - length   <= (end      - *ptr_ptr)
static inline uint32_t wuffs_base__writer1__copy_from_history32__bco(
    uint8_t** ptr_ptr,
    uint8_t* start,
    uint8_t* end,
    uint32_t distance,
    uint32_t length) {
  uint8_t* ptr = *ptr_ptr;
  start = ptr - distance;
  uint32_t n = length;
  for (; n >= 3; n -= 3) {
    *ptr++ = *start++;
    *ptr++ = *start++;
    *ptr++ = *start++;
  }
  for (; n; n--) {
    *ptr++ = *start++;
  }
  *ptr_ptr = ptr;
  return length;
}

static inline uint32_t wuffs_base__writer1__copy_from_reader32(
    uint8_t** ptr_wptr,
    uint8_t* wend,
    uint8_t** ptr_rptr,
    uint8_t* rend,
    uint32_t length) {
  uint8_t* wptr = *ptr_wptr;
  size_t n = length;
  if (n > wend - wptr) {
    n = wend - wptr;
  }
  uint8_t* rptr = *ptr_rptr;
  if (n > rend - rptr) {
    n = rend - rptr;
  }
  if (n > 0) {
    memmove(wptr, rptr, n);
    *ptr_wptr += n;
    *ptr_rptr += n;
  }
  return n;
}

static inline uint64_t wuffs_base__writer1__copy_from_slice(
    uint8_t** ptr_wptr,
    uint8_t* wend,
    wuffs_base__slice_u8 src) {
  uint8_t* wptr = *ptr_wptr;
  size_t n = src.len;
  if (n > wend - wptr) {
    n = wend - wptr;
  }
  if (n > 0) {
    memmove(wptr, src.ptr, n);
    *ptr_wptr += n;
  }
  return n;
}

static inline uint32_t wuffs_base__writer1__copy_from_slice32(
    uint8_t** ptr_wptr,
    uint8_t* wend,
    wuffs_base__slice_u8 src,
    uint32_t length) {
  uint8_t* wptr = *ptr_wptr;
  size_t n = src.len;
  if (n > length) {
    n = length;
  }
  if (n > wend - wptr) {
    n = wend - wptr;
  }
  if (n > 0) {
    memmove(wptr, src.ptr, n);
    *ptr_wptr += n;
  }
  return n;
}

// Note that the *__limit and *__mark methods are private (in base-impl.h) not
// public (in base-header.h). We assume that, at the boundary between user code
// and Wuffs code, the reader1 and writer1's private_impl fields (including
// limit and mark) are NULL. Otherwise, some internal assumptions break down.
// For example, limits could be represented as pointers, even though
// conceptually they are counts, but that pointer-to-count correspondence
// becomes invalid if a buffer is re-used (e.g. on resuming a coroutine).
//
// Admittedly, some of the Wuffs test code calls these methods, but that test
// code is still Wuffs code, not user code. Other Wuffs test code modifies
// private_impl fields directly.

static inline wuffs_base__reader1 wuffs_base__reader1__limit(
    wuffs_base__reader1* o,
    uint64_t* ptr_to_len) {
  wuffs_base__reader1 ret = *o;
  ret.private_impl.limit.ptr_to_len = ptr_to_len;
  ret.private_impl.limit.next = &o->private_impl.limit;
  return ret;
}

static inline wuffs_base__empty_struct wuffs_base__reader1__mark(
    wuffs_base__reader1* o,
    uint8_t* mark) {
  o->private_impl.mark = mark;
  return ((wuffs_base__empty_struct){});
}

// TODO: static inline wuffs_base__writer1 wuffs_base__writer1__limit()

static inline wuffs_base__empty_struct wuffs_base__writer1__mark(
    wuffs_base__writer1* o,
    uint8_t* mark) {
  o->private_impl.mark = mark;
  return ((wuffs_base__empty_struct){});
}

static const char* wuffs_base__status__strings[13] = {
    "ok",
    "bad wuffs version",
    "bad receiver",
    "bad argument",
    "initializer not called",
    "invalid I/O operation",
    "closed for writes",
    "unexpected EOF",
    "short read",
    "short write",
    "cannot return a suspension",
    "invalid call sequence",
    "end of data",
};

#endif  // WUFFS_BASE_IMPL_H

// ---------------- Status Codes Implementations

bool wuffs_gif__status__is_error(wuffs_gif__status s) {
  return s < 0;
}

const char* wuffs_gif__status__strings[7] = {
    "gif: bad GIF block",
    "gif: bad GIF extension label",
    "gif: bad GIF header",
    "gif: bad LZW literal width",
    "gif: internal error: inconsistent limited read",
    "gif: LZW code is out of range",
    "gif: LZW prefix chain is cyclical",
};

const char* wuffs_gif__status__string(wuffs_gif__status s) {
  const char** a = NULL;
  uint32_t n = 0;
  switch ((s >> 10) & 0x1FFFFF) {
    case 0:
      a = wuffs_base__status__strings;
      n = 13;
      break;
    case wuffs_gif__packageid:
      a = wuffs_gif__status__strings;
      n = 7;
      break;
  }
  uint32_t i = s & 0xFF;
  return i < n ? a[i] : "unknown status";
}

// ---------------- Private Consts

static const uint8_t wuffs_gif__animexts1dot0[11] = {
    65, 78, 73, 77, 69, 88, 84, 83, 49, 46, 48,
};

static const uint8_t wuffs_gif__netscape2dot0[11] = {
    78, 69, 84, 83, 67, 65, 80, 69, 50, 46, 48,
};

// ---------------- Private Initializer Prototypes

void wuffs_gif__lzw_decoder__initialize(wuffs_gif__lzw_decoder* self,
                                        uint32_t wuffs_version,
                                        uint32_t for_internal_use_only);

// ---------------- Private Function Prototypes

static wuffs_gif__status wuffs_gif__decoder__decode_header(
    wuffs_gif__decoder* self,
    wuffs_base__reader1 a_src);

static wuffs_gif__status wuffs_gif__decoder__decode_lsd(
    wuffs_gif__decoder* self,
    wuffs_base__reader1 a_src);

static wuffs_gif__status wuffs_gif__decoder__decode_extension(
    wuffs_gif__decoder* self,
    wuffs_base__reader1 a_src);

static wuffs_gif__status wuffs_gif__decoder__skip_blocks(
    wuffs_gif__decoder* self,
    wuffs_base__reader1 a_src);

static wuffs_gif__status wuffs_gif__decoder__decode_ae(
    wuffs_gif__decoder* self,
    wuffs_base__reader1 a_src);

static wuffs_gif__status wuffs_gif__decoder__decode_id(
    wuffs_gif__decoder* self,
    wuffs_base__writer1 a_dst,
    wuffs_base__reader1 a_src);

static void wuffs_gif__lzw_decoder__set_literal_width(
    wuffs_gif__lzw_decoder* self,
    uint32_t a_lw);

static wuffs_gif__status wuffs_gif__lzw_decoder__decode(
    wuffs_gif__lzw_decoder* self,
    wuffs_base__writer1 a_dst,
    wuffs_base__reader1 a_src);

// ---------------- Initializer Implementations

void wuffs_gif__lzw_decoder__initialize(wuffs_gif__lzw_decoder* self,
                                        uint32_t wuffs_version,
                                        uint32_t for_internal_use_only) {
  if (!self) {
    return;
  }
  if (wuffs_version != WUFFS_VERSION) {
    self->private_impl.status = WUFFS_GIF__ERROR_BAD_WUFFS_VERSION;
    return;
  }
  if (for_internal_use_only != WUFFS_BASE__ALREADY_ZEROED) {
    memset(self, 0, sizeof(*self));
  }
  self->private_impl.magic = WUFFS_BASE__MAGIC;
  self->private_impl.f_literal_width = 8;
}

void wuffs_gif__decoder__initialize(wuffs_gif__decoder* self,
                                    uint32_t wuffs_version,
                                    uint32_t for_internal_use_only) {
  if (!self) {
    return;
  }
  if (wuffs_version != WUFFS_VERSION) {
    self->private_impl.status = WUFFS_GIF__ERROR_BAD_WUFFS_VERSION;
    return;
  }
  if (for_internal_use_only != WUFFS_BASE__ALREADY_ZEROED) {
    memset(self, 0, sizeof(*self));
  }
  self->private_impl.magic = WUFFS_BASE__MAGIC;
  self->private_impl.f_num_loops = 1;
  wuffs_gif__lzw_decoder__initialize(&self->private_impl.f_lzw, WUFFS_VERSION,
                                     WUFFS_BASE__ALREADY_ZEROED);
}

// ---------------- Function Implementations

wuffs_gif__status wuffs_gif__decoder__decode_config(
    wuffs_gif__decoder* self,
    wuffs_base__image_config* a_dst,
    wuffs_base__reader1 a_src) {
  if (!self) {
    return WUFFS_GIF__ERROR_BAD_RECEIVER;
  }
  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {
    self->private_impl.status = WUFFS_GIF__ERROR_INITIALIZER_NOT_CALLED;
  }
  if (self->private_impl.status < 0) {
    return self->private_impl.status;
  }
  if (!a_dst) {
    self->private_impl.status = WUFFS_GIF__ERROR_BAD_ARGUMENT;
    return WUFFS_GIF__ERROR_BAD_ARGUMENT;
  }
  wuffs_gif__status status = WUFFS_GIF__STATUS_OK;

  uint8_t* b_rptr_src = NULL;
  uint8_t* b_rstart_src = NULL;
  uint8_t* b_rend_src = NULL;
  if (a_src.buf) {
    b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
    b_rstart_src = b_rptr_src;
    uint64_t len = a_src.buf->wi - a_src.buf->ri;
    wuffs_base__limit1* lim;
    for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len && (len > *lim->ptr_to_len)) {
        len = *lim->ptr_to_len;
      }
    }
    b_rend_src = b_rptr_src + len;
  }

  uint32_t coro_susp_point =
      self->private_impl.c_decode_config[0].coro_susp_point;
  if (coro_susp_point) {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    if (self->private_impl.f_call_sequence >= 1) {
      status = WUFFS_GIF__ERROR_INVALID_CALL_SEQUENCE;
      goto exit;
    }
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
    if (a_src.buf) {
      size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
      a_src.buf->ri += n;
      wuffs_base__limit1* lim;
      for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
        if (lim->ptr_to_len) {
          *lim->ptr_to_len -= n;
        }
      }
    }
    status = wuffs_gif__decoder__decode_header(self, a_src);
    if (a_src.buf) {
      b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
    }
    if (status) {
      goto suspend;
    }
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
    if (a_src.buf) {
      size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
      a_src.buf->ri += n;
      wuffs_base__limit1* lim;
      for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
        if (lim->ptr_to_len) {
          *lim->ptr_to_len -= n;
        }
      }
    }
    status = wuffs_gif__decoder__decode_lsd(self, a_src);
    if (a_src.buf) {
      b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
    }
    if (status) {
      goto suspend;
    }
    while (true) {
      self->private_impl.f_peek_block_type = true;
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
        if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
          goto short_read_src;
        }
        uint8_t t_0 = *b_rptr_src++;
        self->private_impl.f_block_type = t_0;
      }
      if (self->private_impl.f_seen_num_loops ||
          (self->private_impl.f_block_type != 33)) {
        goto label_0_break;
      }
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(4);
      if (a_src.buf) {
        size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
        a_src.buf->ri += n;
        wuffs_base__limit1* lim;
        for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
          if (lim->ptr_to_len) {
            *lim->ptr_to_len -= n;
          }
        }
      }
      status = wuffs_gif__decoder__decode_extension(self, a_src);
      if (a_src.buf) {
        b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
      }
      if (status) {
        goto suspend;
      }
    }
  label_0_break:;
    wuffs_base__image_config__initialize(a_dst, self->private_impl.f_width,
                                         self->private_impl.f_height, 0);
    self->private_impl.f_call_sequence = 1;

    goto ok;
  ok:
    self->private_impl.c_decode_config[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_config[0].coro_susp_point = coro_susp_point;

exit:
  if (a_src.buf) {
    size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
    a_src.buf->ri += n;
    wuffs_base__limit1* lim;
    for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len) {
        *lim->ptr_to_len -= n;
      }
    }
    WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rstart_src);
    WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rend_src);
  }

  self->private_impl.status = status;
  return status;

short_read_src:
  if (a_src.buf && a_src.buf->closed && !a_src.private_impl.limit.ptr_to_len) {
    status = WUFFS_GIF__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_GIF__SUSPENSION_SHORT_READ;
  goto suspend;
}

wuffs_gif__status wuffs_gif__decoder__decode_frame(wuffs_gif__decoder* self,
                                                   wuffs_base__writer1 a_dst,
                                                   wuffs_base__reader1 a_src) {
  if (!self) {
    return WUFFS_GIF__ERROR_BAD_RECEIVER;
  }
  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {
    self->private_impl.status = WUFFS_GIF__ERROR_INITIALIZER_NOT_CALLED;
  }
  if (self->private_impl.status < 0) {
    return self->private_impl.status;
  }
  wuffs_gif__status status = WUFFS_GIF__STATUS_OK;

  uint8_t* b_rptr_src = NULL;
  uint8_t* b_rstart_src = NULL;
  uint8_t* b_rend_src = NULL;
  if (a_src.buf) {
    b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
    b_rstart_src = b_rptr_src;
    uint64_t len = a_src.buf->wi - a_src.buf->ri;
    wuffs_base__limit1* lim;
    for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len && (len > *lim->ptr_to_len)) {
        len = *lim->ptr_to_len;
      }
    }
    b_rend_src = b_rptr_src + len;
  }

  uint32_t coro_susp_point =
      self->private_impl.c_decode_frame[0].coro_susp_point;
  if (coro_susp_point) {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    if (self->private_impl.f_call_sequence < 1) {
      status = WUFFS_GIF__ERROR_INVALID_CALL_SEQUENCE;
      goto exit;
    }
    while (true) {
      if (self->private_impl.f_peek_block_type) {
        self->private_impl.f_peek_block_type = false;
      } else {
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
          if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
            goto short_read_src;
          }
          uint8_t t_0 = *b_rptr_src++;
          self->private_impl.f_block_type = t_0;
        }
      }
      if (self->private_impl.f_block_type == 33) {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
        if (a_src.buf) {
          size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
          a_src.buf->ri += n;
          wuffs_base__limit1* lim;
          for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
            if (lim->ptr_to_len) {
              *lim->ptr_to_len -= n;
            }
          }
        }
        status = wuffs_gif__decoder__decode_extension(self, a_src);
        if (a_src.buf) {
          b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
        }
        if (status) {
          goto suspend;
        }
      } else if (self->private_impl.f_block_type == 44) {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
        if (a_src.buf) {
          size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
          a_src.buf->ri += n;
          wuffs_base__limit1* lim;
          for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
            if (lim->ptr_to_len) {
              *lim->ptr_to_len -= n;
            }
          }
        }
        status = wuffs_gif__decoder__decode_id(self, a_dst, a_src);
        if (a_src.buf) {
          b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
        }
        if (status) {
          goto suspend;
        }
        status = WUFFS_GIF__STATUS_OK;
        goto ok;
      } else if (self->private_impl.f_block_type == 59) {
        goto label_0_break;
      } else {
        status = WUFFS_GIF__ERROR_BAD_GIF_BLOCK;
        goto exit;
      }
    }
  label_0_break:;
    while (true) {
      status = WUFFS_GIF__SUSPENSION_END_OF_DATA;
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(4);
    }

    goto ok;
  ok:
    self->private_impl.c_decode_frame[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_frame[0].coro_susp_point = coro_susp_point;

exit:
  if (a_src.buf) {
    size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
    a_src.buf->ri += n;
    wuffs_base__limit1* lim;
    for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len) {
        *lim->ptr_to_len -= n;
      }
    }
    WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rstart_src);
    WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rend_src);
  }

  self->private_impl.status = status;
  return status;

short_read_src:
  if (a_src.buf && a_src.buf->closed && !a_src.private_impl.limit.ptr_to_len) {
    status = WUFFS_GIF__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_GIF__SUSPENSION_SHORT_READ;
  goto suspend;
}

static wuffs_gif__status wuffs_gif__decoder__decode_header(
    wuffs_gif__decoder* self,
    wuffs_base__reader1 a_src) {
  wuffs_gif__status status = WUFFS_GIF__STATUS_OK;

  uint8_t v_c[6];
  uint32_t v_i;

  uint8_t* b_rptr_src = NULL;
  uint8_t* b_rstart_src = NULL;
  uint8_t* b_rend_src = NULL;
  if (a_src.buf) {
    b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
    b_rstart_src = b_rptr_src;
    uint64_t len = a_src.buf->wi - a_src.buf->ri;
    wuffs_base__limit1* lim;
    for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len && (len > *lim->ptr_to_len)) {
        len = *lim->ptr_to_len;
      }
    }
    b_rend_src = b_rptr_src + len;
  }

  uint32_t coro_susp_point =
      self->private_impl.c_decode_header[0].coro_susp_point;
  if (coro_susp_point) {
    memcpy(v_c, self->private_impl.c_decode_header[0].v_c, sizeof(v_c));
    v_i = self->private_impl.c_decode_header[0].v_i;
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    memset(v_c, 0, sizeof(v_c));
    v_i = 0;
    while (v_i < 6) {
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
        if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
          goto short_read_src;
        }
        uint8_t t_0 = *b_rptr_src++;
        v_c[v_i] = t_0;
      }
      v_i += 1;
    }
    if ((v_c[0] != 71) || (v_c[1] != 73) || (v_c[2] != 70) || (v_c[3] != 56) ||
        ((v_c[4] != 55) && (v_c[4] != 57)) || (v_c[5] != 97)) {
      status = WUFFS_GIF__ERROR_BAD_GIF_HEADER;
      goto exit;
    }

    goto ok;
  ok:
    self->private_impl.c_decode_header[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_header[0].coro_susp_point = coro_susp_point;
  memcpy(self->private_impl.c_decode_header[0].v_c, v_c, sizeof(v_c));
  self->private_impl.c_decode_header[0].v_i = v_i;

exit:
  if (a_src.buf) {
    size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
    a_src.buf->ri += n;
    wuffs_base__limit1* lim;
    for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len) {
        *lim->ptr_to_len -= n;
      }
    }
    WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rstart_src);
    WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rend_src);
  }

  return status;

short_read_src:
  if (a_src.buf && a_src.buf->closed && !a_src.private_impl.limit.ptr_to_len) {
    status = WUFFS_GIF__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_GIF__SUSPENSION_SHORT_READ;
  goto suspend;
}

static wuffs_gif__status wuffs_gif__decoder__decode_lsd(
    wuffs_gif__decoder* self,
    wuffs_base__reader1 a_src) {
  wuffs_gif__status status = WUFFS_GIF__STATUS_OK;

  uint8_t v_c[7];
  uint32_t v_i;
  uint32_t v_gct_size;

  uint8_t* b_rptr_src = NULL;
  uint8_t* b_rstart_src = NULL;
  uint8_t* b_rend_src = NULL;
  if (a_src.buf) {
    b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
    b_rstart_src = b_rptr_src;
    uint64_t len = a_src.buf->wi - a_src.buf->ri;
    wuffs_base__limit1* lim;
    for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len && (len > *lim->ptr_to_len)) {
        len = *lim->ptr_to_len;
      }
    }
    b_rend_src = b_rptr_src + len;
  }

  uint32_t coro_susp_point = self->private_impl.c_decode_lsd[0].coro_susp_point;
  if (coro_susp_point) {
    memcpy(v_c, self->private_impl.c_decode_lsd[0].v_c, sizeof(v_c));
    v_i = self->private_impl.c_decode_lsd[0].v_i;
    v_gct_size = self->private_impl.c_decode_lsd[0].v_gct_size;
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    memset(v_c, 0, sizeof(v_c));
    v_i = 0;
    while (v_i < 7) {
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
        if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
          goto short_read_src;
        }
        uint8_t t_0 = *b_rptr_src++;
        v_c[v_i] = t_0;
      }
      v_i += 1;
    }
    self->private_impl.f_width =
        (((uint32_t)(v_c[0])) | (((uint32_t)(v_c[1])) << 8));
    self->private_impl.f_height =
        (((uint32_t)(v_c[2])) | (((uint32_t)(v_c[3])) << 8));
    self->private_impl.f_background_color_index = v_c[5];
    self->private_impl.f_have_gct = ((v_c[4] & 128) != 0);
    if (self->private_impl.f_have_gct) {
      v_gct_size = (((uint32_t)(1)) << (1 + (v_c[4] & 7)));
      v_i = 0;
      while (v_i < v_gct_size) {
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
          if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
            goto short_read_src;
          }
          uint8_t t_1 = *b_rptr_src++;
          self->private_impl.f_gct[(3 * v_i) + 0] = t_1;
        }
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
          if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
            goto short_read_src;
          }
          uint8_t t_2 = *b_rptr_src++;
          self->private_impl.f_gct[(3 * v_i) + 1] = t_2;
        }
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(4);
          if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
            goto short_read_src;
          }
          uint8_t t_3 = *b_rptr_src++;
          self->private_impl.f_gct[(3 * v_i) + 2] = t_3;
        }
        v_i += 1;
      }
    }

    goto ok;
  ok:
    self->private_impl.c_decode_lsd[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_lsd[0].coro_susp_point = coro_susp_point;
  memcpy(self->private_impl.c_decode_lsd[0].v_c, v_c, sizeof(v_c));
  self->private_impl.c_decode_lsd[0].v_i = v_i;
  self->private_impl.c_decode_lsd[0].v_gct_size = v_gct_size;

exit:
  if (a_src.buf) {
    size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
    a_src.buf->ri += n;
    wuffs_base__limit1* lim;
    for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len) {
        *lim->ptr_to_len -= n;
      }
    }
    WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rstart_src);
    WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rend_src);
  }

  return status;

short_read_src:
  if (a_src.buf && a_src.buf->closed && !a_src.private_impl.limit.ptr_to_len) {
    status = WUFFS_GIF__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_GIF__SUSPENSION_SHORT_READ;
  goto suspend;
}

static wuffs_gif__status wuffs_gif__decoder__decode_extension(
    wuffs_gif__decoder* self,
    wuffs_base__reader1 a_src) {
  wuffs_gif__status status = WUFFS_GIF__STATUS_OK;

  uint8_t v_label;

  uint8_t* b_rptr_src = NULL;
  uint8_t* b_rstart_src = NULL;
  uint8_t* b_rend_src = NULL;
  if (a_src.buf) {
    b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
    b_rstart_src = b_rptr_src;
    uint64_t len = a_src.buf->wi - a_src.buf->ri;
    wuffs_base__limit1* lim;
    for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len && (len > *lim->ptr_to_len)) {
        len = *lim->ptr_to_len;
      }
    }
    b_rend_src = b_rptr_src + len;
  }

  uint32_t coro_susp_point =
      self->private_impl.c_decode_extension[0].coro_susp_point;
  if (coro_susp_point) {
    v_label = self->private_impl.c_decode_extension[0].v_label;
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
      if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
        goto short_read_src;
      }
      uint8_t t_0 = *b_rptr_src++;
      v_label = t_0;
    }
    if (v_label == 249) {
    } else if (v_label == 255) {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
      if (a_src.buf) {
        size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
        a_src.buf->ri += n;
        wuffs_base__limit1* lim;
        for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
          if (lim->ptr_to_len) {
            *lim->ptr_to_len -= n;
          }
        }
      }
      status = wuffs_gif__decoder__decode_ae(self, a_src);
      if (a_src.buf) {
        b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
      }
      if (status) {
        goto suspend;
      }
      status = WUFFS_GIF__STATUS_OK;
      goto ok;
    }
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
    if (a_src.buf) {
      size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
      a_src.buf->ri += n;
      wuffs_base__limit1* lim;
      for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
        if (lim->ptr_to_len) {
          *lim->ptr_to_len -= n;
        }
      }
    }
    status = wuffs_gif__decoder__skip_blocks(self, a_src);
    if (a_src.buf) {
      b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
    }
    if (status) {
      goto suspend;
    }

    goto ok;
  ok:
    self->private_impl.c_decode_extension[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_extension[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode_extension[0].v_label = v_label;

exit:
  if (a_src.buf) {
    size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
    a_src.buf->ri += n;
    wuffs_base__limit1* lim;
    for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len) {
        *lim->ptr_to_len -= n;
      }
    }
    WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rstart_src);
    WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rend_src);
  }

  return status;

short_read_src:
  if (a_src.buf && a_src.buf->closed && !a_src.private_impl.limit.ptr_to_len) {
    status = WUFFS_GIF__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_GIF__SUSPENSION_SHORT_READ;
  goto suspend;
}

static wuffs_gif__status wuffs_gif__decoder__skip_blocks(
    wuffs_gif__decoder* self,
    wuffs_base__reader1 a_src) {
  wuffs_gif__status status = WUFFS_GIF__STATUS_OK;

  uint8_t v_block_size;

  uint8_t* b_rptr_src = NULL;
  uint8_t* b_rstart_src = NULL;
  uint8_t* b_rend_src = NULL;
  if (a_src.buf) {
    b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
    b_rstart_src = b_rptr_src;
    uint64_t len = a_src.buf->wi - a_src.buf->ri;
    wuffs_base__limit1* lim;
    for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len && (len > *lim->ptr_to_len)) {
        len = *lim->ptr_to_len;
      }
    }
    b_rend_src = b_rptr_src + len;
  }

  uint32_t coro_susp_point =
      self->private_impl.c_skip_blocks[0].coro_susp_point;
  if (coro_susp_point) {
    v_block_size = self->private_impl.c_skip_blocks[0].v_block_size;
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    while (true) {
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
        if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
          goto short_read_src;
        }
        uint8_t t_0 = *b_rptr_src++;
        v_block_size = t_0;
      }
      if (v_block_size == 0) {
        status = WUFFS_GIF__STATUS_OK;
        goto ok;
      }
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
      self->private_impl.c_skip_blocks[0].scratch = ((uint32_t)(v_block_size));
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
      if (self->private_impl.c_skip_blocks[0].scratch >
          b_rend_src - b_rptr_src) {
        self->private_impl.c_skip_blocks[0].scratch -= b_rend_src - b_rptr_src;
        b_rptr_src = b_rend_src;
        goto short_read_src;
      }
      b_rptr_src += self->private_impl.c_skip_blocks[0].scratch;
    }

    goto ok;
  ok:
    self->private_impl.c_skip_blocks[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_skip_blocks[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_skip_blocks[0].v_block_size = v_block_size;

exit:
  if (a_src.buf) {
    size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
    a_src.buf->ri += n;
    wuffs_base__limit1* lim;
    for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len) {
        *lim->ptr_to_len -= n;
      }
    }
    WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rstart_src);
    WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rend_src);
  }

  return status;

short_read_src:
  if (a_src.buf && a_src.buf->closed && !a_src.private_impl.limit.ptr_to_len) {
    status = WUFFS_GIF__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_GIF__SUSPENSION_SHORT_READ;
  goto suspend;
}

static wuffs_gif__status wuffs_gif__decoder__decode_ae(
    wuffs_gif__decoder* self,
    wuffs_base__reader1 a_src) {
  wuffs_gif__status status = WUFFS_GIF__STATUS_OK;

  uint8_t v_c;
  uint8_t v_block_size;
  bool v_not_animexts;
  bool v_not_netscape;

  uint8_t* b_rptr_src = NULL;
  uint8_t* b_rstart_src = NULL;
  uint8_t* b_rend_src = NULL;
  if (a_src.buf) {
    b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
    b_rstart_src = b_rptr_src;
    uint64_t len = a_src.buf->wi - a_src.buf->ri;
    wuffs_base__limit1* lim;
    for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len && (len > *lim->ptr_to_len)) {
        len = *lim->ptr_to_len;
      }
    }
    b_rend_src = b_rptr_src + len;
  }

  uint32_t coro_susp_point = self->private_impl.c_decode_ae[0].coro_susp_point;
  if (coro_susp_point) {
    v_c = self->private_impl.c_decode_ae[0].v_c;
    v_block_size = self->private_impl.c_decode_ae[0].v_block_size;
    v_not_animexts = self->private_impl.c_decode_ae[0].v_not_animexts;
    v_not_netscape = self->private_impl.c_decode_ae[0].v_not_netscape;
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    while (true) {
      v_c = 0;
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
        if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
          goto short_read_src;
        }
        uint8_t t_0 = *b_rptr_src++;
        v_block_size = t_0;
      }
      if (v_block_size == 0) {
        status = WUFFS_GIF__STATUS_OK;
        goto ok;
      }
      if (v_block_size != 11) {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
        self->private_impl.c_decode_ae[0].scratch = ((uint32_t)(v_block_size));
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
        if (self->private_impl.c_decode_ae[0].scratch >
            b_rend_src - b_rptr_src) {
          self->private_impl.c_decode_ae[0].scratch -= b_rend_src - b_rptr_src;
          b_rptr_src = b_rend_src;
          goto short_read_src;
        }
        b_rptr_src += self->private_impl.c_decode_ae[0].scratch;
        goto label_0_break;
      }
      v_not_animexts = 0;
      v_not_netscape = 0;
      v_block_size = 0;
      while (v_block_size < 11) {
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(4);
          if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
            goto short_read_src;
          }
          uint8_t t_1 = *b_rptr_src++;
          v_c = t_1;
        }
        v_not_animexts =
            (v_not_animexts || (v_c != wuffs_gif__animexts1dot0[v_block_size]));
        v_not_netscape =
            (v_not_netscape || (v_c != wuffs_gif__netscape2dot0[v_block_size]));
        v_block_size += 1;
      }
      if (v_not_animexts && v_not_netscape) {
        goto label_0_break;
      }
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(5);
        if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
          goto short_read_src;
        }
        uint8_t t_2 = *b_rptr_src++;
        v_block_size = t_2;
      }
      if (v_block_size != 3) {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(6);
        self->private_impl.c_decode_ae[0].scratch = ((uint32_t)(v_block_size));
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(7);
        if (self->private_impl.c_decode_ae[0].scratch >
            b_rend_src - b_rptr_src) {
          self->private_impl.c_decode_ae[0].scratch -= b_rend_src - b_rptr_src;
          b_rptr_src = b_rend_src;
          goto short_read_src;
        }
        b_rptr_src += self->private_impl.c_decode_ae[0].scratch;
        goto label_0_break;
      }
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(8);
        if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
          goto short_read_src;
        }
        uint8_t t_3 = *b_rptr_src++;
        v_c = t_3;
      }
      if (v_c != 1) {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(9);
        self->private_impl.c_decode_ae[0].scratch = 2;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(10);
        if (self->private_impl.c_decode_ae[0].scratch >
            b_rend_src - b_rptr_src) {
          self->private_impl.c_decode_ae[0].scratch -= b_rend_src - b_rptr_src;
          b_rptr_src = b_rend_src;
          goto short_read_src;
        }
        b_rptr_src += self->private_impl.c_decode_ae[0].scratch;
        goto label_0_break;
      }
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(11);
        uint16_t t_5;
        if (WUFFS_BASE__LIKELY(b_rend_src - b_rptr_src >= 2)) {
          t_5 = wuffs_base__load_u16le(b_rptr_src);
          b_rptr_src += 2;
        } else {
          self->private_impl.c_decode_ae[0].scratch = 0;
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(12);
          while (true) {
            if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
              goto short_read_src;
            }
            uint32_t t_4 = self->private_impl.c_decode_ae[0].scratch >> 56;
            self->private_impl.c_decode_ae[0].scratch <<= 8;
            self->private_impl.c_decode_ae[0].scratch >>= 8;
            self->private_impl.c_decode_ae[0].scratch |=
                ((uint64_t)(*b_rptr_src++)) << t_4;
            if (t_4 == 8) {
              t_5 = self->private_impl.c_decode_ae[0].scratch;
              break;
            }
            t_4 += 8;
            self->private_impl.c_decode_ae[0].scratch |= ((uint64_t)(t_4))
                                                         << 56;
          }
        }
        self->private_impl.f_num_loops = ((uint32_t)(t_5));
      }
      self->private_impl.f_seen_num_loops = true;
      if ((0 < self->private_impl.f_num_loops) &&
          (self->private_impl.f_num_loops <= 65535)) {
        self->private_impl.f_num_loops += 1;
      }
      goto label_0_break;
    }
  label_0_break:;
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(13);
    if (a_src.buf) {
      size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
      a_src.buf->ri += n;
      wuffs_base__limit1* lim;
      for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
        if (lim->ptr_to_len) {
          *lim->ptr_to_len -= n;
        }
      }
    }
    status = wuffs_gif__decoder__skip_blocks(self, a_src);
    if (a_src.buf) {
      b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
    }
    if (status) {
      goto suspend;
    }

    goto ok;
  ok:
    self->private_impl.c_decode_ae[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_ae[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode_ae[0].v_c = v_c;
  self->private_impl.c_decode_ae[0].v_block_size = v_block_size;
  self->private_impl.c_decode_ae[0].v_not_animexts = v_not_animexts;
  self->private_impl.c_decode_ae[0].v_not_netscape = v_not_netscape;

exit:
  if (a_src.buf) {
    size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
    a_src.buf->ri += n;
    wuffs_base__limit1* lim;
    for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len) {
        *lim->ptr_to_len -= n;
      }
    }
    WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rstart_src);
    WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rend_src);
  }

  return status;

short_read_src:
  if (a_src.buf && a_src.buf->closed && !a_src.private_impl.limit.ptr_to_len) {
    status = WUFFS_GIF__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_GIF__SUSPENSION_SHORT_READ;
  goto suspend;
}

static wuffs_gif__status wuffs_gif__decoder__decode_id(
    wuffs_gif__decoder* self,
    wuffs_base__writer1 a_dst,
    wuffs_base__reader1 a_src) {
  wuffs_gif__status status = WUFFS_GIF__STATUS_OK;

  uint8_t v_flags;
  uint32_t v_lct_size;
  uint32_t v_i;
  uint8_t v_lw;
  uint64_t v_block_size;
  wuffs_base__reader1 v_r;
  wuffs_gif__status v_z;

  uint8_t* b_rptr_src = NULL;
  uint8_t* b_rstart_src = NULL;
  uint8_t* b_rend_src = NULL;
  if (a_src.buf) {
    b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
    b_rstart_src = b_rptr_src;
    uint64_t len = a_src.buf->wi - a_src.buf->ri;
    wuffs_base__limit1* lim;
    for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len && (len > *lim->ptr_to_len)) {
        len = *lim->ptr_to_len;
      }
    }
    b_rend_src = b_rptr_src + len;
  }

  uint32_t coro_susp_point = self->private_impl.c_decode_id[0].coro_susp_point;
  if (coro_susp_point) {
    v_flags = self->private_impl.c_decode_id[0].v_flags;
    v_lct_size = self->private_impl.c_decode_id[0].v_lct_size;
    v_i = self->private_impl.c_decode_id[0].v_i;
    v_lw = self->private_impl.c_decode_id[0].v_lw;
    v_block_size = self->private_impl.c_decode_id[0].v_block_size;
    v_r = ((wuffs_base__reader1){});
    v_z = self->private_impl.c_decode_id[0].v_z;
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
      uint16_t t_1;
      if (WUFFS_BASE__LIKELY(b_rend_src - b_rptr_src >= 2)) {
        t_1 = wuffs_base__load_u16le(b_rptr_src);
        b_rptr_src += 2;
      } else {
        self->private_impl.c_decode_id[0].scratch = 0;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
        while (true) {
          if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
            goto short_read_src;
          }
          uint32_t t_0 = self->private_impl.c_decode_id[0].scratch >> 56;
          self->private_impl.c_decode_id[0].scratch <<= 8;
          self->private_impl.c_decode_id[0].scratch >>= 8;
          self->private_impl.c_decode_id[0].scratch |=
              ((uint64_t)(*b_rptr_src++)) << t_0;
          if (t_0 == 8) {
            t_1 = self->private_impl.c_decode_id[0].scratch;
            break;
          }
          t_0 += 8;
          self->private_impl.c_decode_id[0].scratch |= ((uint64_t)(t_0)) << 56;
        }
      }
      self->private_impl.f_frame_left = ((uint32_t)(t_1));
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
      uint16_t t_3;
      if (WUFFS_BASE__LIKELY(b_rend_src - b_rptr_src >= 2)) {
        t_3 = wuffs_base__load_u16le(b_rptr_src);
        b_rptr_src += 2;
      } else {
        self->private_impl.c_decode_id[0].scratch = 0;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(4);
        while (true) {
          if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
            goto short_read_src;
          }
          uint32_t t_2 = self->private_impl.c_decode_id[0].scratch >> 56;
          self->private_impl.c_decode_id[0].scratch <<= 8;
          self->private_impl.c_decode_id[0].scratch >>= 8;
          self->private_impl.c_decode_id[0].scratch |=
              ((uint64_t)(*b_rptr_src++)) << t_2;
          if (t_2 == 8) {
            t_3 = self->private_impl.c_decode_id[0].scratch;
            break;
          }
          t_2 += 8;
          self->private_impl.c_decode_id[0].scratch |= ((uint64_t)(t_2)) << 56;
        }
      }
      self->private_impl.f_frame_top = ((uint32_t)(t_3));
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(5);
      uint16_t t_5;
      if (WUFFS_BASE__LIKELY(b_rend_src - b_rptr_src >= 2)) {
        t_5 = wuffs_base__load_u16le(b_rptr_src);
        b_rptr_src += 2;
      } else {
        self->private_impl.c_decode_id[0].scratch = 0;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(6);
        while (true) {
          if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
            goto short_read_src;
          }
          uint32_t t_4 = self->private_impl.c_decode_id[0].scratch >> 56;
          self->private_impl.c_decode_id[0].scratch <<= 8;
          self->private_impl.c_decode_id[0].scratch >>= 8;
          self->private_impl.c_decode_id[0].scratch |=
              ((uint64_t)(*b_rptr_src++)) << t_4;
          if (t_4 == 8) {
            t_5 = self->private_impl.c_decode_id[0].scratch;
            break;
          }
          t_4 += 8;
          self->private_impl.c_decode_id[0].scratch |= ((uint64_t)(t_4)) << 56;
        }
      }
      self->private_impl.f_frame_width = ((uint32_t)(t_5));
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(7);
      uint16_t t_7;
      if (WUFFS_BASE__LIKELY(b_rend_src - b_rptr_src >= 2)) {
        t_7 = wuffs_base__load_u16le(b_rptr_src);
        b_rptr_src += 2;
      } else {
        self->private_impl.c_decode_id[0].scratch = 0;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(8);
        while (true) {
          if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
            goto short_read_src;
          }
          uint32_t t_6 = self->private_impl.c_decode_id[0].scratch >> 56;
          self->private_impl.c_decode_id[0].scratch <<= 8;
          self->private_impl.c_decode_id[0].scratch >>= 8;
          self->private_impl.c_decode_id[0].scratch |=
              ((uint64_t)(*b_rptr_src++)) << t_6;
          if (t_6 == 8) {
            t_7 = self->private_impl.c_decode_id[0].scratch;
            break;
          }
          t_6 += 8;
          self->private_impl.c_decode_id[0].scratch |= ((uint64_t)(t_6)) << 56;
        }
      }
      self->private_impl.f_frame_height = ((uint32_t)(t_7));
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(9);
      if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
        goto short_read_src;
      }
      uint8_t t_8 = *b_rptr_src++;
      v_flags = t_8;
    }
    self->private_impl.f_interlace = ((v_flags & 64) != 0);
    self->private_impl.f_have_lct = ((v_flags & 128) != 0);
    if (self->private_impl.f_have_lct) {
      v_lct_size = (((uint32_t)(1)) << (1 + (v_flags & 7)));
      v_i = 0;
      while (v_i < v_lct_size) {
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(10);
          if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
            goto short_read_src;
          }
          uint8_t t_9 = *b_rptr_src++;
          self->private_impl.f_lct[(3 * v_i) + 0] = t_9;
        }
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(11);
          if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
            goto short_read_src;
          }
          uint8_t t_10 = *b_rptr_src++;
          self->private_impl.f_lct[(3 * v_i) + 1] = t_10;
        }
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(12);
          if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
            goto short_read_src;
          }
          uint8_t t_11 = *b_rptr_src++;
          self->private_impl.f_lct[(3 * v_i) + 2] = t_11;
        }
        v_i += 1;
      }
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(13);
      if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
        goto short_read_src;
      }
      uint8_t t_12 = *b_rptr_src++;
      v_lw = t_12;
    }
    if ((v_lw < 2) || (8 < v_lw)) {
      status = WUFFS_GIF__ERROR_BAD_LZW_LITERAL_WIDTH;
      goto exit;
    }
    wuffs_gif__lzw_decoder__set_literal_width(&self->private_impl.f_lzw,
                                              ((uint32_t)(v_lw)));
    while (true) {
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(14);
        if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
          goto short_read_src;
        }
        uint8_t t_13 = *b_rptr_src++;
        v_block_size = ((uint64_t)(t_13));
      }
      if (v_block_size == 0) {
        goto label_0_break;
      }
      while (true) {
        v_r = a_src;
        wuffs_base__reader1__mark(&v_r, b_rptr_src);
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(15);
          if (a_src.buf) {
            size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
            a_src.buf->ri += n;
            wuffs_base__limit1* lim;
            for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
              if (lim->ptr_to_len) {
                *lim->ptr_to_len -= n;
              }
            }
          }
          uint64_t l_rlimit0 = v_block_size;
          wuffs_gif__status t_14 = wuffs_gif__lzw_decoder__decode(
              &self->private_impl.f_lzw, a_dst,
              wuffs_base__reader1__limit(&v_r, &l_rlimit0));
          if (a_src.buf) {
            b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
          }
          v_z = t_14;
        }
        if (v_z == 0) {
          goto label_1_break;
        }
        if (v_block_size <
            ((uint64_t)(
                ((wuffs_base__slice_u8){
                     .ptr = v_r.private_impl.mark,
                     .len = v_r.private_impl.mark
                                ? (size_t)(b_rptr_src - v_r.private_impl.mark)
                                : 0,
                 })
                    .len))) {
          status = WUFFS_GIF__ERROR_INTERNAL_ERROR_INCONSISTENT_LIMITED_READ;
          goto exit;
        }
        v_block_size -= ((uint64_t)(
            ((wuffs_base__slice_u8){
                 .ptr = v_r.private_impl.mark,
                 .len = v_r.private_impl.mark
                            ? (size_t)(b_rptr_src - v_r.private_impl.mark)
                            : 0,
             })
                .len));
        if ((v_block_size == 0) && (v_z == WUFFS_GIF__SUSPENSION_SHORT_READ)) {
          goto label_1_break;
        }
        status = v_z;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(16);
      }
    label_1_break:;
    }
  label_0_break:;

    goto ok;
  ok:
    self->private_impl.c_decode_id[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_id[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode_id[0].v_flags = v_flags;
  self->private_impl.c_decode_id[0].v_lct_size = v_lct_size;
  self->private_impl.c_decode_id[0].v_i = v_i;
  self->private_impl.c_decode_id[0].v_lw = v_lw;
  self->private_impl.c_decode_id[0].v_block_size = v_block_size;
  self->private_impl.c_decode_id[0].v_z = v_z;

exit:
  if (a_src.buf) {
    size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
    a_src.buf->ri += n;
    wuffs_base__limit1* lim;
    for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len) {
        *lim->ptr_to_len -= n;
      }
    }
    WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rstart_src);
    WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rend_src);
  }

  return status;

short_read_src:
  if (a_src.buf && a_src.buf->closed && !a_src.private_impl.limit.ptr_to_len) {
    status = WUFFS_GIF__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_GIF__SUSPENSION_SHORT_READ;
  goto suspend;
}

static void wuffs_gif__lzw_decoder__set_literal_width(
    wuffs_gif__lzw_decoder* self,
    uint32_t a_lw) {
  self->private_impl.f_literal_width = a_lw;
}

static wuffs_gif__status wuffs_gif__lzw_decoder__decode(
    wuffs_gif__lzw_decoder* self,
    wuffs_base__writer1 a_dst,
    wuffs_base__reader1 a_src) {
  wuffs_gif__status status = WUFFS_GIF__STATUS_OK;

  uint32_t v_clear_code;
  uint32_t v_end_code;
  uint32_t v_save_code;
  uint32_t v_prev_code;
  uint32_t v_width;
  uint32_t v_bits;
  uint32_t v_n_bits;
  uint32_t v_code;
  uint32_t v_s;
  uint32_t v_c;
  wuffs_base__slice_u8 v_expansion;
  uint64_t v_n_copied;

  uint8_t* b_wptr_dst = NULL;
  uint8_t* b_wstart_dst = NULL;
  uint8_t* b_wend_dst = NULL;
  if (a_dst.buf) {
    b_wptr_dst = a_dst.buf->ptr + a_dst.buf->wi;
    b_wstart_dst = b_wptr_dst;
    b_wend_dst = b_wptr_dst;
    if (!a_dst.buf->closed) {
      uint64_t len = a_dst.buf->len - a_dst.buf->wi;
      wuffs_base__limit1* lim;
      for (lim = &a_dst.private_impl.limit; lim; lim = lim->next) {
        if (lim->ptr_to_len && (len > *lim->ptr_to_len)) {
          len = *lim->ptr_to_len;
        }
      }
      b_wend_dst += len;
    }
  }
  uint8_t* b_rptr_src = NULL;
  uint8_t* b_rstart_src = NULL;
  uint8_t* b_rend_src = NULL;
  if (a_src.buf) {
    b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
    b_rstart_src = b_rptr_src;
    uint64_t len = a_src.buf->wi - a_src.buf->ri;
    wuffs_base__limit1* lim;
    for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len && (len > *lim->ptr_to_len)) {
        len = *lim->ptr_to_len;
      }
    }
    b_rend_src = b_rptr_src + len;
  }

  uint32_t coro_susp_point = self->private_impl.c_decode[0].coro_susp_point;
  if (coro_susp_point) {
    v_clear_code = self->private_impl.c_decode[0].v_clear_code;
    v_end_code = self->private_impl.c_decode[0].v_end_code;
    v_save_code = self->private_impl.c_decode[0].v_save_code;
    v_prev_code = self->private_impl.c_decode[0].v_prev_code;
    v_width = self->private_impl.c_decode[0].v_width;
    v_bits = self->private_impl.c_decode[0].v_bits;
    v_n_bits = self->private_impl.c_decode[0].v_n_bits;
    v_code = self->private_impl.c_decode[0].v_code;
    v_s = self->private_impl.c_decode[0].v_s;
    v_c = self->private_impl.c_decode[0].v_c;
    v_expansion = ((wuffs_base__slice_u8){});
    v_n_copied = self->private_impl.c_decode[0].v_n_copied;
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    v_clear_code = (((uint32_t)(1)) << self->private_impl.f_literal_width);
    v_end_code = (v_clear_code + 1);
    v_save_code = v_end_code;
    v_prev_code = 0;
    v_width = (self->private_impl.f_literal_width + 1);
    v_bits = 0;
    v_n_bits = 0;
  label_0_continue:;
    while (true) {
      while (v_n_bits < v_width) {
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
          if (WUFFS_BASE__UNLIKELY(b_rptr_src == b_rend_src)) {
            goto short_read_src;
          }
          uint8_t t_0 = *b_rptr_src++;
          v_bits |= (((uint32_t)(t_0)) << v_n_bits);
        }
        v_n_bits += 8;
      }
      v_code = ((v_bits) & ((1 << (v_width)) - 1));
      v_bits >>= v_width;
      v_n_bits -= v_width;
      if (v_code < v_clear_code) {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
        if (b_wptr_dst == b_wend_dst) {
          status = WUFFS_GIF__SUSPENSION_SHORT_WRITE;
          goto suspend;
        }
        *b_wptr_dst++ = ((uint8_t)(v_code));
        if (v_save_code <= 4095) {
          self->private_impl.f_suffixes[v_save_code] = ((uint8_t)(v_code));
          self->private_impl.f_prefixes[v_save_code] =
              ((uint16_t)(v_prev_code));
        }
      } else if (v_code == v_clear_code) {
        v_save_code = v_end_code;
        v_prev_code = 0;
        v_width = (self->private_impl.f_literal_width + 1);
        goto label_0_continue;
      } else if (v_code == v_end_code) {
        status = WUFFS_GIF__STATUS_OK;
        goto ok;
      } else if (v_code <= v_save_code) {
        v_s = 4095;
        v_c = v_code;
        if (v_code == v_save_code) {
          v_s -= 1;
          v_c = v_prev_code;
        }
        while (v_c >= v_clear_code) {
          self->private_impl.f_stack[v_s] = self->private_impl.f_suffixes[v_c];
          if (v_s == 0) {
            status = WUFFS_GIF__ERROR_LZW_PREFIX_CHAIN_IS_CYCLICAL;
            goto exit;
          }
          v_s -= 1;
          v_c = ((uint32_t)(self->private_impl.f_prefixes[v_c]));
        }
        self->private_impl.f_stack[v_s] = ((uint8_t)(v_c));
        if (v_code == v_save_code) {
          self->private_impl.f_stack[4095] = ((uint8_t)(v_c));
        }
        while (true) {
          v_expansion = wuffs_base__slice_u8__subslice_i(
              ((wuffs_base__slice_u8){.ptr = self->private_impl.f_stack,
                                      .len = 4096}),
              v_s);
          v_n_copied = wuffs_base__writer1__copy_from_slice(
              &b_wptr_dst, b_wend_dst, v_expansion);
          if (v_n_copied == ((uint64_t)(v_expansion.len))) {
            goto label_1_break;
          }
          v_s = ((v_s + ((uint32_t)((v_n_copied & 4095)))) & 4095);
          status = WUFFS_GIF__SUSPENSION_SHORT_WRITE;
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(3);
        }
      label_1_break:;
        if (v_save_code <= 4095) {
          self->private_impl.f_suffixes[v_save_code] = ((uint8_t)(v_c));
          self->private_impl.f_prefixes[v_save_code] =
              ((uint16_t)(v_prev_code));
        }
      } else {
        status = WUFFS_GIF__ERROR_LZW_CODE_IS_OUT_OF_RANGE;
        goto exit;
      }
      if (v_save_code <= 4095) {
        v_save_code += 1;
        if ((v_save_code == (((uint32_t)(1)) << v_width)) && (v_width < 12)) {
          v_width += 1;
        }
      }
      v_prev_code = v_code;
    }

    goto ok;
  ok:
    self->private_impl.c_decode[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode[0].v_clear_code = v_clear_code;
  self->private_impl.c_decode[0].v_end_code = v_end_code;
  self->private_impl.c_decode[0].v_save_code = v_save_code;
  self->private_impl.c_decode[0].v_prev_code = v_prev_code;
  self->private_impl.c_decode[0].v_width = v_width;
  self->private_impl.c_decode[0].v_bits = v_bits;
  self->private_impl.c_decode[0].v_n_bits = v_n_bits;
  self->private_impl.c_decode[0].v_code = v_code;
  self->private_impl.c_decode[0].v_s = v_s;
  self->private_impl.c_decode[0].v_c = v_c;
  self->private_impl.c_decode[0].v_n_copied = v_n_copied;

exit:
  if (a_dst.buf) {
    size_t n = b_wptr_dst - (a_dst.buf->ptr + a_dst.buf->wi);
    a_dst.buf->wi += n;
    wuffs_base__limit1* lim;
    for (lim = &a_dst.private_impl.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len) {
        *lim->ptr_to_len -= n;
      }
    }
    WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_wstart_dst);
    WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_wend_dst);
  }
  if (a_src.buf) {
    size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
    a_src.buf->ri += n;
    wuffs_base__limit1* lim;
    for (lim = &a_src.private_impl.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len) {
        *lim->ptr_to_len -= n;
      }
    }
    WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rstart_src);
    WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rend_src);
  }

  return status;

short_read_src:
  if (a_src.buf && a_src.buf->closed && !a_src.private_impl.limit.ptr_to_len) {
    status = WUFFS_GIF__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_GIF__SUSPENSION_SHORT_READ;
  goto suspend;
}
