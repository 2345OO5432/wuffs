#ifndef WUFFS_GIF_H
#define WUFFS_GIF_H

// Code generated by wuffs-c. DO NOT EDIT.

#ifndef WUFFS_BASE_HEADER_H
#define WUFFS_BASE_HEADER_H

// Copyright 2017 The Wuffs Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <stdbool.h>
#include <stdint.h>
#include <string.h>

// Wuffs assumes that:
//  - converting a uint32_t to a size_t will never overflow.
//  - converting a size_t to a uint64_t will never overflow.
#if (__WORDSIZE != 32) && (__WORDSIZE != 64)
#error "Wuffs requires a word size of either 32 or 64 bits"
#endif

// WUFFS_VERSION is the major.minor version number as a uint32_t. The major
// number is the high 16 bits. The minor number is the low 16 bits.
//
// The intention is to bump the version number at least on every API / ABI
// backwards incompatible change.
//
// For now, the API and ABI are simply unstable and can change at any time.
//
// TODO: don't hard code this in base-header.h.
#define WUFFS_VERSION ((uint32_t)0x00001)

// wuffs_base__empty_struct is used when a Wuffs function returns an empty
// struct. In C, if a function f returns void, you can't say "x = f()", but in
// Wuffs, if a function g returns empty, you can say "y = g()".
typedef struct {
} wuffs_base__empty_struct;

// ---------------- Numeric Types

// Flicks are a unit of time. One flick (frame-tick) is 1 / 705_600_000 of a
// second. See https://github.com/OculusVR/Flicks
typedef uint64_t wuffs_base__flicks;

#define WUFFS_BASE__FLICKS_PER_SECOND ((uint64_t)705600000)
#define WUFFS_BASE__FLICKS_PER_MILLISECOND ((uint64_t)705600)

// --------

static inline uint8_t wuffs_base__u8__min(uint8_t x, uint8_t y) {
  return x < y ? x : y;
}

static inline uint8_t wuffs_base__u8__max(uint8_t x, uint8_t y) {
  return x > y ? x : y;
}

static inline uint16_t wuffs_base__u16__min(uint16_t x, uint16_t y) {
  return x < y ? x : y;
}

static inline uint16_t wuffs_base__u16__max(uint16_t x, uint16_t y) {
  return x > y ? x : y;
}

static inline uint32_t wuffs_base__u32__min(uint32_t x, uint32_t y) {
  return x < y ? x : y;
}

static inline uint32_t wuffs_base__u32__max(uint32_t x, uint32_t y) {
  return x > y ? x : y;
}

static inline uint64_t wuffs_base__u64__min(uint64_t x, uint64_t y) {
  return x < y ? x : y;
}

static inline uint64_t wuffs_base__u64__max(uint64_t x, uint64_t y) {
  return x > y ? x : y;
}

// --------

// Saturating arithmetic (sat_add, sat_sub) branchless bit-twiddling algorithms
// are per https://locklessinc.com/articles/sat_arithmetic/
//
// It is important that the underlying types are unsigned integers, as signed
// integer arithmetic overflow is undefined behavior in C.

static inline uint8_t wuffs_base__u8__sat_add(uint8_t x, uint8_t y) {
  uint8_t res = x + y;
  res |= -(res < x);
  return res;
}

static inline uint8_t wuffs_base__u8__sat_sub(uint8_t x, uint8_t y) {
  uint8_t res = x - y;
  res &= -(res <= x);
  return res;
}

static inline uint16_t wuffs_base__u16__sat_add(uint16_t x, uint16_t y) {
  uint16_t res = x + y;
  res |= -(res < x);
  return res;
}

static inline uint16_t wuffs_base__u16__sat_sub(uint16_t x, uint16_t y) {
  uint16_t res = x - y;
  res &= -(res <= x);
  return res;
}

static inline uint32_t wuffs_base__u32__sat_add(uint32_t x, uint32_t y) {
  uint32_t res = x + y;
  res |= -(res < x);
  return res;
}

static inline uint32_t wuffs_base__u32__sat_sub(uint32_t x, uint32_t y) {
  uint32_t res = x - y;
  res &= -(res <= x);
  return res;
}

static inline uint64_t wuffs_base__u64__sat_add(uint64_t x, uint64_t y) {
  uint64_t res = x + y;
  res |= -(res < x);
  return res;
}

static inline uint64_t wuffs_base__u64__sat_sub(uint64_t x, uint64_t y) {
  uint64_t res = x - y;
  res &= -(res <= x);
  return res;
}

// --------

// Clang also defines "__GNUC__".

static inline uint16_t wuffs_base__u16__byte_swapped(uint16_t x) {
#if defined(__GNUC__)
  return __builtin_bswap16(x);
#else
  return (x >> 8) | (x << 8);
#endif
}

static inline uint32_t wuffs_base__u32__byte_swapped(uint32_t x) {
#if defined(__GNUC__)
  return __builtin_bswap32(x);
#else
  static const uint32_t mask8 = 0x00FF00FF;
  x = ((x >> 8) & mask8) | ((x & mask8) << 8);
  return (x >> 16) | (x << 16);
#endif
}

static inline uint64_t wuffs_base__u64__byte_swapped(uint64_t x) {
#if defined(__GNUC__)
  return __builtin_bswap64(x);
#else
  static const uint64_t mask8 = 0x00FF00FF00FF00FF;
  static const uint64_t mask16 = 0x0000FFFF0000FFFF;
  x = ((x >> 8) & mask8) | ((x & mask8) << 8);
  x = ((x >> 16) & mask16) | ((x & mask16) << 16);
  return (x >> 32) | (x << 32);
#endif
}

// ---------------- Slices and Tables

// WUFFS_BASE__SLICE is a 1-dimensional buffer.
//
// A value with all fields NULL or zero is a valid, empty slice.
#define WUFFS_BASE__SLICE(T) \
  struct {                   \
    T* ptr;                  \
    size_t len;              \
  }

// WUFFS_BASE__TABLE is a 2-dimensional buffer.
//
// A value with all fields NULL or zero is a valid, empty table.
#define WUFFS_BASE__TABLE(T) \
  struct {                   \
    T* ptr;                  \
    size_t width;            \
    size_t height;           \
    size_t stride;           \
  }

typedef WUFFS_BASE__SLICE(uint8_t) wuffs_base__slice_u8;
typedef WUFFS_BASE__SLICE(uint16_t) wuffs_base__slice_u16;
typedef WUFFS_BASE__SLICE(uint32_t) wuffs_base__slice_u32;
typedef WUFFS_BASE__SLICE(uint64_t) wuffs_base__slice_u64;

typedef WUFFS_BASE__TABLE(uint8_t) wuffs_base__table_u8;
typedef WUFFS_BASE__TABLE(uint16_t) wuffs_base__table_u16;
typedef WUFFS_BASE__TABLE(uint32_t) wuffs_base__table_u32;
typedef WUFFS_BASE__TABLE(uint64_t) wuffs_base__table_u64;

// ---------------- Ranges and Rects

// Ranges are either inclusive ("range_ii") or exclusive ("range_ie") on the
// high end. Both the "ii" and "ie" flavors are useful in practice.
//
// The "ei" and "ee" flavors also exist in theory, but aren't widely used. In
// Wuffs, the low end is always inclusive.
//
// The "ii" (closed interval) flavor is useful when refining e.g. "the set of
// all uint32_t values" to a contiguous subset: "uint32_t values in the closed
// interval [M, N]", for uint32_t values M and N. An unrefined type (in other
// words, the set of all uint32_t values) is not representable in the "ie"
// flavor because if N equals ((1<<32) - 1) then (N + 1) will overflow.
//
// On the other hand, the "ie" (half-open interval) flavor is recommended by
// Dijkstra's "Why numbering should start at zero" at
// http://www.cs.utexas.edu/users/EWD/ewd08xx/EWD831.PDF and a further
// discussion of motivating rationale is at
// https://www.quora.com/Why-are-Python-ranges-half-open-exclusive-instead-of-closed-inclusive
//
// For example, with "ie", the number of elements in "uint32_t values in the
// half-open interval [M, N)" is equal to max(0, N-M). Furthermore, that number
// of elements (in one dimension, a length, in two dimensions, a width or
// height) is itself representable as a uint32_t without overflow, again for
// uint32_t values M and N. In the contrasting "ii" flavor, the length of the
// closed interval [0, (1<<32) - 1] is 1<<32, which cannot be represented as a
// uint32_t. In Wuffs, because of this potential overflow, the "ie" flavor has
// length / width / height methods, but the "ii" flavor does not.
//
// It is valid for min > max (for range_ii) or for min >= max (for range_ie),
// in which case the range is empty. There are multiple representations of an
// empty range.

typedef struct {
  uint32_t min_inclusive;
  uint32_t max_inclusive;
} wuffs_base__range_ii_u32;

static inline bool wuffs_base__range_ii_u32__is_empty(
    wuffs_base__range_ii_u32 r) {
  return r.min_inclusive > r.max_inclusive;
}

static inline bool wuffs_base__range_ii_u32__equals(
    wuffs_base__range_ii_u32 r,
    wuffs_base__range_ii_u32 s) {
  return (r.min_inclusive == s.min_inclusive &&
          r.max_inclusive == s.max_inclusive) ||
         (wuffs_base__range_ii_u32__is_empty(r) &&
          wuffs_base__range_ii_u32__is_empty(s));
}

static inline bool wuffs_base__range_ii_u32__contains(
    wuffs_base__range_ii_u32 r,
    uint32_t x) {
  return (r.min_inclusive <= x) && (x <= r.max_inclusive);
}

static inline wuffs_base__range_ii_u32 wuffs_base__range_ii_u32__intersection(
    wuffs_base__range_ii_u32 r,
    wuffs_base__range_ii_u32 s) {
  r.min_inclusive = wuffs_base__u32__max(r.min_inclusive, s.min_inclusive);
  r.max_inclusive = wuffs_base__u32__min(r.max_inclusive, s.max_inclusive);
  return r;
}

static inline wuffs_base__range_ii_u32 wuffs_base__range_ii_u32__union(
    wuffs_base__range_ii_u32 r,
    wuffs_base__range_ii_u32 s) {
  if (wuffs_base__range_ii_u32__is_empty(r)) {
    return s;
  }
  if (wuffs_base__range_ii_u32__is_empty(s)) {
    return r;
  }
  r.min_inclusive = wuffs_base__u32__min(r.min_inclusive, s.min_inclusive);
  r.max_inclusive = wuffs_base__u32__max(r.max_inclusive, s.max_inclusive);
  return r;
}

// --------

typedef struct {
  uint32_t min_inclusive;
  uint32_t max_exclusive;
} wuffs_base__range_ie_u32;

static inline bool wuffs_base__range_ie_u32__is_empty(
    wuffs_base__range_ie_u32 r) {
  return r.min_inclusive >= r.max_exclusive;
}

static inline bool wuffs_base__range_ie_u32__equals(
    wuffs_base__range_ie_u32 r,
    wuffs_base__range_ie_u32 s) {
  return (r.min_inclusive == s.min_inclusive &&
          r.max_exclusive == s.max_exclusive) ||
         (wuffs_base__range_ie_u32__is_empty(r) &&
          wuffs_base__range_ie_u32__is_empty(s));
}

static inline bool wuffs_base__range_ie_u32__contains(
    wuffs_base__range_ie_u32 r,
    uint32_t x) {
  return (r.min_inclusive <= x) && (x < r.max_exclusive);
}

static inline wuffs_base__range_ie_u32 wuffs_base__range_ie_u32__intersection(
    wuffs_base__range_ie_u32 r,
    wuffs_base__range_ie_u32 s) {
  r.min_inclusive = wuffs_base__u32__max(r.min_inclusive, s.min_inclusive);
  r.max_exclusive = wuffs_base__u32__min(r.max_exclusive, s.max_exclusive);
  return r;
}

static inline wuffs_base__range_ie_u32 wuffs_base__range_ie_u32__union(
    wuffs_base__range_ie_u32 r,
    wuffs_base__range_ie_u32 s) {
  if (wuffs_base__range_ie_u32__is_empty(r)) {
    return s;
  }
  if (wuffs_base__range_ie_u32__is_empty(s)) {
    return r;
  }
  r.min_inclusive = wuffs_base__u32__min(r.min_inclusive, s.min_inclusive);
  r.max_exclusive = wuffs_base__u32__max(r.max_exclusive, s.max_exclusive);
  return r;
}

static inline uint32_t wuffs_base__range_ie_u32__length(
    wuffs_base__range_ie_u32 r) {
  return wuffs_base__u32__sat_sub(r.max_exclusive, r.min_inclusive);
}

// --------

typedef struct {
  uint64_t min_inclusive;
  uint64_t max_inclusive;
} wuffs_base__range_ii_u64;

static inline bool wuffs_base__range_ii_u64__is_empty(
    wuffs_base__range_ii_u64 r) {
  return r.min_inclusive > r.max_inclusive;
}

static inline bool wuffs_base__range_ii_u64__equals(
    wuffs_base__range_ii_u64 r,
    wuffs_base__range_ii_u64 s) {
  return (r.min_inclusive == s.min_inclusive &&
          r.max_inclusive == s.max_inclusive) ||
         (wuffs_base__range_ii_u64__is_empty(r) &&
          wuffs_base__range_ii_u64__is_empty(s));
}

static inline bool wuffs_base__range_ii_u64__contains(
    wuffs_base__range_ii_u64 r,
    uint64_t x) {
  return (r.min_inclusive <= x) && (x <= r.max_inclusive);
}

static inline wuffs_base__range_ii_u64 wuffs_base__range_ii_u64__intersection(
    wuffs_base__range_ii_u64 r,
    wuffs_base__range_ii_u64 s) {
  r.min_inclusive = wuffs_base__u64__max(r.min_inclusive, s.min_inclusive);
  r.max_inclusive = wuffs_base__u64__min(r.max_inclusive, s.max_inclusive);
  return r;
}

static inline wuffs_base__range_ii_u64 wuffs_base__range_ii_u64__union(
    wuffs_base__range_ii_u64 r,
    wuffs_base__range_ii_u64 s) {
  if (wuffs_base__range_ii_u64__is_empty(r)) {
    return s;
  }
  if (wuffs_base__range_ii_u64__is_empty(s)) {
    return r;
  }
  r.min_inclusive = wuffs_base__u64__min(r.min_inclusive, s.min_inclusive);
  r.max_inclusive = wuffs_base__u64__max(r.max_inclusive, s.max_inclusive);
  return r;
}

// --------

typedef struct {
  uint64_t min_inclusive;
  uint64_t max_exclusive;
} wuffs_base__range_ie_u64;

static inline bool wuffs_base__range_ie_u64__is_empty(
    wuffs_base__range_ie_u64 r) {
  return r.min_inclusive >= r.max_exclusive;
}

static inline bool wuffs_base__range_ie_u64__equals(
    wuffs_base__range_ie_u64 r,
    wuffs_base__range_ie_u64 s) {
  return (r.min_inclusive == s.min_inclusive &&
          r.max_exclusive == s.max_exclusive) ||
         (wuffs_base__range_ie_u64__is_empty(r) &&
          wuffs_base__range_ie_u64__is_empty(s));
}

static inline bool wuffs_base__range_ie_u64__contains(
    wuffs_base__range_ie_u64 r,
    uint64_t x) {
  return (r.min_inclusive <= x) && (x < r.max_exclusive);
}

static inline wuffs_base__range_ie_u64 wuffs_base__range_ie_u64__intersection(
    wuffs_base__range_ie_u64 r,
    wuffs_base__range_ie_u64 s) {
  r.min_inclusive = wuffs_base__u64__max(r.min_inclusive, s.min_inclusive);
  r.max_exclusive = wuffs_base__u64__min(r.max_exclusive, s.max_exclusive);
  return r;
}

static inline wuffs_base__range_ie_u64 wuffs_base__range_ie_u64__union(
    wuffs_base__range_ie_u64 r,
    wuffs_base__range_ie_u64 s) {
  if (wuffs_base__range_ie_u64__is_empty(r)) {
    return s;
  }
  if (wuffs_base__range_ie_u64__is_empty(s)) {
    return r;
  }
  r.min_inclusive = wuffs_base__u64__min(r.min_inclusive, s.min_inclusive);
  r.max_exclusive = wuffs_base__u64__max(r.max_exclusive, s.max_exclusive);
  return r;
}

static inline uint64_t wuffs_base__range_ie_u64__length(
    wuffs_base__range_ie_u64 r) {
  return wuffs_base__u64__sat_sub(r.max_exclusive, r.min_inclusive);
}

// --------

// wuffs_base__rect_ii_u32 is a rectangle (a 2-dimensional range) on the
// integer grid. The "ii" means that the bounds are inclusive on the low end
// and inclusive on the high end. It contains all points (x, y) such that
// ((min_inclusive_x <= x) && (x <= max_inclusive_x)) and likewise for y.
//
// It is valid for min > max, in which case the rectangle is empty. There are
// multiple representations of an empty rectangle.
//
// The X and Y axes increase right and down.
typedef struct {
  uint32_t min_inclusive_x;
  uint32_t min_inclusive_y;
  uint32_t max_inclusive_x;
  uint32_t max_inclusive_y;
} wuffs_base__rect_ii_u32;

static inline bool wuffs_base__rect_ii_u32__is_empty(
    wuffs_base__rect_ii_u32 r) {
  return (r.min_inclusive_x > r.max_inclusive_x) ||
         (r.min_inclusive_y > r.max_inclusive_y);
}

static inline bool wuffs_base__rect_ii_u32__equals(wuffs_base__rect_ii_u32 r,
                                                   wuffs_base__rect_ii_u32 s) {
  return (r.min_inclusive_x == s.min_inclusive_x &&
          r.min_inclusive_y == s.min_inclusive_y &&
          r.max_inclusive_x == s.max_inclusive_x &&
          r.max_inclusive_y == s.max_inclusive_y) ||
         (wuffs_base__rect_ii_u32__is_empty(r) &&
          wuffs_base__rect_ii_u32__is_empty(s));
}

static inline bool wuffs_base__rect_ii_u32__contains(wuffs_base__rect_ii_u32 r,
                                                     uint32_t x,
                                                     uint32_t y) {
  return (r.min_inclusive_x <= x) && (x <= r.max_inclusive_x) &&
         (r.min_inclusive_y <= y) && (y <= r.max_inclusive_y);
}

static inline wuffs_base__rect_ii_u32 wuffs_base__rect_ii_u32__intersection(
    wuffs_base__rect_ii_u32 r,
    wuffs_base__rect_ii_u32 s) {
  r.min_inclusive_x =
      wuffs_base__u32__max(r.min_inclusive_x, s.min_inclusive_x);
  r.min_inclusive_y =
      wuffs_base__u32__max(r.min_inclusive_y, s.min_inclusive_y);
  r.max_inclusive_x =
      wuffs_base__u32__min(r.max_inclusive_x, s.max_inclusive_x);
  r.max_inclusive_y =
      wuffs_base__u32__min(r.max_inclusive_y, s.max_inclusive_y);
  return r;
}

static inline wuffs_base__rect_ii_u32 wuffs_base__rect_ii_u32__union(
    wuffs_base__rect_ii_u32 r,
    wuffs_base__rect_ii_u32 s) {
  if (wuffs_base__rect_ii_u32__is_empty(r)) {
    return s;
  }
  if (wuffs_base__rect_ii_u32__is_empty(s)) {
    return r;
  }
  r.min_inclusive_x =
      wuffs_base__u32__min(r.min_inclusive_x, s.min_inclusive_x);
  r.min_inclusive_y =
      wuffs_base__u32__min(r.min_inclusive_y, s.min_inclusive_y);
  r.max_inclusive_x =
      wuffs_base__u32__max(r.max_inclusive_x, s.max_inclusive_x);
  r.max_inclusive_y =
      wuffs_base__u32__max(r.max_inclusive_y, s.max_inclusive_y);
  return r;
}

// --------

// wuffs_base__rect_ie_u32 is a rectangle (a 2-dimensional range) on the
// integer grid. The "ie" means that the bounds are inclusive on the low end
// and exclusive on the high end. It contains all points (x, y) such that
// ((min_inclusive_x <= x) && (x < max_exclusive_x)) and likewise for y.
//
// It is valid for min >= max, in which case the rectangle is empty. There are
// multiple representations of an empty rectangle, including a value with all
// fields zero.
//
// The X and Y axes increase right and down.
typedef struct {
  uint32_t min_inclusive_x;
  uint32_t min_inclusive_y;
  uint32_t max_exclusive_x;
  uint32_t max_exclusive_y;
} wuffs_base__rect_ie_u32;

static inline bool wuffs_base__rect_ie_u32__is_empty(
    wuffs_base__rect_ie_u32 r) {
  return (r.min_inclusive_x >= r.max_exclusive_x) ||
         (r.min_inclusive_y >= r.max_exclusive_y);
}

static inline bool wuffs_base__rect_ie_u32__equals(wuffs_base__rect_ie_u32 r,
                                                   wuffs_base__rect_ie_u32 s) {
  return (r.min_inclusive_x == s.min_inclusive_x &&
          r.min_inclusive_y == s.min_inclusive_y &&
          r.max_exclusive_x == s.max_exclusive_x &&
          r.max_exclusive_y == s.max_exclusive_y) ||
         (wuffs_base__rect_ie_u32__is_empty(r) &&
          wuffs_base__rect_ie_u32__is_empty(s));
}

static inline bool wuffs_base__rect_ie_u32__contains(wuffs_base__rect_ie_u32 r,
                                                     uint32_t x,
                                                     uint32_t y) {
  return (r.min_inclusive_x <= x) && (x < r.max_exclusive_x) &&
         (r.min_inclusive_y <= y) && (y < r.max_exclusive_y);
}

static inline wuffs_base__rect_ie_u32 wuffs_base__rect_ie_u32__intersection(
    wuffs_base__rect_ie_u32 r,
    wuffs_base__rect_ie_u32 s) {
  r.min_inclusive_x =
      wuffs_base__u32__max(r.min_inclusive_x, s.min_inclusive_x);
  r.min_inclusive_y =
      wuffs_base__u32__max(r.min_inclusive_y, s.min_inclusive_y);
  r.max_exclusive_x =
      wuffs_base__u32__min(r.max_exclusive_x, s.max_exclusive_x);
  r.max_exclusive_y =
      wuffs_base__u32__min(r.max_exclusive_y, s.max_exclusive_y);
  return r;
}

static inline wuffs_base__rect_ie_u32 wuffs_base__rect_ie_u32__union(
    wuffs_base__rect_ie_u32 r,
    wuffs_base__rect_ie_u32 s) {
  if (wuffs_base__rect_ie_u32__is_empty(r)) {
    return s;
  }
  if (wuffs_base__rect_ie_u32__is_empty(s)) {
    return r;
  }
  r.min_inclusive_x =
      wuffs_base__u32__min(r.min_inclusive_x, s.min_inclusive_x);
  r.min_inclusive_y =
      wuffs_base__u32__min(r.min_inclusive_y, s.min_inclusive_y);
  r.max_exclusive_x =
      wuffs_base__u32__max(r.max_exclusive_x, s.max_exclusive_x);
  r.max_exclusive_y =
      wuffs_base__u32__max(r.max_exclusive_y, s.max_exclusive_y);
  return r;
}

static inline uint32_t wuffs_base__rect_ie_u32__width(
    wuffs_base__rect_ie_u32 r) {
  return wuffs_base__u32__sat_sub(r.max_exclusive_x, r.min_inclusive_x);
}

static inline uint32_t wuffs_base__rect_ie_u32__height(
    wuffs_base__rect_ie_u32 r) {
  return wuffs_base__u32__sat_sub(r.max_exclusive_y, r.min_inclusive_y);
}

// ---------------- I/O

// wuffs_base__io_buffer is a 1-dimensional buffer (a pointer and length), plus
// additional indexes into that buffer, plus an opened / closed flag.
//
// A value with all fields NULL or zero is a valid, empty buffer.
typedef struct {
  uint8_t* ptr;  // Pointer.
  size_t len;    // Length.
  size_t wi;     // Write index. Invariant: wi <= len.
  size_t ri;     // Read  index. Invariant: ri <= wi.
  bool closed;   // No further writes are expected.
} wuffs_base__io_buffer;

typedef struct {
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so.
  struct {
    wuffs_base__io_buffer* buf;
    // The bounds values are typically NULL, when created by the Wuffs public
    // API. NULL means that the callee substitutes the implicit bounds derived
    // from buf.
    uint8_t* bounds[2];
  } private_impl;
} wuffs_base__io_reader;

typedef struct {
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so.
  struct {
    wuffs_base__io_buffer* buf;
    // The bounds values are typically NULL, when created by the Wuffs public
    // API. NULL means that the callee substitutes the implicit bounds derived
    // from buf.
    uint8_t* bounds[2];
  } private_impl;
} wuffs_base__io_writer;

static inline wuffs_base__io_reader wuffs_base__io_buffer__reader(
    wuffs_base__io_buffer* buf) {
  wuffs_base__io_reader ret = ((wuffs_base__io_reader){});
  ret.private_impl.buf = buf;
  return ret;
}

static inline wuffs_base__io_writer wuffs_base__io_buffer__writer(
    wuffs_base__io_buffer* buf) {
  wuffs_base__io_writer ret = ((wuffs_base__io_writer){});
  ret.private_impl.buf = buf;
  return ret;
}

// ---------------- Images

// wuffs_base__pixel_format encodes the format of the bytes that constitute an
// image frame's pixel data. Its bits:
//  - bit        31  is reserved.
//  - bits 30 .. 28 encodes color (and channel order, in terms of memory).
//  - bits 27 .. 26 are reserved.
//  - bits 25 .. 24 encodes transparency.
//  - bit        23 indicates big-endian/MSB-first (as opposed to little/LSB).
//  - bit        22 indicates floating point (as opposed to integer).
//  - bits 21 .. 20 are the number of planes, minus 1. Zero means packed.
//  - bits 19 .. 16 encodes the number of bits (depth) in an index value.
//                  Zero means direct, not palette-indexed.
//  - bits 15 .. 12 encodes the number of bits (depth) in the 3rd channel.
//  - bits 11 ..  8 encodes the number of bits (depth) in the 2nd channel.
//  - bits  7 ..  4 encodes the number of bits (depth) in the 1st channel.
//  - bits  3 ..  0 encodes the number of bits (depth) in the 0th channel.
//
// The bit fields of a wuffs_base__pixel_format are not independent. For
// example, the number of planes should not be greater than the number of
// channels. Similarly, bits 15..4 are unused (and should be zero) if bits
// 31..24 (color and transparency) together imply only 1 channel (gray, no
// alpha) and floating point samples should mean a bit depth of 16, 32 or 64.
//
// Formats hold between 1 and 4 channels. For example: Y (1 channel: gray), YA
// (2 channels: gray and alpha), BGR (3 channels: blue, green, red) or CMYK (4
// channels: cyan, magenta, yellow, black).
//
// For direct formats with N > 1 channels, those channels can be laid out in
// either 1 (packed) or N (planar) planes. For example, RGBA data is usually
// packed, but YUV data is usually planar, due to chroma subsampling (for
// details, see the wuffs_base__pixel_subsampling type). For indexed formats,
// the palette (always 256 × 4 bytes) holds up to 4 packed bytes of color data
// per index value, and there is only 1 plane (for the index). The distance
// between successive palette elements is always 4 bytes.
//
// The color field is encoded in 3 bits:
//  - 0 means                 A (Alpha).
//  - 1 means   Y       or   YA (Gray, Alpha).
//  - 2 means BGR, BGRX or BGRA (Blue, Green, Red, X-padding or Alpha).
//  - 3 means RGB, RGBX or RGBA (Red, Green, Blue, X-padding or Alpha).
//  - 4 means YUV       or YUVA (Luma, Chroma-blue, Chroma-red, Alpha).
//  - 5 means CMY       or CMYK (Cyan, Magenta, Yellow, Black).
//  - all other values are reserved.
//
// In Wuffs, channels are given in memory order, regardless of endianness,
// since the C type for the pixel data is an array of bytes, not an array of
// uint32_t. For example, packed BGRA with 8 bits per channel means that the
// bytes in memory are always Blue, Green, Red then Alpha. On big-endian
// systems, that is the uint32_t 0xBBGGRRAA. On little-endian, 0xAARRGGBB.
//
// When the color field (3 bits) encodes multiple options, the transparency
// field (2 bits) distinguishes them:
//  - 0 means fully opaque, no extra channels
//  - 1 means fully opaque, one extra channel (X or K, padding or black).
//  - 2 means one extra alpha channel, other channels are non-premultiplied.
//  - 3 means one extra alpha channel, other channels are     premultiplied.
//
// The zero wuffs_base__pixel_format value is an invalid pixel format, as it is
// invalid to combine the zero color (alpha only) with the zero transparency.
//
// Bit depth is encoded in 4 bits:
//  -  0 means the channel or index is unused.
//  -  x means a bit depth of  x, for x in the range 1..8.
//  -  9 means a bit depth of 10.
//  - 10 means a bit depth of 12.
//  - 11 means a bit depth of 16.
//  - 12 means a bit depth of 24.
//  - 13 means a bit depth of 32.
//  - 14 means a bit depth of 48.
//  - 15 means a bit depth of 64.
//
// For example, wuffs_base__pixel_format 0x3280BBBB is a natural format for
// decoding a PNG image - network byte order (also known as big-endian),
// packed, non-premultiplied alpha - that happens to be 16-bit-depth truecolor
// with alpha (RGBA). In memory order:
//
//  ptr+0  ptr+1  ptr+2  ptr+3  ptr+4  ptr+5  ptr+6  ptr+7
//  Rhi    Rlo    Ghi    Glo    Bhi    Blo    Ahi    Alo
//
// For example, the value wuffs_base__pixel_format 0x20000565 means BGR with no
// alpha or padding, 5/6/5 bits for blue/green/red, packed 2 bytes per pixel,
// laid out LSB-first in memory order:
//
//  ptr+0...........  ptr+1...........
//  MSB          LSB  MSB          LSB
//  G₂G₁G₀B₄B₃B₂B₁B₀  R₄R₃R₂R₁R₀G₅G₄G₃
//
// On little-endian systems (but not big-endian), this Wuffs pixel format value
// (0x20000565) corresponds to the Cairo library's CAIRO_FORMAT_RGB16_565, the
// SDL2 (Simple DirectMedia Layer 2) library's SDL_PIXELFORMAT_RGB565 and the
// Skia library's kRGB_565_SkColorType. Note BGR in Wuffs versus RGB in the
// other libraries.
//
// Regardless of endianness, this Wuffs pixel format value (0x20000565)
// corresponds to the V4L2 (Video For Linux 2) library's V4L2_PIX_FMT_RGB565
// and the Wayland-DRM library's WL_DRM_FORMAT_RGB565.
//
// Different software libraries name their pixel formats (and especially their
// channel order) either according to memory layout or as bits of a native
// integer type like uint32_t. The two conventions differ because of a system's
// endianness. As mentioned earlier, Wuffs pixel formats are always in memory
// order. More detail of other software libraries' naming conventions is in the
// Pixel Format Guide at https://afrantzis.github.io/pixel-format-guide/
//
// Do not manipulate these bits directly; they are private implementation
// details. Use methods such as wuffs_base__pixel_format__num_planes instead.
typedef uint32_t wuffs_base__pixel_format;

// Common 8-bit-depth pixel formats. This list is not exhaustive; not all valid
// wuffs_base__pixel_format values are present.

#define WUFFS_BASE__PIXEL_FORMAT__INVALID ((wuffs_base__pixel_format)0x00000000)

#define WUFFS_BASE__PIXEL_FORMAT__A ((wuffs_base__pixel_format)0x02000008)

#define WUFFS_BASE__PIXEL_FORMAT__Y ((wuffs_base__pixel_format)0x10000008)
#define WUFFS_BASE__PIXEL_FORMAT__YA_NONPREMUL \
  ((wuffs_base__pixel_format)0x12000008)
#define WUFFS_BASE__PIXEL_FORMAT__YA_PREMUL \
  ((wuffs_base__pixel_format)0x13000008)

#define WUFFS_BASE__PIXEL_FORMAT__BGR ((wuffs_base__pixel_format)0x20000888)
#define WUFFS_BASE__PIXEL_FORMAT__BGRX ((wuffs_base__pixel_format)0x21008888)
#define WUFFS_BASE__PIXEL_FORMAT__BGRX_INDEXED \
  ((wuffs_base__pixel_format)0x21088888)
#define WUFFS_BASE__PIXEL_FORMAT__BGRA_NONPREMUL \
  ((wuffs_base__pixel_format)0x22008888)
#define WUFFS_BASE__PIXEL_FORMAT__BGRA_NONPREMUL_INDEXED \
  ((wuffs_base__pixel_format)0x22088888)
#define WUFFS_BASE__PIXEL_FORMAT__BGRA_PREMUL \
  ((wuffs_base__pixel_format)0x23008888)

#define WUFFS_BASE__PIXEL_FORMAT__RGB ((wuffs_base__pixel_format)0x30000888)
#define WUFFS_BASE__PIXEL_FORMAT__RGBX ((wuffs_base__pixel_format)0x31008888)
#define WUFFS_BASE__PIXEL_FORMAT__RGBX_INDEXED \
  ((wuffs_base__pixel_format)0x31088888)
#define WUFFS_BASE__PIXEL_FORMAT__RGBA_NONPREMUL \
  ((wuffs_base__pixel_format)0x32008888)
#define WUFFS_BASE__PIXEL_FORMAT__RGBA_NONPREMUL_INDEXED \
  ((wuffs_base__pixel_format)0x32088888)
#define WUFFS_BASE__PIXEL_FORMAT__RGBA_PREMUL \
  ((wuffs_base__pixel_format)0x33008888)

#define WUFFS_BASE__PIXEL_FORMAT__YUV ((wuffs_base__pixel_format)0x40200888)
#define WUFFS_BASE__PIXEL_FORMAT__YUVK ((wuffs_base__pixel_format)0x41308888)
#define WUFFS_BASE__PIXEL_FORMAT__YUVA_NONPREMUL \
  ((wuffs_base__pixel_format)0x42308888)

#define WUFFS_BASE__PIXEL_FORMAT__CMY ((wuffs_base__pixel_format)0x50200888)
#define WUFFS_BASE__PIXEL_FORMAT__CMYK ((wuffs_base__pixel_format)0x51308888)

static inline bool wuffs_base__pixel_format__is_valid(
    wuffs_base__pixel_format f) {
  return f != 0;
}

static inline bool wuffs_base__pixel_format__is_indexed(
    wuffs_base__pixel_format f) {
  return ((f >> 16) & 0x0F) != 0;
}

#define WUFFS_BASE__PIXEL_FORMAT__NUM_PLANES_MAX 4

static inline uint32_t wuffs_base__pixel_format__num_planes(
    wuffs_base__pixel_format f) {
  return f ? (((f >> 20) & 0x03) + 1) : 0;
}

typedef struct {
  wuffs_base__table_u8 planes[WUFFS_BASE__PIXEL_FORMAT__NUM_PLANES_MAX];
} wuffs_base__pixel_buffer;

// --------

// wuffs_base__pixel_subsampling encodes the mapping of pixel space coordinates
// (x, y) to pixel buffer indices (i, j). That mapping can differ for each
// plane p. For a depth of 8 bits (1 byte), the p'th plane's sample starts at
// (planes[p].ptr + (j * planes[p].stride) + i).
//
// For packed pixel formats, the mapping is trivial: i = x and j = y. For
// planar pixel formats, the mapping can differ due to chroma subsampling. For
// example, consider a three plane YUV pixel format with 4:2:2 subsampling. For
// the luma (Y) channel, there is one sample for every pixel, but for the
// chroma (U, V) channels, there is one sample for every two pixels: pairs of
// horizontally adjacent pixels form one macropixel, i = x / 2 and j == y. In
// general, for a given p:
//  - i = (x + bias_x) >> shift_x.
//  - j = (y + bias_y) >> shift_y.
// where biases and shifts are in the range 0..3 and 0..2 respectively.
//
// In general, the biases will be zero after decoding an image. However, making
// a sub-image may change the bias, since the (x, y) coordinates are relative
// to the sub-image's top-left origin, but the backing pixel buffers were
// created relative to the original image's origin.
//
// For each plane p, each of those four numbers (biases and shifts) are encoded
// in two bits, which combine to form an 8 bit unsigned integer:
//
//  e_p = (bias_x << 6) | (shift_x << 4) | (bias_y << 2) | (shift_y << 0)
//
// Those e_p values (e_0 for the first plane, e_1 for the second plane, etc)
// combine to form a wuffs_base__pixel_subsampling value:
//
//  pixsub = (e_3 << 24) | (e_2 << 16) | (e_1 << 8) | (e_0 << 0)
//
// Do not manipulate these bits directly; they are private implementation
// details. Use methods such as wuffs_base__pixel_subsampling__bias_x instead.
typedef uint32_t wuffs_base__pixel_subsampling;

#define WUFFS_BASE__PIXEL_SUBSAMPLING__NONE ((wuffs_base__pixel_subsampling)0)

#define WUFFS_BASE__PIXEL_SUBSAMPLING__444 \
  ((wuffs_base__pixel_subsampling)0x000000)
#define WUFFS_BASE__PIXEL_SUBSAMPLING__440 \
  ((wuffs_base__pixel_subsampling)0x010100)
#define WUFFS_BASE__PIXEL_SUBSAMPLING__422 \
  ((wuffs_base__pixel_subsampling)0x101000)
#define WUFFS_BASE__PIXEL_SUBSAMPLING__420 \
  ((wuffs_base__pixel_subsampling)0x111100)
#define WUFFS_BASE__PIXEL_SUBSAMPLING__411 \
  ((wuffs_base__pixel_subsampling)0x202000)
#define WUFFS_BASE__PIXEL_SUBSAMPLING__410 \
  ((wuffs_base__pixel_subsampling)0x212100)

static inline uint32_t wuffs_base__pixel_subsampling__bias_x(
    wuffs_base__pixel_subsampling s,
    uint32_t plane) {
  uint32_t shift = ((plane & 0x03) * 8) + 6;
  return (s >> shift) & 0x03;
}

static inline uint32_t wuffs_base__pixel_subsampling__shift_x(
    wuffs_base__pixel_subsampling s,
    uint32_t plane) {
  uint32_t shift = ((plane & 0x03) * 8) + 4;
  return (s >> shift) & 0x03;
}

static inline uint32_t wuffs_base__pixel_subsampling__bias_y(
    wuffs_base__pixel_subsampling s,
    uint32_t plane) {
  uint32_t shift = ((plane & 0x03) * 8) + 2;
  return (s >> shift) & 0x03;
}

static inline uint32_t wuffs_base__pixel_subsampling__shift_y(
    wuffs_base__pixel_subsampling s,
    uint32_t plane) {
  uint32_t shift = ((plane & 0x03) * 8) + 0;
  return (s >> shift) & 0x03;
}

// --------

typedef struct {
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so.
  struct {
    wuffs_base__pixel_format pixfmt;
    wuffs_base__pixel_subsampling pixsub;
    uint32_t width;
    uint32_t height;
    uint32_t num_loops;
  } private_impl;
} wuffs_base__image_config;

// TODO: Should this function return bool? An error type?
static inline void wuffs_base__image_config__initialize(
    wuffs_base__image_config* c,
    wuffs_base__pixel_format pixfmt,
    wuffs_base__pixel_subsampling pixsub,
    uint32_t width,
    uint32_t height,
    uint32_t num_loops) {
  if (!c) {
    return;
  }
  if (pixfmt) {
    uint64_t wh = ((uint64_t)width) * ((uint64_t)height);
    // TODO: handle things other than 1 byte per pixel.
    if (wh <= ((uint64_t)SIZE_MAX)) {
      c->private_impl.pixfmt = pixfmt;
      c->private_impl.pixsub = pixsub;
      c->private_impl.width = width;
      c->private_impl.height = height;
      c->private_impl.num_loops = num_loops;
      return;
    }
  }
  *c = ((wuffs_base__image_config){});
}

static inline void wuffs_base__image_config__invalidate(
    wuffs_base__image_config* c) {
  if (c) {
    *c = ((wuffs_base__image_config){});
  }
}

static inline bool wuffs_base__image_config__is_valid(
    wuffs_base__image_config* c) {
  return c && c->private_impl.pixfmt;
}

static inline wuffs_base__pixel_format wuffs_base__image_config__pixel_format(
    wuffs_base__image_config* c) {
  return c ? c->private_impl.pixfmt : 0;
}

static inline wuffs_base__pixel_subsampling
wuffs_base__image_config__pixel_subsampling(wuffs_base__image_config* c) {
  return c ? c->private_impl.pixsub : 0;
}

static inline uint32_t wuffs_base__image_config__width(
    wuffs_base__image_config* c) {
  return c ? c->private_impl.width : 0;
}

static inline uint32_t wuffs_base__image_config__height(
    wuffs_base__image_config* c) {
  return c ? c->private_impl.height : 0;
}

static inline uint32_t wuffs_base__image_config__num_loops(
    wuffs_base__image_config* c) {
  return c ? c->private_impl.num_loops : 0;
}

// TODO: this is the right API for planar (not packed) pixbufs? Should it allow
// decoding into a color model different from the format's intrinsic one? For
// example, decoding a JPEG image straight to RGBA instead of to YCbCr?
static inline size_t wuffs_base__image_config__pixbuf_size(
    wuffs_base__image_config* c) {
  if (c) {
    uint64_t wh =
        ((uint64_t)c->private_impl.width) * ((uint64_t)c->private_impl.height);
    // TODO: handle things other than 1 byte per pixel.
    return (size_t)wh;
  }
  return 0;
}

// --------

typedef struct {
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so.
  struct {
    wuffs_base__image_config config;
    uint32_t loop_count;  // 0-based count of the current loop.
    wuffs_base__pixel_buffer pixbuf;
    // TODO: color spaces.
    wuffs_base__rect_ie_u32 dirty_rect;
    wuffs_base__flicks duration;
    bool palette_changed;
    uint8_t palette[1024];
  } private_impl;
} wuffs_base__image_buffer;

static inline void wuffs_base__image_buffer__set_from_pixbuf(
    wuffs_base__image_buffer* b,
    wuffs_base__image_config config,
    wuffs_base__pixel_buffer pixbuf) {
  if (!b) {
    return;
  }
  *b = ((wuffs_base__image_buffer){});
  b->private_impl.config = config;
  b->private_impl.pixbuf = pixbuf;
}

// TODO: Should this function return bool? An error type?
static inline void wuffs_base__image_buffer__set_from_slice(
    wuffs_base__image_buffer* b,
    wuffs_base__image_config config,
    wuffs_base__slice_u8 pixbuf_memory) {
  if (!b) {
    return;
  }
  *b = ((wuffs_base__image_buffer){});
  // TODO: don't assume 1 byte per pixel. Don't assume packed.
  uint64_t wh = ((uint64_t)config.private_impl.width) *
                ((uint64_t)config.private_impl.height);
  if (wh > pixbuf_memory.len) {
    return;
  }
  b->private_impl.config = config;
  wuffs_base__table_u8* tab = &b->private_impl.pixbuf.planes[0];
  tab->ptr = pixbuf_memory.ptr;
  tab->width = config.private_impl.width;
  tab->height = config.private_impl.height;
  tab->stride = config.private_impl.width;
}

// The palette argument is ignored unless its length is exactly 1024.
static inline void wuffs_base__image_buffer__update(
    wuffs_base__image_buffer* b,
    wuffs_base__rect_ie_u32 dirty_rect,
    wuffs_base__flicks duration,
    wuffs_base__slice_u8 palette) {
  if (!b) {
    return;
  }

  // Clip the dirty_rect to the image bounds.
  dirty_rect.max_exclusive_x = wuffs_base__u32__min(
      dirty_rect.max_exclusive_x, b->private_impl.config.private_impl.width);
  dirty_rect.max_exclusive_y = wuffs_base__u32__min(
      dirty_rect.max_exclusive_y, b->private_impl.config.private_impl.height);
  b->private_impl.dirty_rect = dirty_rect;

  b->private_impl.duration = duration;
  b->private_impl.palette_changed = palette.ptr && (palette.len == 1024);
  if (b->private_impl.palette_changed) {
    memmove(b->private_impl.palette, palette.ptr, 1024);
  }
}

// wuffs_base__image_buffer__loop returns whether the image decoder should loop
// back to the beginning of the animation, assuming that we've reached the end
// of the encoded stream. If so, it increments b's count of the animation loops
// played so far.
static inline bool wuffs_base__image_buffer__loop(wuffs_base__image_buffer* b) {
  if (!b) {
    return false;
  }
  uint32_t n = b->private_impl.config.private_impl.num_loops;
  if (n == 0) {
    return true;
  }
  if (b->private_impl.loop_count < n - 1) {
    b->private_impl.loop_count++;
    return true;
  }
  return false;
}

static inline wuffs_base__image_config* wuffs_base__image_buffer__image_config(
    wuffs_base__image_buffer* b) {
  return b ? &b->private_impl.config : NULL;
}

// wuffs_base__image_buffer__palette_changed returns whether this frame's
// palette differs from the previous frame. It is conservative and may return
// false positives (but never false negatives).
static inline bool wuffs_base__image_buffer__palette_changed(
    wuffs_base__image_buffer* b) {
  return b && b->private_impl.palette_changed;
}

// wuffs_base__image_buffer__dirty_rect returns an upper bound for what part of
// this frame's pixels differs from the previous frame.
static inline wuffs_base__rect_ie_u32 wuffs_base__image_buffer__dirty_rect(
    wuffs_base__image_buffer* b) {
  return b ? b->private_impl.dirty_rect : ((wuffs_base__rect_ie_u32){0});
}

// wuffs_base__image_buffer__duration returns the amount of time to display
// this frame. Zero means to display forever - a still (non-animated) image.
static inline wuffs_base__flicks wuffs_base__image_buffer__duration(
    wuffs_base__image_buffer* b) {
  return b ? b->private_impl.duration : 0;
}

// wuffs_base__image_buffer__palette returns the palette that the pixel data
// can index. The backing array is inside b and has length 1024.
static inline wuffs_base__slice_u8 wuffs_base__image_buffer__palette(
    wuffs_base__image_buffer* b) {
  return b ? ((wuffs_base__slice_u8){.ptr = b->private_impl.palette,
                                     .len = 1024})
           : ((wuffs_base__slice_u8){});
}

static inline wuffs_base__table_u8 wuffs_base__image_buffer__plane(
    wuffs_base__image_buffer* b,
    uint32_t p) {
  return (b && (p < WUFFS_BASE__PIXEL_FORMAT__NUM_PLANES_MAX))
             ? b->private_impl.pixbuf.planes[p]
             : ((wuffs_base__table_u8){});
}

#endif  // WUFFS_BASE_HEADER_H

  // ---------------- Use Declarations

#ifdef __cplusplus
extern "C" {
#endif

// ---------------- Status Codes

// Status codes are int32_t values. Its bits:
//  - bit        31 (the sign bit) indicates unrecoverable-ness: an error.
//  - bits 30 .. 10 are the packageid: a namespace.
//  - bits  9 ..  8 are reserved.
//  - bits  7 ..  0 are a package-namespaced numeric code.
//
// Do not manipulate these bits directly; they are private implementation
// details. Use methods such as wuffs_gif__status__is_error instead.
typedef int32_t wuffs_gif__status;

#define wuffs_gif__packageid 1017222  // 0x000F8586

#define WUFFS_GIF__STATUS_OK 0                                   // 0x00000000
#define WUFFS_GIF__ERROR_BAD_WUFFS_VERSION -2147483647           // 0x80000001
#define WUFFS_GIF__ERROR_BAD_RECEIVER -2147483646                // 0x80000002
#define WUFFS_GIF__ERROR_BAD_ARGUMENT -2147483645                // 0x80000003
#define WUFFS_GIF__ERROR_INITIALIZER_NOT_CALLED -2147483644      // 0x80000004
#define WUFFS_GIF__ERROR_INVALID_I_O_OPERATION -2147483643       // 0x80000005
#define WUFFS_GIF__ERROR_CLOSED_FOR_WRITES -2147483642           // 0x80000006
#define WUFFS_GIF__ERROR_UNEXPECTED_EOF -2147483641              // 0x80000007
#define WUFFS_GIF__SUSPENSION_SHORT_READ 8                       // 0x00000008
#define WUFFS_GIF__SUSPENSION_SHORT_WRITE 9                      // 0x00000009
#define WUFFS_GIF__ERROR_CANNOT_RETURN_A_SUSPENSION -2147483638  // 0x8000000A
#define WUFFS_GIF__ERROR_INVALID_CALL_SEQUENCE -2147483637       // 0x8000000B
#define WUFFS_GIF__SUSPENSION_END_OF_DATA 12                     // 0x0000000C

#define WUFFS_GIF__ERROR_BAD_BLOCK -1105848320              // 0xBE161800
#define WUFFS_GIF__ERROR_BAD_EXTENSION_LABEL -1105848319    // 0xBE161801
#define WUFFS_GIF__ERROR_BAD_GRAPHIC_CONTROL -1105848318    // 0xBE161802
#define WUFFS_GIF__ERROR_BAD_HEADER -1105848317             // 0xBE161803
#define WUFFS_GIF__ERROR_BAD_LITERAL_WIDTH -1105848316      // 0xBE161804
#define WUFFS_GIF__ERROR_NOT_ENOUGH_PIXEL_DATA -1105848315  // 0xBE161805
#define WUFFS_GIF__ERROR_TOO_MUCH_PIXEL_DATA -1105848314    // 0xBE161806
#define WUFFS_GIF__ERROR_INTERNAL_ERROR_INCONSISTENT_RI_WI \
  -1105848313                                                      // 0xBE161807
#define WUFFS_GIF__ERROR_TODO_UNSUPPORTED_INTERLACING -1105848312  // 0xBE161808
#define WUFFS_GIF__ERROR_LZW_CODE_IS_OUT_OF_RANGE -1105848311      // 0xBE161809
#define WUFFS_GIF__ERROR_LZW_PREFIX_CHAIN_IS_CYCLICAL -1105848310  // 0xBE16180A

bool wuffs_gif__status__is_error(wuffs_gif__status s);

const char* wuffs_gif__status__string(wuffs_gif__status s);

// ---------------- Public Consts

// ---------------- Structs

typedef struct {
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so. Instead, use the
  // wuffs_gif__lzw_decoder__etc functions.
  //
  // In C++, these fields would be "private", but C does not support that.
  //
  // It is a struct, not a struct*, so that it can be stack allocated.
  struct {
    wuffs_gif__status status;
    uint32_t magic;

    uint32_t f_literal_width;
    uint8_t f_stack[4096];
    uint8_t f_suffixes[4096];
    uint16_t f_prefixes[4096];

    struct {
      uint32_t coro_susp_point;
      uint32_t v_clear_code;
      uint32_t v_end_code;
      uint32_t v_save_code;
      uint32_t v_prev_code;
      uint32_t v_initial_width;
      uint32_t v_width;
      uint32_t v_bits;
      uint32_t v_n_bits;
      uint32_t v_code;
      uint32_t v_s;
      uint32_t v_c;
      uint64_t v_n_copied;
    } c_decode[1];
  } private_impl;
} wuffs_gif__lzw_decoder;

typedef struct {
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so. Instead, use the
  // wuffs_gif__decoder__etc functions.
  //
  // In C++, these fields would be "private", but C does not support that.
  //
  // It is a struct, not a struct*, so that it can be stack allocated.
  struct {
    wuffs_gif__status status;
    uint32_t magic;

    uint32_t f_width;
    uint32_t f_height;
    uint8_t f_call_sequence;
    bool f_end_of_data;
    bool f_previous_lzw_decode_ended_abruptly;
    bool f_previous_use_global_palette;
    uint8_t f_background_color_index;
    bool f_interlace;
    bool f_seen_num_loops;
    uint32_t f_num_loops;
    bool f_seen_graphic_control;
    bool f_gc_has_transparent_index;
    uint8_t f_gc_transparent_index;
    uint8_t f_gc_disposal;
    uint64_t f_gc_duration;
    wuffs_base__rect_ie_u32 f_frame_rect;
    uint32_t f_dst_x;
    uint32_t f_dst_y;
    uint32_t f_dst_x0;
    uint32_t f_dst_x1;
    uint32_t f_dst_y1;
    uint32_t f_uncompressed_ri;
    uint32_t f_uncompressed_wi;
    uint8_t f_uncompressed[4096];
    uint8_t f_palettes[2][1024];
    wuffs_gif__lzw_decoder f_lzw;

    struct {
      uint32_t coro_susp_point;
    } c_decode_config[1];
    struct {
      uint32_t coro_susp_point;
    } c_decode_frame[1];
    struct {
      uint32_t coro_susp_point;
      uint8_t v_block_type;
    } c_decode_up_to_id_part1[1];
    struct {
      uint32_t coro_susp_point;
      uint8_t v_c[6];
      uint32_t v_i;
    } c_decode_header[1];
    struct {
      uint32_t coro_susp_point;
      uint8_t v_c[7];
      uint32_t v_i;
      uint8_t v_flags;
      uint32_t v_num_palette_entries;
    } c_decode_lsd[1];
    struct {
      uint32_t coro_susp_point;
      uint8_t v_label;
    } c_decode_extension[1];
    struct {
      uint32_t coro_susp_point;
      uint8_t v_block_size;
      uint64_t scratch;
    } c_skip_blocks[1];
    struct {
      uint32_t coro_susp_point;
      uint8_t v_c;
      uint8_t v_block_size;
      bool v_not_animexts;
      bool v_not_netscape;
      uint64_t scratch;
    } c_decode_ae[1];
    struct {
      uint32_t coro_susp_point;
      uint8_t v_flags;
      uint64_t scratch;
    } c_decode_gc[1];
    struct {
      uint32_t coro_susp_point;
      uint32_t v_frame_x;
      uint32_t v_frame_y;
      uint64_t scratch;
    } c_decode_id_part0[1];
    struct {
      uint32_t coro_susp_point;
      uint8_t v_flags;
      bool v_use_local_palette;
      uint32_t v_num_palette_entries;
      uint32_t v_i;
      uint8_t v_lw;
      uint64_t v_block_size;
      wuffs_gif__status v_z;
    } c_decode_id_part1[1];
  } private_impl;
} wuffs_gif__decoder;

// ---------------- Public Initializer Prototypes

// wuffs_gif__decoder__initialize is an initializer function.
//
// It should be called before any other wuffs_gif__decoder__* function.
//
// Pass WUFFS_VERSION and 0 for wuffs_version and for_internal_use_only.
void wuffs_gif__decoder__initialize(wuffs_gif__decoder* self,
                                    uint32_t wuffs_version,
                                    uint32_t for_internal_use_only);

// ---------------- Public Function Prototypes

wuffs_gif__status wuffs_gif__decoder__decode_config(
    wuffs_gif__decoder* self,
    wuffs_base__image_config* a_dst,
    wuffs_base__io_reader a_src);

wuffs_gif__status wuffs_gif__decoder__decode_frame(
    wuffs_gif__decoder* self,
    wuffs_base__image_buffer* a_ib,
    wuffs_base__io_reader a_src);

wuffs_gif__status wuffs_gif__decoder__decode_up_to_id_part1(
    wuffs_gif__decoder* self,
    wuffs_base__io_reader a_src);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif  // WUFFS_GIF_H

// C HEADER ENDS HERE.

#ifndef WUFFS_BASE_IMPL_H
#define WUFFS_BASE_IMPL_H

// Copyright 2017 The Wuffs Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#define WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(x) (void)(x)

// WUFFS_BASE__MAGIC is a magic number to check that initializers are called.
// It's not foolproof, given C doesn't automatically zero memory before use,
// but it should catch 99.99% of cases.
//
// Its (non-zero) value is arbitrary, based on md5sum("wuffs").
#define WUFFS_BASE__MAGIC ((uint32_t)0x3CCB6C71)

// WUFFS_BASE__ALREADY_ZEROED is passed from a container struct's initializer
// to a containee struct's initializer when the container has already zeroed
// the containee's memory.
//
// Its (non-zero) value is arbitrary, based on md5sum("zeroed").
#define WUFFS_BASE__ALREADY_ZEROED ((uint32_t)0x68602EF1)

// Denote intentional fallthroughs for -Wimplicit-fallthrough.
//
// The order matters here. Clang also defines "__GNUC__".
#if defined(__clang__) && __cplusplus >= 201103L
#define WUFFS_BASE__FALLTHROUGH [[clang::fallthrough]]
#elif !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 7)
#define WUFFS_BASE__FALLTHROUGH __attribute__((fallthrough))
#else
#define WUFFS_BASE__FALLTHROUGH
#endif

// Use switch cases for coroutine suspension points, similar to the technique
// in https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html
//
// We use trivial macros instead of an explicit assignment and case statement
// so that clang-format doesn't get confused by the unusual "case"s.
#define WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0 case 0:;
#define WUFFS_BASE__COROUTINE_SUSPENSION_POINT(n) \
  coro_susp_point = n;                            \
  WUFFS_BASE__FALLTHROUGH;                        \
  case n:;

#define WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(n) \
  if (status < 0) {                                             \
    goto exit;                                                  \
  } else if (status == 0) {                                     \
    goto ok;                                                    \
  }                                                             \
  coro_susp_point = n;                                          \
  goto suspend;                                                 \
  case n:;

// Clang also defines "__GNUC__".
#if defined(__GNUC__)
#define WUFFS_BASE__LIKELY(expr) (__builtin_expect(!!(expr), 1))
#define WUFFS_BASE__UNLIKELY(expr) (__builtin_expect(!!(expr), 0))
#else
#define WUFFS_BASE__LIKELY(expr) (expr)
#define WUFFS_BASE__UNLIKELY(expr) (expr)
#endif

// Uncomment this #include for printf-debugging.
// #include <stdio.h>

// The helpers below are functions, instead of macros, because their arguments
// can be an expression that we shouldn't evaluate more than once.
//
// They are in base-impl.h and hence copy/pasted into every generated C file,
// instead of being in some "base.c" file, since a design goal is that users of
// the generated C code can often just #include a single .c file, such as
// "gif.c", without having to additionally include or otherwise build and link
// a "base.c" file.
//
// They are static, so that linking multiple wuffs .o files won't complain about
// duplicate function definitions.
//
// They are explicitly marked inline, even if modern compilers don't use the
// inline attribute to guide optimizations such as inlining, to avoid the
// -Wunused-function warning, and we like to compile with -Wall -Werror.

// ---------------- Numeric Types

static inline uint16_t wuffs_base__load_u16be(uint8_t* p) {
  return ((uint16_t)(p[0]) << 8) | ((uint16_t)(p[1]) << 0);
}

static inline uint16_t wuffs_base__load_u16le(uint8_t* p) {
  return ((uint16_t)(p[0]) << 0) | ((uint16_t)(p[1]) << 8);
}

static inline uint32_t wuffs_base__load_u32be(uint8_t* p) {
  return ((uint32_t)(p[0]) << 24) | ((uint32_t)(p[1]) << 16) |
         ((uint32_t)(p[2]) << 8) | ((uint32_t)(p[3]) << 0);
}

static inline uint32_t wuffs_base__load_u32le(uint8_t* p) {
  return ((uint32_t)(p[0]) << 0) | ((uint32_t)(p[1]) << 8) |
         ((uint32_t)(p[2]) << 16) | ((uint32_t)(p[3]) << 24);
}

static inline uint64_t wuffs_base__load_u64be(uint8_t* p) {
  return ((uint64_t)(p[0]) << 56) | ((uint64_t)(p[1]) << 48) |
         ((uint64_t)(p[2]) << 40) | ((uint64_t)(p[3]) << 32) |
         ((uint64_t)(p[4]) << 24) | ((uint64_t)(p[5]) << 16) |
         ((uint64_t)(p[6]) << 8) | ((uint64_t)(p[7]) << 0);
}

static inline uint64_t wuffs_base__load_u64le(uint8_t* p) {
  return ((uint64_t)(p[0]) << 0) | ((uint64_t)(p[1]) << 8) |
         ((uint64_t)(p[2]) << 16) | ((uint64_t)(p[3]) << 24) |
         ((uint64_t)(p[4]) << 32) | ((uint64_t)(p[5]) << 40) |
         ((uint64_t)(p[6]) << 48) | ((uint64_t)(p[7]) << 56);
}

// --------

static inline void wuffs_base__u8__sat_add_indirect(uint8_t* x, uint8_t y) {
  *x = wuffs_base__u8__sat_add(*x, y);
}

static inline void wuffs_base__u8__sat_sub_indirect(uint8_t* x, uint8_t y) {
  *x = wuffs_base__u8__sat_sub(*x, y);
}

static inline void wuffs_base__u16__sat_add_indirect(uint16_t* x, uint16_t y) {
  *x = wuffs_base__u16__sat_add(*x, y);
}

static inline void wuffs_base__u16__sat_sub_indirect(uint16_t* x, uint16_t y) {
  *x = wuffs_base__u16__sat_sub(*x, y);
}

static inline void wuffs_base__u32__sat_add_indirect(uint32_t* x, uint32_t y) {
  *x = wuffs_base__u32__sat_add(*x, y);
}

static inline void wuffs_base__u32__sat_sub_indirect(uint32_t* x, uint32_t y) {
  *x = wuffs_base__u32__sat_sub(*x, y);
}

static inline void wuffs_base__u64__sat_add_indirect(uint64_t* x, uint64_t y) {
  *x = wuffs_base__u64__sat_add(*x, y);
}

static inline void wuffs_base__u64__sat_sub_indirect(uint64_t* x, uint64_t y) {
  *x = wuffs_base__u64__sat_sub(*x, y);
}

// ---------------- Slices and Tables

static inline wuffs_base__slice_u8 wuffs_base__slice_u8__subslice_i(
    wuffs_base__slice_u8 s,
    uint64_t i) {
  if ((i <= SIZE_MAX) && (i <= s.len)) {
    return ((wuffs_base__slice_u8){
        .ptr = s.ptr + i,
        .len = s.len - i,
    });
  }
  return ((wuffs_base__slice_u8){});
}

static inline wuffs_base__slice_u8 wuffs_base__slice_u8__subslice_j(
    wuffs_base__slice_u8 s,
    uint64_t j) {
  if ((j <= SIZE_MAX) && (j <= s.len)) {
    return ((wuffs_base__slice_u8){.ptr = s.ptr, .len = j});
  }
  return ((wuffs_base__slice_u8){});
}

static inline wuffs_base__slice_u8 wuffs_base__slice_u8__subslice_ij(
    wuffs_base__slice_u8 s,
    uint64_t i,
    uint64_t j) {
  if ((i <= j) && (j <= SIZE_MAX) && (j <= s.len)) {
    return ((wuffs_base__slice_u8){
        .ptr = s.ptr + i,
        .len = j - i,
    });
  }
  return ((wuffs_base__slice_u8){});
}

// wuffs_base__slice_u8__prefix returns up to the first up_to bytes of s.
static inline wuffs_base__slice_u8 wuffs_base__slice_u8__prefix(
    wuffs_base__slice_u8 s,
    uint64_t up_to) {
  if ((uint64_t)(s.len) > up_to) {
    s.len = up_to;
  }
  return s;
}

// wuffs_base__slice_u8__suffix returns up to the last up_to bytes of s.
static inline wuffs_base__slice_u8 wuffs_base__slice_u8__suffix(
    wuffs_base__slice_u8 s,
    uint64_t up_to) {
  if ((uint64_t)(s.len) > up_to) {
    s.ptr += (uint64_t)(s.len) - up_to;
    s.len = up_to;
  }
  return s;
}

// wuffs_base__slice_u8__copy_from_slice calls memmove(dst.ptr, src.ptr,
// length) where length is the minimum of dst.len and src.len.
//
// Passing a wuffs_base__slice_u8 with all fields NULL or zero (a valid, empty
// slice) is valid and results in a no-op.
static inline uint64_t wuffs_base__slice_u8__copy_from_slice(
    wuffs_base__slice_u8 dst,
    wuffs_base__slice_u8 src) {
  size_t length = dst.len < src.len ? dst.len : src.len;
  if (length > 0) {
    memmove(dst.ptr, src.ptr, length);
  }
  return length;
}

// --------

static inline wuffs_base__slice_u8 wuffs_base__table_u8__row(
    wuffs_base__table_u8 t,
    uint32_t y) {
  if (y < t.height) {
    return ((wuffs_base__slice_u8){
        .ptr = t.ptr + (t.stride * y),
        .len = t.width,
    });
  }
  return ((wuffs_base__slice_u8){});
}

// ---------------- Ranges and Rects

static inline wuffs_base__empty_struct
wuffs_base__rect_ii_u32__set_min_inclusive_x(wuffs_base__rect_ii_u32* r,
                                             uint32_t x) {
  r->min_inclusive_x = x;
  return ((wuffs_base__empty_struct){});
}

static inline wuffs_base__empty_struct
wuffs_base__rect_ii_u32__set_min_inclusive_y(wuffs_base__rect_ii_u32* r,
                                             uint32_t y) {
  r->min_inclusive_y = y;
  return ((wuffs_base__empty_struct){});
}

static inline wuffs_base__empty_struct
wuffs_base__rect_ii_u32__set_max_inclusive_x(wuffs_base__rect_ii_u32* r,
                                             uint32_t x) {
  r->max_inclusive_x = x;
  return ((wuffs_base__empty_struct){});
}

static inline wuffs_base__empty_struct
wuffs_base__rect_ii_u32__set_max_inclusive_y(wuffs_base__rect_ii_u32* r,
                                             uint32_t y) {
  r->max_inclusive_y = y;
  return ((wuffs_base__empty_struct){});
}

// --------

static inline wuffs_base__empty_struct
wuffs_base__rect_ie_u32__set_min_inclusive_x(wuffs_base__rect_ie_u32* r,
                                             uint32_t x) {
  r->min_inclusive_x = x;
  return ((wuffs_base__empty_struct){});
}

static inline wuffs_base__empty_struct
wuffs_base__rect_ie_u32__set_min_inclusive_y(wuffs_base__rect_ie_u32* r,
                                             uint32_t y) {
  r->min_inclusive_y = y;
  return ((wuffs_base__empty_struct){});
}

static inline wuffs_base__empty_struct
wuffs_base__rect_ie_u32__set_max_exclusive_x(wuffs_base__rect_ie_u32* r,
                                             uint32_t x) {
  r->max_exclusive_x = x;
  return ((wuffs_base__empty_struct){});
}

static inline wuffs_base__empty_struct
wuffs_base__rect_ie_u32__set_max_exclusive_y(wuffs_base__rect_ie_u32* r,
                                             uint32_t y) {
  r->max_exclusive_y = y;
  return ((wuffs_base__empty_struct){});
}

// ---------------- I/O

static inline bool wuffs_base__io_buffer__is_valid(wuffs_base__io_buffer buf) {
  return (buf.ptr || (buf.len == 0)) && (buf.len >= buf.wi) &&
         (buf.wi >= buf.ri);
}

static inline bool wuffs_base__io_reader__is_eof(wuffs_base__io_reader o) {
  wuffs_base__io_buffer* buf = o.private_impl.buf;
  return buf && buf->closed && (buf->ptr + buf->wi == o.private_impl.bounds[1]);
}

static inline bool wuffs_base__io_reader__is_valid(wuffs_base__io_reader o) {
  wuffs_base__io_buffer* buf = o.private_impl.buf;
  // Note: if making this function public (i.e. moving it to base-header.h), it
  // also needs to allow NULL (i.e. implicit, callee-calculated) bounds.
  return buf ? ((buf->ptr <= o.private_impl.bounds[0]) &&
                (o.private_impl.bounds[0] <= o.private_impl.bounds[1]) &&
                (o.private_impl.bounds[1] <= buf->ptr + buf->len))
             : ((o.private_impl.bounds[0] == NULL) &&
                (o.private_impl.bounds[1] == NULL));
}

static inline bool wuffs_base__io_writer__is_valid(wuffs_base__io_writer o) {
  wuffs_base__io_buffer* buf = o.private_impl.buf;
  // Note: if making this function public (i.e. moving it to base-header.h), it
  // also needs to allow NULL (i.e. implicit, callee-calculated) bounds.
  return buf ? ((buf->ptr <= o.private_impl.bounds[0]) &&
                (o.private_impl.bounds[0] <= o.private_impl.bounds[1]) &&
                (o.private_impl.bounds[1] <= buf->ptr + buf->len))
             : ((o.private_impl.bounds[0] == NULL) &&
                (o.private_impl.bounds[1] == NULL));
}

static inline uint32_t wuffs_base__io_writer__copy_from_history32(
    uint8_t** ptr_ptr,
    uint8_t* start,
    uint8_t* end,
    uint32_t distance,
    uint32_t length) {
  if (!distance) {
    return 0;
  }
  uint8_t* ptr = *ptr_ptr;
  if ((size_t)(ptr - start) < (size_t)(distance)) {
    return 0;
  }
  start = ptr - distance;
  size_t n = end - ptr;
  if ((size_t)(length) > n) {
    length = n;
  } else {
    n = length;
  }
  // TODO: unrolling by 3 seems best for the std/deflate benchmarks, but that
  // is mostly because 3 is the minimum length for the deflate format. This
  // function implementation shouldn't overfit to that one format. Perhaps the
  // copy_from_history32 Wuffs method should also take an unroll hint argument,
  // and the cgen can look if that argument is the constant expression '3'.
  //
  // See also wuffs_base__io_writer__copy_from_history32__bco below.
  //
  // Alternatively, or additionally, have a sloppy_copy_from_history32 method
  // that copies 8 bytes at a time, possibly writing more than length bytes?
  for (; n >= 3; n -= 3) {
    *ptr++ = *start++;
    *ptr++ = *start++;
    *ptr++ = *start++;
  }
  for (; n; n--) {
    *ptr++ = *start++;
  }
  *ptr_ptr = ptr;
  return length;
}

// wuffs_base__io_writer__copy_from_history32__bco is a Bounds Check Optimized
// version of the wuffs_base__io_writer__copy_from_history32 function above.
// The caller needs to prove that:
//  - distance >  0
//  - distance <= (*ptr_ptr - start)
//  - length   <= (end      - *ptr_ptr)
static inline uint32_t wuffs_base__io_writer__copy_from_history32__bco(
    uint8_t** ptr_ptr,
    uint8_t* start,
    uint8_t* end,
    uint32_t distance,
    uint32_t length) {
  uint8_t* ptr = *ptr_ptr;
  start = ptr - distance;
  uint32_t n = length;
  for (; n >= 3; n -= 3) {
    *ptr++ = *start++;
    *ptr++ = *start++;
    *ptr++ = *start++;
  }
  for (; n; n--) {
    *ptr++ = *start++;
  }
  *ptr_ptr = ptr;
  return length;
}

static inline uint32_t wuffs_base__io_writer__copy_from_reader32(
    uint8_t** ptr_ioptr_w,
    uint8_t* iobounds1_w,
    uint8_t** ptr_ioptr_r,
    uint8_t* iobounds1_r,
    uint32_t length) {
  uint8_t* ioptr_w = *ptr_ioptr_w;
  size_t n = length;
  if (n > iobounds1_w - ioptr_w) {
    n = iobounds1_w - ioptr_w;
  }
  uint8_t* ioptr_r = *ptr_ioptr_r;
  if (n > iobounds1_r - ioptr_r) {
    n = iobounds1_r - ioptr_r;
  }
  if (n > 0) {
    memmove(ioptr_w, ioptr_r, n);
    *ptr_ioptr_w += n;
    *ptr_ioptr_r += n;
  }
  return n;
}

static inline uint64_t wuffs_base__io_writer__copy_from_slice(
    uint8_t** ptr_ioptr_w,
    uint8_t* iobounds1_w,
    wuffs_base__slice_u8 src) {
  uint8_t* ioptr_w = *ptr_ioptr_w;
  size_t n = src.len;
  if (n > iobounds1_w - ioptr_w) {
    n = iobounds1_w - ioptr_w;
  }
  if (n > 0) {
    memmove(ioptr_w, src.ptr, n);
    *ptr_ioptr_w += n;
  }
  return n;
}

static inline uint32_t wuffs_base__io_writer__copy_from_slice32(
    uint8_t** ptr_ioptr_w,
    uint8_t* iobounds1_w,
    wuffs_base__slice_u8 src,
    uint32_t length) {
  uint8_t* ioptr_w = *ptr_ioptr_w;
  size_t n = src.len;
  if (n > length) {
    n = length;
  }
  if (n > iobounds1_w - ioptr_w) {
    n = iobounds1_w - ioptr_w;
  }
  if (n > 0) {
    memmove(ioptr_w, src.ptr, n);
    *ptr_ioptr_w += n;
  }
  return n;
}

static inline wuffs_base__empty_struct wuffs_base__io_reader__set_limit(
    wuffs_base__io_reader* o,
    uint8_t* ioptr_r,
    uint64_t limit) {
  if (o && ((o->private_impl.bounds[1] - ioptr_r) > limit)) {
    o->private_impl.bounds[1] = ioptr_r + limit;
  }
  return ((wuffs_base__empty_struct){});
}

static inline wuffs_base__empty_struct wuffs_base__io_reader__set_mark(
    wuffs_base__io_reader* o,
    uint8_t* mark) {
  o->private_impl.bounds[0] = mark;
  return ((wuffs_base__empty_struct){});
}

static inline wuffs_base__empty_struct wuffs_base__io_writer__set(
    wuffs_base__io_writer* o,
    wuffs_base__io_buffer* b,
    uint8_t** ioptr1_ptr,
    uint8_t** ioptr2_ptr,
    wuffs_base__slice_u8 s) {
  b->ptr = s.ptr;
  b->len = s.len;
  b->wi = 0;
  b->ri = 0;
  b->closed = false;
  o->private_impl.buf = b;
  o->private_impl.bounds[0] = s.ptr;
  o->private_impl.bounds[1] = s.ptr + s.len;
  *ioptr1_ptr = s.ptr;
  *ioptr2_ptr = s.ptr + s.len;
  return ((wuffs_base__empty_struct){});
}

static inline wuffs_base__empty_struct wuffs_base__io_writer__set_mark(
    wuffs_base__io_writer* o,
    uint8_t* mark) {
  o->private_impl.bounds[0] = mark;
  return ((wuffs_base__empty_struct){});
}

static const char* wuffs_base__status__strings[13] = {
    "ok",
    "bad wuffs version",
    "bad receiver",
    "bad argument",
    "initializer not called",
    "invalid I/O operation",
    "closed for writes",
    "unexpected EOF",
    "short read",
    "short write",
    "cannot return a suspension",
    "invalid call sequence",
    "end of data",
};

#endif  // WUFFS_BASE_IMPL_H

// ---------------- Status Codes Implementations

bool wuffs_gif__status__is_error(wuffs_gif__status s) {
  return s < 0;
}

const char* wuffs_gif__status__strings[11] = {
    "gif: bad block",
    "gif: bad extension label",
    "gif: bad graphic control",
    "gif: bad header",
    "gif: bad literal width",
    "gif: not enough pixel data",
    "gif: too much pixel data",
    "gif: internal error: inconsistent ri/wi",
    "gif: TODO: unsupported interlacing",
    "gif: LZW code is out of range",
    "gif: LZW prefix chain is cyclical",
};

const char* wuffs_gif__status__string(wuffs_gif__status s) {
  const char** a = NULL;
  uint32_t n = 0;
  switch ((s >> 10) & 0x1FFFFF) {
    case 0:
      a = wuffs_base__status__strings;
      n = 13;
      break;
    case wuffs_gif__packageid:
      a = wuffs_gif__status__strings;
      n = 11;
      break;
  }
  uint32_t i = s & 0xFF;
  return i < n ? a[i] : "unknown status";
}

// ---------------- Private Consts

static const uint8_t wuffs_gif__animexts1dot0[11] = {
    65, 78, 73, 77, 69, 88, 84, 83, 49, 46, 48,
};

static const uint8_t wuffs_gif__netscape2dot0[11] = {
    78, 69, 84, 83, 67, 65, 80, 69, 50, 46, 48,
};

// ---------------- Private Initializer Prototypes

void wuffs_gif__lzw_decoder__initialize(wuffs_gif__lzw_decoder* self,
                                        uint32_t wuffs_version,
                                        uint32_t for_internal_use_only);

// ---------------- Private Function Prototypes

static wuffs_gif__status wuffs_gif__decoder__decode_header(
    wuffs_gif__decoder* self,
    wuffs_base__io_reader a_src);

static wuffs_gif__status wuffs_gif__decoder__decode_lsd(
    wuffs_gif__decoder* self,
    wuffs_base__io_reader a_src);

static wuffs_gif__status wuffs_gif__decoder__decode_extension(
    wuffs_gif__decoder* self,
    wuffs_base__io_reader a_src);

static wuffs_gif__status wuffs_gif__decoder__skip_blocks(
    wuffs_gif__decoder* self,
    wuffs_base__io_reader a_src);

static wuffs_gif__status wuffs_gif__decoder__decode_ae(
    wuffs_gif__decoder* self,
    wuffs_base__io_reader a_src);

static wuffs_gif__status wuffs_gif__decoder__decode_gc(
    wuffs_gif__decoder* self,
    wuffs_base__io_reader a_src);

static wuffs_gif__status wuffs_gif__decoder__decode_id_part0(
    wuffs_gif__decoder* self,
    wuffs_base__io_reader a_src);

static wuffs_gif__status wuffs_gif__decoder__decode_id_part1(
    wuffs_gif__decoder* self,
    wuffs_base__image_buffer* a_ib,
    wuffs_base__io_reader a_src);

static wuffs_gif__status wuffs_gif__decoder__copy_to_image_buffer(
    wuffs_gif__decoder* self,
    wuffs_base__image_buffer* a_ib);

static void wuffs_gif__lzw_decoder__set_literal_width(
    wuffs_gif__lzw_decoder* self,
    uint32_t a_lw);

static wuffs_gif__status wuffs_gif__lzw_decoder__decode(
    wuffs_gif__lzw_decoder* self,
    wuffs_base__io_writer a_dst,
    wuffs_base__io_reader a_src);

// ---------------- Initializer Implementations

void wuffs_gif__lzw_decoder__initialize(wuffs_gif__lzw_decoder* self,
                                        uint32_t wuffs_version,
                                        uint32_t for_internal_use_only) {
  if (!self) {
    return;
  }
  if (wuffs_version != WUFFS_VERSION) {
    self->private_impl.status = WUFFS_GIF__ERROR_BAD_WUFFS_VERSION;
    return;
  }
  if (for_internal_use_only != WUFFS_BASE__ALREADY_ZEROED) {
    memset(self, 0, sizeof(*self));
  }
  self->private_impl.magic = WUFFS_BASE__MAGIC;
  self->private_impl.f_literal_width = 8;
}

void wuffs_gif__decoder__initialize(wuffs_gif__decoder* self,
                                    uint32_t wuffs_version,
                                    uint32_t for_internal_use_only) {
  if (!self) {
    return;
  }
  if (wuffs_version != WUFFS_VERSION) {
    self->private_impl.status = WUFFS_GIF__ERROR_BAD_WUFFS_VERSION;
    return;
  }
  if (for_internal_use_only != WUFFS_BASE__ALREADY_ZEROED) {
    memset(self, 0, sizeof(*self));
  }
  self->private_impl.magic = WUFFS_BASE__MAGIC;
  self->private_impl.f_num_loops = 1;
  wuffs_gif__lzw_decoder__initialize(&self->private_impl.f_lzw, WUFFS_VERSION,
                                     WUFFS_BASE__ALREADY_ZEROED);
}

// ---------------- Function Implementations

// -------- func decoder.decode_config

wuffs_gif__status wuffs_gif__decoder__decode_config(
    wuffs_gif__decoder* self,
    wuffs_base__image_config* a_dst,
    wuffs_base__io_reader a_src) {
  if (!self) {
    return WUFFS_GIF__ERROR_BAD_RECEIVER;
  }
  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {
    self->private_impl.status = WUFFS_GIF__ERROR_INITIALIZER_NOT_CALLED;
  }
  if (self->private_impl.status < 0) {
    return self->private_impl.status;
  }
  if (!a_dst) {
    self->private_impl.status = WUFFS_GIF__ERROR_BAD_ARGUMENT;
    return WUFFS_GIF__ERROR_BAD_ARGUMENT;
  }
  wuffs_gif__status status = WUFFS_GIF__STATUS_OK;

  uint32_t coro_susp_point =
      self->private_impl.c_decode_config[0].coro_susp_point;
  if (coro_susp_point) {
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    if (self->private_impl.f_call_sequence >= 1) {
      status = WUFFS_GIF__ERROR_INVALID_CALL_SEQUENCE;
      goto exit;
    }
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
    status = wuffs_gif__decoder__decode_header(self, a_src);
    if (status) {
      goto suspend;
    }
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
    status = wuffs_gif__decoder__decode_lsd(self, a_src);
    if (status) {
      goto suspend;
    }
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
    status = wuffs_gif__decoder__decode_up_to_id_part1(self, a_src);
    if (status) {
      goto suspend;
    }
    wuffs_base__image_config__initialize(
        a_dst, 570984584, 0, self->private_impl.f_width,
        self->private_impl.f_height, self->private_impl.f_num_loops);
    self->private_impl.f_call_sequence = 1;

    goto ok;
  ok:
    self->private_impl.c_decode_config[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_config[0].coro_susp_point = coro_susp_point;

  goto exit;
exit:
  self->private_impl.status = status;
  return status;
}

// -------- func decoder.decode_frame

wuffs_gif__status wuffs_gif__decoder__decode_frame(
    wuffs_gif__decoder* self,
    wuffs_base__image_buffer* a_ib,
    wuffs_base__io_reader a_src) {
  if (!self) {
    return WUFFS_GIF__ERROR_BAD_RECEIVER;
  }
  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {
    self->private_impl.status = WUFFS_GIF__ERROR_INITIALIZER_NOT_CALLED;
  }
  if (self->private_impl.status < 0) {
    return self->private_impl.status;
  }
  if (!a_ib) {
    self->private_impl.status = WUFFS_GIF__ERROR_BAD_ARGUMENT;
    return WUFFS_GIF__ERROR_BAD_ARGUMENT;
  }
  wuffs_gif__status status = WUFFS_GIF__STATUS_OK;

  uint32_t coro_susp_point =
      self->private_impl.c_decode_frame[0].coro_susp_point;
  if (coro_susp_point) {
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    if (self->private_impl.f_call_sequence == 0) {
      status = WUFFS_GIF__ERROR_INVALID_CALL_SEQUENCE;
      goto exit;
    }
    if (!self->private_impl.f_end_of_data) {
      if (self->private_impl.f_call_sequence == 1) {
        self->private_impl.f_call_sequence = 2;
      } else {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
        status = wuffs_gif__decoder__decode_up_to_id_part1(self, a_src);
        if (status) {
          goto suspend;
        }
      }
    }
    if (self->private_impl.f_end_of_data) {
      while (true) {
        status = WUFFS_GIF__SUSPENSION_END_OF_DATA;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(2);
      }
    }
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
    status = wuffs_gif__decoder__decode_id_part1(self, a_ib, a_src);
    if (status) {
      goto suspend;
    }

    goto ok;
  ok:
    self->private_impl.c_decode_frame[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_frame[0].coro_susp_point = coro_susp_point;

  goto exit;
exit:
  self->private_impl.status = status;
  return status;
}

// -------- func decoder.decode_up_to_id_part1

wuffs_gif__status wuffs_gif__decoder__decode_up_to_id_part1(
    wuffs_gif__decoder* self,
    wuffs_base__io_reader a_src) {
  if (!self) {
    return WUFFS_GIF__ERROR_BAD_RECEIVER;
  }
  if (self->private_impl.magic != WUFFS_BASE__MAGIC) {
    self->private_impl.status = WUFFS_GIF__ERROR_INITIALIZER_NOT_CALLED;
  }
  if (self->private_impl.status < 0) {
    return self->private_impl.status;
  }
  wuffs_gif__status status = WUFFS_GIF__STATUS_OK;

  uint8_t v_block_type;

  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point =
      self->private_impl.c_decode_up_to_id_part1[0].coro_susp_point;
  if (coro_susp_point) {
    v_block_type = self->private_impl.c_decode_up_to_id_part1[0].v_block_type;
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    while (true) {
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
        if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
          goto short_read_src;
        }
        uint8_t t_0 = *ioptr_src++;
        v_block_type = t_0;
      }
      if (v_block_type == 33) {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
        if (a_src.private_impl.buf) {
          a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
        }
        status = wuffs_gif__decoder__decode_extension(self, a_src);
        if (a_src.private_impl.buf) {
          ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
        }
        if (status) {
          goto suspend;
        }
      } else if (v_block_type == 44) {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
        if (a_src.private_impl.buf) {
          a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
        }
        status = wuffs_gif__decoder__decode_id_part0(self, a_src);
        if (a_src.private_impl.buf) {
          ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
        }
        if (status) {
          goto suspend;
        }
        goto label_0_break;
      } else if (v_block_type == 59) {
        self->private_impl.f_end_of_data = true;
        goto label_0_break;
      } else {
        status = WUFFS_GIF__ERROR_BAD_BLOCK;
        goto exit;
      }
    }
  label_0_break:;

    goto ok;
  ok:
    self->private_impl.c_decode_up_to_id_part1[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_up_to_id_part1[0].coro_susp_point =
      coro_susp_point;
  self->private_impl.c_decode_up_to_id_part1[0].v_block_type = v_block_type;

  goto exit;
exit:
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  self->private_impl.status = status;
  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_GIF__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_GIF__SUSPENSION_SHORT_READ;
  goto suspend;
}

// -------- func decoder.decode_header

static wuffs_gif__status wuffs_gif__decoder__decode_header(
    wuffs_gif__decoder* self,
    wuffs_base__io_reader a_src) {
  wuffs_gif__status status = WUFFS_GIF__STATUS_OK;

  uint8_t v_c[6];
  uint32_t v_i;

  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point =
      self->private_impl.c_decode_header[0].coro_susp_point;
  if (coro_susp_point) {
    memcpy(v_c, self->private_impl.c_decode_header[0].v_c, sizeof(v_c));
    v_i = self->private_impl.c_decode_header[0].v_i;
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    memset(v_c, 0, sizeof(v_c));
    v_i = 0;
    while (v_i < 6) {
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
        if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
          goto short_read_src;
        }
        uint8_t t_0 = *ioptr_src++;
        v_c[v_i] = t_0;
      }
      v_i += 1;
    }
    if ((v_c[0] != 71) || (v_c[1] != 73) || (v_c[2] != 70) || (v_c[3] != 56) ||
        ((v_c[4] != 55) && (v_c[4] != 57)) || (v_c[5] != 97)) {
      status = WUFFS_GIF__ERROR_BAD_HEADER;
      goto exit;
    }

    goto ok;
  ok:
    self->private_impl.c_decode_header[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_header[0].coro_susp_point = coro_susp_point;
  memcpy(self->private_impl.c_decode_header[0].v_c, v_c, sizeof(v_c));
  self->private_impl.c_decode_header[0].v_i = v_i;

  goto exit;
exit:
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_GIF__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_GIF__SUSPENSION_SHORT_READ;
  goto suspend;
}

// -------- func decoder.decode_lsd

static wuffs_gif__status wuffs_gif__decoder__decode_lsd(
    wuffs_gif__decoder* self,
    wuffs_base__io_reader a_src) {
  wuffs_gif__status status = WUFFS_GIF__STATUS_OK;

  uint8_t v_c[7];
  uint32_t v_i;
  uint8_t v_flags;
  uint32_t v_num_palette_entries;

  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point = self->private_impl.c_decode_lsd[0].coro_susp_point;
  if (coro_susp_point) {
    memcpy(v_c, self->private_impl.c_decode_lsd[0].v_c, sizeof(v_c));
    v_i = self->private_impl.c_decode_lsd[0].v_i;
    v_flags = self->private_impl.c_decode_lsd[0].v_flags;
    v_num_palette_entries =
        self->private_impl.c_decode_lsd[0].v_num_palette_entries;
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    memset(v_c, 0, sizeof(v_c));
    v_i = 0;
    while (v_i < 7) {
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
        if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
          goto short_read_src;
        }
        uint8_t t_0 = *ioptr_src++;
        v_c[v_i] = t_0;
      }
      v_i += 1;
    }
    self->private_impl.f_width =
        (((uint32_t)(v_c[0])) | (((uint32_t)(v_c[1])) << 8));
    self->private_impl.f_height =
        (((uint32_t)(v_c[2])) | (((uint32_t)(v_c[3])) << 8));
    v_flags = v_c[4];
    self->private_impl.f_background_color_index = v_c[5];
    if ((v_flags & 128) != 0) {
      v_num_palette_entries = (((uint32_t)(1)) << (1 + (v_flags & 7)));
      v_i = 0;
      while (v_i < v_num_palette_entries) {
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint8_t t_1 = *ioptr_src++;
          self->private_impl.f_palettes[0][((4 * v_i) + 2)] = t_1;
        }
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint8_t t_2 = *ioptr_src++;
          self->private_impl.f_palettes[0][((4 * v_i) + 1)] = t_2;
        }
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(4);
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint8_t t_3 = *ioptr_src++;
          self->private_impl.f_palettes[0][((4 * v_i) + 0)] = t_3;
        }
        self->private_impl.f_palettes[0][((4 * v_i) + 3)] = 255;
        v_i += 1;
      }
      while (v_i < 256) {
        self->private_impl.f_palettes[0][((4 * v_i) + 0)] = 0;
        self->private_impl.f_palettes[0][((4 * v_i) + 1)] = 0;
        self->private_impl.f_palettes[0][((4 * v_i) + 2)] = 0;
        self->private_impl.f_palettes[0][((4 * v_i) + 3)] = 0;
        v_i += 1;
      }
    }

    goto ok;
  ok:
    self->private_impl.c_decode_lsd[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_lsd[0].coro_susp_point = coro_susp_point;
  memcpy(self->private_impl.c_decode_lsd[0].v_c, v_c, sizeof(v_c));
  self->private_impl.c_decode_lsd[0].v_i = v_i;
  self->private_impl.c_decode_lsd[0].v_flags = v_flags;
  self->private_impl.c_decode_lsd[0].v_num_palette_entries =
      v_num_palette_entries;

  goto exit;
exit:
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_GIF__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_GIF__SUSPENSION_SHORT_READ;
  goto suspend;
}

// -------- func decoder.decode_extension

static wuffs_gif__status wuffs_gif__decoder__decode_extension(
    wuffs_gif__decoder* self,
    wuffs_base__io_reader a_src) {
  wuffs_gif__status status = WUFFS_GIF__STATUS_OK;

  uint8_t v_label;

  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point =
      self->private_impl.c_decode_extension[0].coro_susp_point;
  if (coro_susp_point) {
    v_label = self->private_impl.c_decode_extension[0].v_label;
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
      if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
        goto short_read_src;
      }
      uint8_t t_0 = *ioptr_src++;
      v_label = t_0;
    }
    if (v_label == 249) {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
      if (a_src.private_impl.buf) {
        a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
      }
      status = wuffs_gif__decoder__decode_gc(self, a_src);
      if (a_src.private_impl.buf) {
        ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
      }
      if (status) {
        goto suspend;
      }
      status = WUFFS_GIF__STATUS_OK;
      goto ok;
    } else if (v_label == 255) {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
      if (a_src.private_impl.buf) {
        a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
      }
      status = wuffs_gif__decoder__decode_ae(self, a_src);
      if (a_src.private_impl.buf) {
        ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
      }
      if (status) {
        goto suspend;
      }
      status = WUFFS_GIF__STATUS_OK;
      goto ok;
    }
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(4);
    if (a_src.private_impl.buf) {
      a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
    }
    status = wuffs_gif__decoder__skip_blocks(self, a_src);
    if (a_src.private_impl.buf) {
      ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    }
    if (status) {
      goto suspend;
    }

    goto ok;
  ok:
    self->private_impl.c_decode_extension[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_extension[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode_extension[0].v_label = v_label;

  goto exit;
exit:
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_GIF__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_GIF__SUSPENSION_SHORT_READ;
  goto suspend;
}

// -------- func decoder.skip_blocks

static wuffs_gif__status wuffs_gif__decoder__skip_blocks(
    wuffs_gif__decoder* self,
    wuffs_base__io_reader a_src) {
  wuffs_gif__status status = WUFFS_GIF__STATUS_OK;

  uint8_t v_block_size;

  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point =
      self->private_impl.c_skip_blocks[0].coro_susp_point;
  if (coro_susp_point) {
    v_block_size = self->private_impl.c_skip_blocks[0].v_block_size;
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    while (true) {
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
        if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
          goto short_read_src;
        }
        uint8_t t_0 = *ioptr_src++;
        v_block_size = t_0;
      }
      if (v_block_size == 0) {
        status = WUFFS_GIF__STATUS_OK;
        goto ok;
      }
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
      self->private_impl.c_skip_blocks[0].scratch = ((uint32_t)(v_block_size));
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
      if (self->private_impl.c_skip_blocks[0].scratch >
          iobounds1_src - ioptr_src) {
        self->private_impl.c_skip_blocks[0].scratch -=
            iobounds1_src - ioptr_src;
        ioptr_src = iobounds1_src;
        goto short_read_src;
      }
      ioptr_src += self->private_impl.c_skip_blocks[0].scratch;
    }

    goto ok;
  ok:
    self->private_impl.c_skip_blocks[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_skip_blocks[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_skip_blocks[0].v_block_size = v_block_size;

  goto exit;
exit:
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_GIF__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_GIF__SUSPENSION_SHORT_READ;
  goto suspend;
}

// -------- func decoder.decode_ae

static wuffs_gif__status wuffs_gif__decoder__decode_ae(
    wuffs_gif__decoder* self,
    wuffs_base__io_reader a_src) {
  wuffs_gif__status status = WUFFS_GIF__STATUS_OK;

  uint8_t v_c;
  uint8_t v_block_size;
  bool v_not_animexts;
  bool v_not_netscape;

  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point = self->private_impl.c_decode_ae[0].coro_susp_point;
  if (coro_susp_point) {
    v_c = self->private_impl.c_decode_ae[0].v_c;
    v_block_size = self->private_impl.c_decode_ae[0].v_block_size;
    v_not_animexts = self->private_impl.c_decode_ae[0].v_not_animexts;
    v_not_netscape = self->private_impl.c_decode_ae[0].v_not_netscape;
  } else {
    v_not_animexts = false;
    v_not_netscape = false;
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    while (true) {
      v_c = 0;
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
        if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
          goto short_read_src;
        }
        uint8_t t_0 = *ioptr_src++;
        v_block_size = t_0;
      }
      if (v_block_size == 0) {
        status = WUFFS_GIF__STATUS_OK;
        goto ok;
      }
      if (v_block_size != 11) {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
        self->private_impl.c_decode_ae[0].scratch = ((uint32_t)(v_block_size));
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
        if (self->private_impl.c_decode_ae[0].scratch >
            iobounds1_src - ioptr_src) {
          self->private_impl.c_decode_ae[0].scratch -=
              iobounds1_src - ioptr_src;
          ioptr_src = iobounds1_src;
          goto short_read_src;
        }
        ioptr_src += self->private_impl.c_decode_ae[0].scratch;
        goto label_0_break;
      }
      v_not_animexts = 0;
      v_not_netscape = 0;
      v_block_size = 0;
      while (v_block_size < 11) {
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(4);
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint8_t t_1 = *ioptr_src++;
          v_c = t_1;
        }
        v_not_animexts =
            (v_not_animexts || (v_c != wuffs_gif__animexts1dot0[v_block_size]));
        v_not_netscape =
            (v_not_netscape || (v_c != wuffs_gif__netscape2dot0[v_block_size]));
        v_block_size += 1;
      }
      if (v_not_animexts && v_not_netscape) {
        goto label_0_break;
      }
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(5);
        if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
          goto short_read_src;
        }
        uint8_t t_2 = *ioptr_src++;
        v_block_size = t_2;
      }
      if (v_block_size != 3) {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(6);
        self->private_impl.c_decode_ae[0].scratch = ((uint32_t)(v_block_size));
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(7);
        if (self->private_impl.c_decode_ae[0].scratch >
            iobounds1_src - ioptr_src) {
          self->private_impl.c_decode_ae[0].scratch -=
              iobounds1_src - ioptr_src;
          ioptr_src = iobounds1_src;
          goto short_read_src;
        }
        ioptr_src += self->private_impl.c_decode_ae[0].scratch;
        goto label_0_break;
      }
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(8);
        if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
          goto short_read_src;
        }
        uint8_t t_3 = *ioptr_src++;
        v_c = t_3;
      }
      if (v_c != 1) {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(9);
        self->private_impl.c_decode_ae[0].scratch = 2;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(10);
        if (self->private_impl.c_decode_ae[0].scratch >
            iobounds1_src - ioptr_src) {
          self->private_impl.c_decode_ae[0].scratch -=
              iobounds1_src - ioptr_src;
          ioptr_src = iobounds1_src;
          goto short_read_src;
        }
        ioptr_src += self->private_impl.c_decode_ae[0].scratch;
        goto label_0_break;
      }
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(11);
        uint16_t t_5;
        if (WUFFS_BASE__LIKELY(iobounds1_src - ioptr_src >= 2)) {
          t_5 = wuffs_base__load_u16le(ioptr_src);
          ioptr_src += 2;
        } else {
          self->private_impl.c_decode_ae[0].scratch = 0;
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(12);
          while (true) {
            if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
              goto short_read_src;
            }
            uint32_t t_4 = self->private_impl.c_decode_ae[0].scratch >> 56;
            self->private_impl.c_decode_ae[0].scratch <<= 8;
            self->private_impl.c_decode_ae[0].scratch >>= 8;
            self->private_impl.c_decode_ae[0].scratch |=
                ((uint64_t)(*ioptr_src++)) << t_4;
            if (t_4 == 8) {
              t_5 = self->private_impl.c_decode_ae[0].scratch;
              break;
            }
            t_4 += 8;
            self->private_impl.c_decode_ae[0].scratch |= ((uint64_t)(t_4))
                                                         << 56;
          }
        }
        self->private_impl.f_num_loops = ((uint32_t)(t_5));
      }
      self->private_impl.f_seen_num_loops = true;
      if ((0 < self->private_impl.f_num_loops) &&
          (self->private_impl.f_num_loops <= 65535)) {
        self->private_impl.f_num_loops += 1;
      }
      goto label_0_break;
    }
  label_0_break:;
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(13);
    if (a_src.private_impl.buf) {
      a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
    }
    status = wuffs_gif__decoder__skip_blocks(self, a_src);
    if (a_src.private_impl.buf) {
      ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    }
    if (status) {
      goto suspend;
    }

    goto ok;
  ok:
    self->private_impl.c_decode_ae[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_ae[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode_ae[0].v_c = v_c;
  self->private_impl.c_decode_ae[0].v_block_size = v_block_size;
  self->private_impl.c_decode_ae[0].v_not_animexts = v_not_animexts;
  self->private_impl.c_decode_ae[0].v_not_netscape = v_not_netscape;

  goto exit;
exit:
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_GIF__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_GIF__SUSPENSION_SHORT_READ;
  goto suspend;
}

// -------- func decoder.decode_gc

static wuffs_gif__status wuffs_gif__decoder__decode_gc(
    wuffs_gif__decoder* self,
    wuffs_base__io_reader a_src) {
  wuffs_gif__status status = WUFFS_GIF__STATUS_OK;

  uint8_t v_flags;

  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point = self->private_impl.c_decode_gc[0].coro_susp_point;
  if (coro_susp_point) {
    v_flags = self->private_impl.c_decode_gc[0].v_flags;
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    if (self->private_impl.f_seen_graphic_control) {
      status = WUFFS_GIF__ERROR_BAD_GRAPHIC_CONTROL;
      goto exit;
    }
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
    if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
      goto short_read_src;
    }
    uint8_t t_0 = *ioptr_src++;
    if (t_0 != 4) {
      status = WUFFS_GIF__ERROR_BAD_GRAPHIC_CONTROL;
      goto exit;
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
      if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
        goto short_read_src;
      }
      uint8_t t_1 = *ioptr_src++;
      v_flags = t_1;
    }
    self->private_impl.f_gc_has_transparent_index = ((v_flags & 1) != 0);
    self->private_impl.f_gc_disposal = ((v_flags >> 2) & 7);
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
      uint16_t t_3;
      if (WUFFS_BASE__LIKELY(iobounds1_src - ioptr_src >= 2)) {
        t_3 = wuffs_base__load_u16le(ioptr_src);
        ioptr_src += 2;
      } else {
        self->private_impl.c_decode_gc[0].scratch = 0;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(4);
        while (true) {
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint32_t t_2 = self->private_impl.c_decode_gc[0].scratch >> 56;
          self->private_impl.c_decode_gc[0].scratch <<= 8;
          self->private_impl.c_decode_gc[0].scratch >>= 8;
          self->private_impl.c_decode_gc[0].scratch |=
              ((uint64_t)(*ioptr_src++)) << t_2;
          if (t_2 == 8) {
            t_3 = self->private_impl.c_decode_gc[0].scratch;
            break;
          }
          t_2 += 8;
          self->private_impl.c_decode_gc[0].scratch |= ((uint64_t)(t_2)) << 56;
        }
      }
      self->private_impl.f_gc_duration = (((uint64_t)(t_3)) * 7056000);
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(5);
      if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
        goto short_read_src;
      }
      uint8_t t_4 = *ioptr_src++;
      self->private_impl.f_gc_transparent_index = t_4;
    }
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT(6);
    if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
      goto short_read_src;
    }
    uint8_t t_5 = *ioptr_src++;
    if (t_5 != 0) {
      status = WUFFS_GIF__ERROR_BAD_GRAPHIC_CONTROL;
      goto exit;
    }
    self->private_impl.f_seen_graphic_control = true;

    goto ok;
  ok:
    self->private_impl.c_decode_gc[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_gc[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode_gc[0].v_flags = v_flags;

  goto exit;
exit:
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_GIF__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_GIF__SUSPENSION_SHORT_READ;
  goto suspend;
}

// -------- func decoder.decode_id_part0

static wuffs_gif__status wuffs_gif__decoder__decode_id_part0(
    wuffs_gif__decoder* self,
    wuffs_base__io_reader a_src) {
  wuffs_gif__status status = WUFFS_GIF__STATUS_OK;

  uint32_t v_frame_x;
  uint32_t v_frame_y;

  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point =
      self->private_impl.c_decode_id_part0[0].coro_susp_point;
  if (coro_susp_point) {
    v_frame_x = self->private_impl.c_decode_id_part0[0].v_frame_x;
    v_frame_y = self->private_impl.c_decode_id_part0[0].v_frame_y;
  } else {
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
      uint16_t t_1;
      if (WUFFS_BASE__LIKELY(iobounds1_src - ioptr_src >= 2)) {
        t_1 = wuffs_base__load_u16le(ioptr_src);
        ioptr_src += 2;
      } else {
        self->private_impl.c_decode_id_part0[0].scratch = 0;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
        while (true) {
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint32_t t_0 = self->private_impl.c_decode_id_part0[0].scratch >> 56;
          self->private_impl.c_decode_id_part0[0].scratch <<= 8;
          self->private_impl.c_decode_id_part0[0].scratch >>= 8;
          self->private_impl.c_decode_id_part0[0].scratch |=
              ((uint64_t)(*ioptr_src++)) << t_0;
          if (t_0 == 8) {
            t_1 = self->private_impl.c_decode_id_part0[0].scratch;
            break;
          }
          t_0 += 8;
          self->private_impl.c_decode_id_part0[0].scratch |= ((uint64_t)(t_0))
                                                             << 56;
        }
      }
      v_frame_x = ((uint32_t)(t_1));
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
      uint16_t t_3;
      if (WUFFS_BASE__LIKELY(iobounds1_src - ioptr_src >= 2)) {
        t_3 = wuffs_base__load_u16le(ioptr_src);
        ioptr_src += 2;
      } else {
        self->private_impl.c_decode_id_part0[0].scratch = 0;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(4);
        while (true) {
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint32_t t_2 = self->private_impl.c_decode_id_part0[0].scratch >> 56;
          self->private_impl.c_decode_id_part0[0].scratch <<= 8;
          self->private_impl.c_decode_id_part0[0].scratch >>= 8;
          self->private_impl.c_decode_id_part0[0].scratch |=
              ((uint64_t)(*ioptr_src++)) << t_2;
          if (t_2 == 8) {
            t_3 = self->private_impl.c_decode_id_part0[0].scratch;
            break;
          }
          t_2 += 8;
          self->private_impl.c_decode_id_part0[0].scratch |= ((uint64_t)(t_2))
                                                             << 56;
        }
      }
      v_frame_y = ((uint32_t)(t_3));
    }
    wuffs_base__rect_ie_u32__set_min_inclusive_x(
        &self->private_impl.f_frame_rect, v_frame_x);
    wuffs_base__rect_ie_u32__set_min_inclusive_y(
        &self->private_impl.f_frame_rect, v_frame_y);
    self->private_impl.f_dst_x = v_frame_x;
    self->private_impl.f_dst_y = v_frame_y;
    self->private_impl.f_dst_x0 = v_frame_x;
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(5);
      uint16_t t_5;
      if (WUFFS_BASE__LIKELY(iobounds1_src - ioptr_src >= 2)) {
        t_5 = wuffs_base__load_u16le(ioptr_src);
        ioptr_src += 2;
      } else {
        self->private_impl.c_decode_id_part0[0].scratch = 0;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(6);
        while (true) {
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint32_t t_4 = self->private_impl.c_decode_id_part0[0].scratch >> 56;
          self->private_impl.c_decode_id_part0[0].scratch <<= 8;
          self->private_impl.c_decode_id_part0[0].scratch >>= 8;
          self->private_impl.c_decode_id_part0[0].scratch |=
              ((uint64_t)(*ioptr_src++)) << t_4;
          if (t_4 == 8) {
            t_5 = self->private_impl.c_decode_id_part0[0].scratch;
            break;
          }
          t_4 += 8;
          self->private_impl.c_decode_id_part0[0].scratch |= ((uint64_t)(t_4))
                                                             << 56;
        }
      }
      v_frame_x += ((uint32_t)(t_5));
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(7);
      uint16_t t_7;
      if (WUFFS_BASE__LIKELY(iobounds1_src - ioptr_src >= 2)) {
        t_7 = wuffs_base__load_u16le(ioptr_src);
        ioptr_src += 2;
      } else {
        self->private_impl.c_decode_id_part0[0].scratch = 0;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(8);
        while (true) {
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint32_t t_6 = self->private_impl.c_decode_id_part0[0].scratch >> 56;
          self->private_impl.c_decode_id_part0[0].scratch <<= 8;
          self->private_impl.c_decode_id_part0[0].scratch >>= 8;
          self->private_impl.c_decode_id_part0[0].scratch |=
              ((uint64_t)(*ioptr_src++)) << t_6;
          if (t_6 == 8) {
            t_7 = self->private_impl.c_decode_id_part0[0].scratch;
            break;
          }
          t_6 += 8;
          self->private_impl.c_decode_id_part0[0].scratch |= ((uint64_t)(t_6))
                                                             << 56;
        }
      }
      v_frame_y += ((uint32_t)(t_7));
    }
    wuffs_base__rect_ie_u32__set_max_exclusive_x(
        &self->private_impl.f_frame_rect, v_frame_x);
    wuffs_base__rect_ie_u32__set_max_exclusive_y(
        &self->private_impl.f_frame_rect, v_frame_y);
    self->private_impl.f_dst_x1 = v_frame_x;
    self->private_impl.f_dst_y1 = v_frame_y;
    if (self->private_impl.f_call_sequence == 0) {
      self->private_impl.f_width =
          wuffs_base__u32__max(self->private_impl.f_width, v_frame_x);
      self->private_impl.f_height =
          wuffs_base__u32__max(self->private_impl.f_height, v_frame_y);
    }

    goto ok;
  ok:
    self->private_impl.c_decode_id_part0[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_id_part0[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode_id_part0[0].v_frame_x = v_frame_x;
  self->private_impl.c_decode_id_part0[0].v_frame_y = v_frame_y;

  goto exit;
exit:
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_GIF__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_GIF__SUSPENSION_SHORT_READ;
  goto suspend;
}

// -------- func decoder.decode_id_part1

static wuffs_gif__status wuffs_gif__decoder__decode_id_part1(
    wuffs_gif__decoder* self,
    wuffs_base__image_buffer* a_ib,
    wuffs_base__io_reader a_src) {
  wuffs_gif__status status = WUFFS_GIF__STATUS_OK;

  uint8_t v_flags;
  bool v_use_local_palette;
  uint32_t v_num_palette_entries;
  uint32_t v_i;
  uint8_t v_lw;
  uint64_t v_block_size;
  wuffs_base__io_writer v_w;
  wuffs_base__io_buffer u_w;
  uint8_t* ioptr_w = NULL;
  uint8_t* iobounds1_w = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(u_w);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(ioptr_w);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_w);
  wuffs_gif__status v_z;
  wuffs_base__slice_u8 v_palette;

  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point =
      self->private_impl.c_decode_id_part1[0].coro_susp_point;
  if (coro_susp_point) {
    v_flags = self->private_impl.c_decode_id_part1[0].v_flags;
    v_use_local_palette =
        self->private_impl.c_decode_id_part1[0].v_use_local_palette;
    v_num_palette_entries =
        self->private_impl.c_decode_id_part1[0].v_num_palette_entries;
    v_i = self->private_impl.c_decode_id_part1[0].v_i;
    v_lw = self->private_impl.c_decode_id_part1[0].v_lw;
    v_block_size = self->private_impl.c_decode_id_part1[0].v_block_size;
    v_w = ((wuffs_base__io_writer){});
    v_z = self->private_impl.c_decode_id_part1[0].v_z;
    v_palette = ((wuffs_base__slice_u8){});
  } else {
    v_use_local_palette = false;
    v_w = ((wuffs_base__io_writer){});
    v_palette = ((wuffs_base__slice_u8){});
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
      if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
        goto short_read_src;
      }
      uint8_t t_0 = *ioptr_src++;
      v_flags = t_0;
    }
    self->private_impl.f_interlace = ((v_flags & 64) != 0);
    v_use_local_palette = ((v_flags & 128) != 0);
    if (v_use_local_palette) {
      v_num_palette_entries = (((uint32_t)(1)) << (1 + (v_flags & 7)));
      v_i = 0;
      while (v_i < v_num_palette_entries) {
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint8_t t_1 = *ioptr_src++;
          self->private_impl.f_palettes[1][((4 * v_i) + 2)] = t_1;
        }
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(3);
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint8_t t_2 = *ioptr_src++;
          self->private_impl.f_palettes[1][((4 * v_i) + 1)] = t_2;
        }
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(4);
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint8_t t_3 = *ioptr_src++;
          self->private_impl.f_palettes[1][((4 * v_i) + 0)] = t_3;
        }
        self->private_impl.f_palettes[1][((4 * v_i) + 3)] = 255;
        v_i += 1;
      }
      while (v_i < 256) {
        self->private_impl.f_palettes[1][((4 * v_i) + 0)] = 0;
        self->private_impl.f_palettes[1][((4 * v_i) + 1)] = 0;
        self->private_impl.f_palettes[1][((4 * v_i) + 2)] = 0;
        self->private_impl.f_palettes[1][((4 * v_i) + 3)] = 0;
        v_i += 1;
      }
    }
    if (self->private_impl.f_previous_lzw_decode_ended_abruptly) {
      wuffs_gif__lzw_decoder__initialize(&self->private_impl.f_lzw,
                                         WUFFS_VERSION, 0);
    }
    {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(5);
      if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
        goto short_read_src;
      }
      uint8_t t_4 = *ioptr_src++;
      v_lw = t_4;
    }
    if ((v_lw < 2) || (8 < v_lw)) {
      status = WUFFS_GIF__ERROR_BAD_LITERAL_WIDTH;
      goto exit;
    }
    wuffs_gif__lzw_decoder__set_literal_width(&self->private_impl.f_lzw,
                                              ((uint32_t)(v_lw)));
    self->private_impl.f_previous_lzw_decode_ended_abruptly = true;
    while (true) {
      {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(6);
        if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
          goto short_read_src;
        }
        uint8_t t_5 = *ioptr_src++;
        v_block_size = ((uint64_t)(t_5));
      }
      if (v_block_size == 0) {
        goto label_0_break;
      }
      self->private_impl.f_previous_lzw_decode_ended_abruptly = true;
    label_1_continue:;
      while (true) {
        v_w = ((wuffs_base__io_writer){});
        {
          wuffs_base__io_reader o_0_a_src = a_src;
          wuffs_base__io_writer o_0_v_w = v_w;
          uint8_t* o_0_ioptr_v_w = ioptr_w;
          uint8_t* o_0_iobounds1_v_w = iobounds1_w;
          wuffs_base__io_writer__set(
              &v_w, &u_w, &ioptr_w, &iobounds1_w,
              wuffs_base__slice_u8__subslice_i(
                  ((wuffs_base__slice_u8){
                      .ptr = self->private_impl.f_uncompressed, .len = 4096}),
                  self->private_impl.f_uncompressed_wi));
          wuffs_base__io_reader__set_limit(&a_src, ioptr_src, v_block_size);
          wuffs_base__io_reader__set_mark(&a_src, ioptr_src);
          {
            u_w.wi = ioptr_w - u_w.ptr;
            if (a_src.private_impl.buf) {
              a_src.private_impl.buf->ri =
                  ioptr_src - a_src.private_impl.buf->ptr;
            }
            wuffs_gif__status t_6 = wuffs_gif__lzw_decoder__decode(
                &self->private_impl.f_lzw, v_w, a_src);
            ioptr_w = u_w.ptr + u_w.wi;
            if (a_src.private_impl.buf) {
              ioptr_src =
                  a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
            }
            v_z = t_6;
          }
          self->private_impl.f_uncompressed_wi =
              (4096 - ((uint32_t)(wuffs_base__u64__min(
                          ((uint64_t)(iobounds1_w - ioptr_w)), 4096))));
          wuffs_base__u64__sat_sub_indirect(
              &v_block_size,
              ((uint64_t)(((wuffs_base__slice_u8){
                               .ptr = a_src.private_impl.bounds[0],
                               .len = (size_t)(ioptr_src -
                                               a_src.private_impl.bounds[0]),
                           })
                              .len)));
          v_w = o_0_v_w;
          ioptr_w = o_0_ioptr_v_w;
          iobounds1_w = o_0_iobounds1_v_w;
          a_src = o_0_a_src;
        }
        if ((v_z == 0) || (v_z == WUFFS_GIF__SUSPENSION_SHORT_WRITE)) {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(7);
          status = wuffs_gif__decoder__copy_to_image_buffer(self, a_ib);
          if (status) {
            goto suspend;
          }
          if (v_z == WUFFS_GIF__SUSPENSION_SHORT_WRITE) {
            goto label_1_continue;
          }
          self->private_impl.f_previous_lzw_decode_ended_abruptly = false;
          goto label_1_break;
        }
        if ((v_block_size == 0) && (v_z == WUFFS_GIF__SUSPENSION_SHORT_READ)) {
          goto label_1_break;
        }
        status = v_z;
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(8);
      }
    label_1_break:;
    }
  label_0_break:;
    if (self->private_impl.f_uncompressed_ri !=
        self->private_impl.f_uncompressed_wi) {
      WUFFS_BASE__COROUTINE_SUSPENSION_POINT(9);
      status = wuffs_gif__decoder__copy_to_image_buffer(self, a_ib);
      if (status) {
        goto suspend;
      }
    }
    v_palette = ((wuffs_base__slice_u8){});
    if (v_use_local_palette) {
      v_palette = ((wuffs_base__slice_u8){
          .ptr = self->private_impl.f_palettes[1], .len = 1024});
    } else if (!self->private_impl.f_previous_use_global_palette) {
      v_palette = ((wuffs_base__slice_u8){
          .ptr = self->private_impl.f_palettes[0], .len = 1024});
    }
    wuffs_base__image_buffer__update(a_ib, self->private_impl.f_frame_rect,
                                     self->private_impl.f_gc_duration,
                                     v_palette);
    self->private_impl.f_previous_use_global_palette = !v_use_local_palette;
    self->private_impl.f_seen_graphic_control = false;
    self->private_impl.f_gc_has_transparent_index = false;
    self->private_impl.f_gc_transparent_index = 0;
    self->private_impl.f_gc_disposal = 0;
    self->private_impl.f_gc_duration = 0;

    goto ok;
  ok:
    self->private_impl.c_decode_id_part1[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_id_part1[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode_id_part1[0].v_flags = v_flags;
  self->private_impl.c_decode_id_part1[0].v_use_local_palette =
      v_use_local_palette;
  self->private_impl.c_decode_id_part1[0].v_num_palette_entries =
      v_num_palette_entries;
  self->private_impl.c_decode_id_part1[0].v_i = v_i;
  self->private_impl.c_decode_id_part1[0].v_lw = v_lw;
  self->private_impl.c_decode_id_part1[0].v_block_size = v_block_size;
  self->private_impl.c_decode_id_part1[0].v_z = v_z;

  goto exit;
exit:
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_GIF__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_GIF__SUSPENSION_SHORT_READ;
  goto suspend;
}

// -------- func decoder.copy_to_image_buffer

static wuffs_gif__status wuffs_gif__decoder__copy_to_image_buffer(
    wuffs_gif__decoder* self,
    wuffs_base__image_buffer* a_ib) {
  wuffs_gif__status status = WUFFS_GIF__STATUS_OK;

  wuffs_base__slice_u8 v_dst;
  wuffs_base__slice_u8 v_src;
  uint32_t v_n;
  uint32_t v_new_ri;
  wuffs_base__table_u8 v_tab;

  v_dst = ((wuffs_base__slice_u8){});
  v_src = ((wuffs_base__slice_u8){});
  v_n = 0;
  v_new_ri = 0;
  v_tab = wuffs_base__image_buffer__plane(a_ib, 0);
label_0_continue:;
  while (self->private_impl.f_uncompressed_wi >
         self->private_impl.f_uncompressed_ri) {
    v_src = wuffs_base__slice_u8__subslice_ij(
        ((wuffs_base__slice_u8){.ptr = self->private_impl.f_uncompressed,
                                .len = 4096}),
        self->private_impl.f_uncompressed_ri,
        self->private_impl.f_uncompressed_wi);
    if (self->private_impl.f_dst_y >= self->private_impl.f_dst_y1) {
      status = WUFFS_GIF__ERROR_TOO_MUCH_PIXEL_DATA;
      goto exit;
    }
    if (self->private_impl.f_interlace) {
      status = WUFFS_GIF__ERROR_TODO_UNSUPPORTED_INTERLACING;
      goto exit;
    } else {
      v_dst = wuffs_base__table_u8__row(v_tab, self->private_impl.f_dst_y);
    }
    if (((uint64_t)(self->private_impl.f_dst_x)) < ((uint64_t)(v_dst.len))) {
      if ((((uint64_t)(self->private_impl.f_dst_x)) <=
           ((uint64_t)(self->private_impl.f_dst_x1))) &&
          (((uint64_t)(self->private_impl.f_dst_x1)) <=
           ((uint64_t)(v_dst.len)))) {
        v_dst = wuffs_base__slice_u8__subslice_ij(
            v_dst, ((uint64_t)(self->private_impl.f_dst_x)),
            ((uint64_t)(self->private_impl.f_dst_x1)));
      } else {
        v_dst = wuffs_base__slice_u8__subslice_i(
            v_dst, ((uint64_t)(self->private_impl.f_dst_x)));
      }
      v_n = ((uint32_t)(
          (wuffs_base__slice_u8__copy_from_slice(v_dst, v_src) & 4294967295)));
      v_new_ri =
          wuffs_base__u32__sat_add(self->private_impl.f_uncompressed_ri, v_n);
      self->private_impl.f_uncompressed_ri =
          wuffs_base__u32__min(v_new_ri, 4096);
      wuffs_base__u32__sat_add_indirect(&self->private_impl.f_dst_x, v_n);
    }
    if (self->private_impl.f_dst_x1 <= self->private_impl.f_dst_x) {
      self->private_impl.f_dst_x = self->private_impl.f_dst_x0;
      self->private_impl.f_dst_y += 1;
      goto label_0_continue;
    }
    if (self->private_impl.f_uncompressed_wi ==
        self->private_impl.f_uncompressed_ri) {
      goto label_0_break;
    } else if (self->private_impl.f_uncompressed_wi <
               self->private_impl.f_uncompressed_ri) {
      status = WUFFS_GIF__ERROR_INTERNAL_ERROR_INCONSISTENT_RI_WI;
      goto exit;
    }
    v_n = (self->private_impl.f_dst_x1 - self->private_impl.f_dst_x);
    v_n = wuffs_base__u32__min(v_n, (self->private_impl.f_uncompressed_wi -
                                     self->private_impl.f_uncompressed_ri));
    v_new_ri =
        wuffs_base__u32__sat_add(self->private_impl.f_uncompressed_ri, v_n);
    self->private_impl.f_uncompressed_ri = wuffs_base__u32__min(v_new_ri, 4096);
    wuffs_base__u32__sat_add_indirect(&self->private_impl.f_dst_x, v_n);
    if (self->private_impl.f_dst_x1 <= self->private_impl.f_dst_x) {
      self->private_impl.f_dst_x = self->private_impl.f_dst_x0;
      self->private_impl.f_dst_y += 1;
      goto label_0_continue;
    }
    if (self->private_impl.f_uncompressed_ri !=
        self->private_impl.f_uncompressed_wi) {
      status = WUFFS_GIF__ERROR_INTERNAL_ERROR_INCONSISTENT_RI_WI;
      goto exit;
    }
    goto label_0_break;
  }
label_0_break:;
  self->private_impl.f_uncompressed_ri = 0;
  self->private_impl.f_uncompressed_wi = 0;
  goto exit;
exit:
  return status;
}

// -------- func lzw_decoder.set_literal_width

static void wuffs_gif__lzw_decoder__set_literal_width(
    wuffs_gif__lzw_decoder* self,
    uint32_t a_lw) {
  self->private_impl.f_literal_width = a_lw;
}

// -------- func lzw_decoder.decode

static wuffs_gif__status wuffs_gif__lzw_decoder__decode(
    wuffs_gif__lzw_decoder* self,
    wuffs_base__io_writer a_dst,
    wuffs_base__io_reader a_src) {
  wuffs_gif__status status = WUFFS_GIF__STATUS_OK;

  uint32_t v_clear_code;
  uint32_t v_end_code;
  uint32_t v_save_code;
  uint32_t v_prev_code;
  uint32_t v_initial_width;
  uint32_t v_width;
  uint32_t v_bits;
  uint32_t v_n_bits;
  uint32_t v_code;
  uint32_t v_s;
  uint32_t v_c;
  wuffs_base__slice_u8 v_expansion;
  uint64_t v_n_copied;

  uint8_t* ioptr_dst = NULL;
  uint8_t* iobounds0orig_dst = NULL;
  uint8_t* iobounds1_dst = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_dst);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_dst);
  if (a_dst.private_impl.buf) {
    ioptr_dst = a_dst.private_impl.buf->ptr + a_dst.private_impl.buf->wi;
    if (!a_dst.private_impl.bounds[0]) {
      a_dst.private_impl.bounds[0] = ioptr_dst;
      a_dst.private_impl.bounds[1] =
          a_dst.private_impl.buf->ptr + a_dst.private_impl.buf->len;
    }
    if (a_dst.private_impl.buf->closed) {
      a_dst.private_impl.bounds[1] = ioptr_dst;
    }
    iobounds0orig_dst = a_dst.private_impl.bounds[0];
    iobounds1_dst = a_dst.private_impl.bounds[1];
  }
  uint8_t* ioptr_src = NULL;
  uint8_t* iobounds0orig_src = NULL;
  uint8_t* iobounds1_src = NULL;
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds0orig_src);
  WUFFS_BASE__IGNORE_POTENTIALLY_UNUSED_VARIABLE(iobounds1_src);
  if (a_src.private_impl.buf) {
    ioptr_src = a_src.private_impl.buf->ptr + a_src.private_impl.buf->ri;
    if (!a_src.private_impl.bounds[0]) {
      a_src.private_impl.bounds[0] = ioptr_src;
      a_src.private_impl.bounds[1] =
          a_src.private_impl.buf->ptr + a_src.private_impl.buf->wi;
    }
    iobounds0orig_src = a_src.private_impl.bounds[0];
    iobounds1_src = a_src.private_impl.bounds[1];
  }

  uint32_t coro_susp_point = self->private_impl.c_decode[0].coro_susp_point;
  if (coro_susp_point) {
    v_clear_code = self->private_impl.c_decode[0].v_clear_code;
    v_end_code = self->private_impl.c_decode[0].v_end_code;
    v_save_code = self->private_impl.c_decode[0].v_save_code;
    v_prev_code = self->private_impl.c_decode[0].v_prev_code;
    v_initial_width = self->private_impl.c_decode[0].v_initial_width;
    v_width = self->private_impl.c_decode[0].v_width;
    v_bits = self->private_impl.c_decode[0].v_bits;
    v_n_bits = self->private_impl.c_decode[0].v_n_bits;
    v_code = self->private_impl.c_decode[0].v_code;
    v_s = self->private_impl.c_decode[0].v_s;
    v_c = self->private_impl.c_decode[0].v_c;
    v_expansion = ((wuffs_base__slice_u8){});
    v_n_copied = self->private_impl.c_decode[0].v_n_copied;
  } else {
    v_expansion = ((wuffs_base__slice_u8){});
  }
  switch (coro_susp_point) {
    WUFFS_BASE__COROUTINE_SUSPENSION_POINT_0;

    v_clear_code = (((uint32_t)(1)) << self->private_impl.f_literal_width);
    v_end_code = (v_clear_code + 1);
    v_save_code = v_end_code;
    v_prev_code = 0;
    v_initial_width = (self->private_impl.f_literal_width + 1);
    v_width = v_initial_width;
    v_bits = 0;
    v_n_bits = 0;
  label_0_continue:;
    while (true) {
      while (v_n_bits < v_width) {
        {
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT(1);
          if (WUFFS_BASE__UNLIKELY(ioptr_src == iobounds1_src)) {
            goto short_read_src;
          }
          uint8_t t_0 = *ioptr_src++;
          v_bits |= (((uint32_t)(t_0)) << v_n_bits);
        }
        v_n_bits += 8;
      }
      v_code = ((v_bits) & ((1 << (v_width)) - 1));
      v_bits >>= v_width;
      v_n_bits -= v_width;
      if (v_code < v_clear_code) {
        WUFFS_BASE__COROUTINE_SUSPENSION_POINT(2);
        if (ioptr_dst == iobounds1_dst) {
          status = WUFFS_GIF__SUSPENSION_SHORT_WRITE;
          goto suspend;
        }
        *ioptr_dst++ = ((uint8_t)(v_code));
        if (v_save_code <= 4095) {
          self->private_impl.f_suffixes[v_save_code] = ((uint8_t)(v_code));
          self->private_impl.f_prefixes[v_save_code] =
              ((uint16_t)(v_prev_code));
        }
      } else if (v_code == v_clear_code) {
        v_save_code = v_end_code;
        v_prev_code = 0;
        v_width = v_initial_width;
        goto label_0_continue;
      } else if (v_code == v_end_code) {
        status = WUFFS_GIF__STATUS_OK;
        goto ok;
      } else if (v_code <= v_save_code) {
        v_s = 4095;
        v_c = v_code;
        if (v_code == v_save_code) {
          v_s -= 1;
          v_c = v_prev_code;
        }
        while (v_c >= v_clear_code) {
          self->private_impl.f_stack[v_s] = self->private_impl.f_suffixes[v_c];
          if (v_s == 0) {
            status = WUFFS_GIF__ERROR_LZW_PREFIX_CHAIN_IS_CYCLICAL;
            goto exit;
          }
          v_s -= 1;
          v_c = ((uint32_t)(self->private_impl.f_prefixes[v_c]));
        }
        self->private_impl.f_stack[v_s] = ((uint8_t)(v_c));
        if (v_code == v_save_code) {
          self->private_impl.f_stack[4095] = ((uint8_t)(v_c));
        }
        while (true) {
          v_expansion = wuffs_base__slice_u8__subslice_i(
              ((wuffs_base__slice_u8){.ptr = self->private_impl.f_stack,
                                      .len = 4096}),
              v_s);
          v_n_copied = wuffs_base__io_writer__copy_from_slice(
              &ioptr_dst, iobounds1_dst, v_expansion);
          if (v_n_copied == ((uint64_t)(v_expansion.len))) {
            goto label_1_break;
          }
          v_s = ((v_s + ((uint32_t)((v_n_copied & 4095)))) & 4095);
          status = WUFFS_GIF__SUSPENSION_SHORT_WRITE;
          WUFFS_BASE__COROUTINE_SUSPENSION_POINT_MAYBE_SUSPEND(3);
        }
      label_1_break:;
        if (v_save_code <= 4095) {
          self->private_impl.f_suffixes[v_save_code] = ((uint8_t)(v_c));
          self->private_impl.f_prefixes[v_save_code] =
              ((uint16_t)(v_prev_code));
        }
      } else {
        status = WUFFS_GIF__ERROR_LZW_CODE_IS_OUT_OF_RANGE;
        goto exit;
      }
      if (v_save_code <= 4095) {
        v_save_code += 1;
        if ((v_save_code == (((uint32_t)(1)) << v_width)) && (v_width < 12)) {
          v_width += 1;
        }
      }
      v_prev_code = v_code;
    }

    goto ok;
  ok:
    self->private_impl.c_decode[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode[0].v_clear_code = v_clear_code;
  self->private_impl.c_decode[0].v_end_code = v_end_code;
  self->private_impl.c_decode[0].v_save_code = v_save_code;
  self->private_impl.c_decode[0].v_prev_code = v_prev_code;
  self->private_impl.c_decode[0].v_initial_width = v_initial_width;
  self->private_impl.c_decode[0].v_width = v_width;
  self->private_impl.c_decode[0].v_bits = v_bits;
  self->private_impl.c_decode[0].v_n_bits = v_n_bits;
  self->private_impl.c_decode[0].v_code = v_code;
  self->private_impl.c_decode[0].v_s = v_s;
  self->private_impl.c_decode[0].v_c = v_c;
  self->private_impl.c_decode[0].v_n_copied = v_n_copied;

  goto exit;
exit:
  if (a_dst.private_impl.buf) {
    a_dst.private_impl.buf->wi = ioptr_dst - a_dst.private_impl.buf->ptr;
  }
  if (a_src.private_impl.buf) {
    a_src.private_impl.buf->ri = ioptr_src - a_src.private_impl.buf->ptr;
  }

  return status;

short_read_src:
  if (wuffs_base__io_reader__is_eof(a_src)) {
    status = WUFFS_GIF__ERROR_UNEXPECTED_EOF;
    goto exit;
  }
  status = WUFFS_GIF__SUSPENSION_SHORT_READ;
  goto suspend;
}
