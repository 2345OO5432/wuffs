#ifndef PUFFS_FLATE_H
#define PUFFS_FLATE_H

// Code generated by puffs-c. DO NOT EDIT.

#ifndef PUFFS_BASE_HEADER_H
#define PUFFS_BASE_HEADER_H

// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file.

#include <stdbool.h>
#include <stdint.h>
#include <string.h>

// Puffs requires a word size of at least 32 bits because it assumes that
// converting a u32 to usize will never overflow. For example, the size of a
// decoded image is often represented, explicitly or implicitly in an image
// file, as a u32, and it is convenient to compare that to a buffer size.
//
// Similarly, the word size is at most 64 bits because it assumes that
// converting a usize to u64 will never overflow.
#if __WORDSIZE < 32
#error "Puffs requires a word size of at least 32 bits"
#elif __WORDSIZE > 64
#error "Puffs requires a word size of at most 64 bits"
#endif

// PUFFS_VERSION is the major.minor version number as a uint32. The major
// number is the high 16 bits. The minor number is the low 16 bits.
//
// The intention is to bump the version number at least on every API / ABI
// backwards incompatible change.
//
// For now, the API and ABI are simply unstable and can change at any time.
//
// TODO: don't hard code this in base-header.h.
#define PUFFS_VERSION (0x00001)

// puffs_base_slice_u8 is a 1-dimensional buffer (a pointer and length).
//
// A value with all fields NULL or zero is a valid, empty slice.
typedef struct {
  uint8_t* ptr;
  size_t len;
} puffs_base_slice_u8;

// puffs_base_buf1 is a 1-dimensional buffer (a pointer and length), plus
// additional indexes into that buffer, plus an opened / closed flag.
//
// A value with all fields NULL or zero is a valid, empty buffer.
typedef struct {
  uint8_t* ptr;  // Pointer.
  size_t len;    // Length.
  size_t wi;     // Write index. Invariant: wi <= len.
  size_t ri;     // Read  index. Invariant: ri <= wi.
  bool closed;   // No further writes are expected.
} puffs_base_buf1;

// puffs_base_limit1 provides a limited view of a 1-dimensional byte stream:
// its first N bytes. That N can be greater than a buffer's current read or
// write capacity. N decreases naturally over time as bytes are read from or
// written to the stream.
//
// A value with all fields NULL or zero is a valid, unlimited view.
typedef struct puffs_base_limit1 {
  uint64_t* ptr_to_len;            // Pointer to N.
  struct puffs_base_limit1* next;  // Linked list of limits.
} puffs_base_limit1;

typedef struct {
  puffs_base_buf1* buf;
  puffs_base_limit1 limit;
} puffs_base_reader1;

typedef struct {
  puffs_base_buf1* buf;
  puffs_base_limit1 limit;
} puffs_base_writer1;

#endif  // PUFFS_BASE_HEADER_H

#ifdef __cplusplus
extern "C" {
#endif

// ---------------- Status Codes

// Status codes are int32_t values:
//  - the sign bit indicates a non-recoverable status code: an error
//  - bits 10-30 hold the packageid: a namespace
//  - bits 8-9 are reserved
//  - bits 0-7 are a package-namespaced numeric code
//
// Do not manipulate these bits directly. Use the API functions such as
// puffs_flate_status_is_error instead.
typedef int32_t puffs_flate_status;

#define puffs_flate_packageid 967230  // 0x000ec23e

#define PUFFS_FLATE_STATUS_OK 0                               // 0x00000000
#define PUFFS_FLATE_ERROR_BAD_PUFFS_VERSION -2147483647       // 0x80000001
#define PUFFS_FLATE_ERROR_BAD_RECEIVER -2147483646            // 0x80000002
#define PUFFS_FLATE_ERROR_BAD_ARGUMENT -2147483645            // 0x80000003
#define PUFFS_FLATE_ERROR_INITIALIZER_NOT_CALLED -2147483644  // 0x80000004
#define PUFFS_FLATE_ERROR_CLOSED_FOR_WRITES -2147483643       // 0x80000005
#define PUFFS_FLATE_ERROR_UNEXPECTED_EOF -2147483642          // 0x80000006
#define PUFFS_FLATE_SUSPENSION_SHORT_READ 7                   // 0x00000007
#define PUFFS_FLATE_SUSPENSION_SHORT_WRITE 8                  // 0x00000008
#define PUFFS_FLATE_SUSPENSION_LIMITED_READ 9                 // 0x00000009
#define PUFFS_FLATE_SUSPENSION_LIMITED_WRITE 10               // 0x0000000a

#define PUFFS_FLATE_ERROR_BAD_HUFFMAN_CODE_OVER_SUBSCRIBED \
  -1157040128  // 0xbb08f800
#define PUFFS_FLATE_ERROR_BAD_HUFFMAN_CODE_UNDER_SUBSCRIBED \
  -1157040127  // 0xbb08f801
#define PUFFS_FLATE_ERROR_BAD_HUFFMAN_CODE_LENGTH_COUNT \
  -1157040126  // 0xbb08f802
#define PUFFS_FLATE_ERROR_BAD_HUFFMAN_CODE_LENGTH_REPETITION \
  -1157040125                                           // 0xbb08f803
#define PUFFS_FLATE_ERROR_BAD_HUFFMAN_CODE -1157040124  // 0xbb08f804
#define PUFFS_FLATE_ERROR_BAD_HUFFMAN_MINIMUM_CODE_LENGTH \
  -1157040123                                                  // 0xbb08f805
#define PUFFS_FLATE_ERROR_BAD_DISTANCE_CODE_COUNT -1157040122  // 0xbb08f806
#define PUFFS_FLATE_ERROR_BAD_FLATE_BLOCK -1157040121          // 0xbb08f807
#define PUFFS_FLATE_ERROR_BAD_LITERAL_LENGTH_CODE_COUNT \
  -1157040120  // 0xbb08f808
#define PUFFS_FLATE_ERROR_INCONSISTENT_STORED_BLOCK_LENGTH \
  -1157040119  // 0xbb08f809
#define PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE \
  -1157040118  // 0xbb08f80a
#define PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_N_BITS \
  -1157040117                                                    // 0xbb08f80b
#define PUFFS_FLATE_ERROR_MISSING_END_OF_BLOCK_CODE -1157040116  // 0xbb08f80c
#define PUFFS_FLATE_ERROR_NO_HUFFMAN_CODES -1157040115           // 0xbb08f80d
#define PUFFS_FLATE_ERROR_INVALID_ZLIB_COMPRESSION_METHOD \
  -1157040114  // 0xbb08f80e
#define PUFFS_FLATE_ERROR_INVALID_ZLIB_COMPRESSION_WINDOW_SIZE \
  -1157040113                                                    // 0xbb08f80f
#define PUFFS_FLATE_ERROR_INVALID_ZLIB_PARITY_CHECK -1157040112  // 0xbb08f810
#define PUFFS_FLATE_ERROR_TODO_UNSUPPORTED_ZLIB_PRESET_DICTIONARY \
  -1157040111  // 0xbb08f811

bool puffs_flate_status_is_error(puffs_flate_status s);

const char* puffs_flate_status_string(puffs_flate_status s);

// ---------------- Public Consts

// ---------------- Structs

typedef struct {
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so. Instead, use the
  // puffs_flate_decoder_etc functions.
  //
  // In C++, these fields would be "private", but C does not support that.
  //
  // It is a struct, not a struct*, so that it can be stack allocated.
  struct {
    puffs_flate_status status;
    uint32_t magic;

    uint32_t f_bits;
    uint32_t f_n_bits;
    uint32_t f_huffs[2][1234];
    uint32_t f_n_huffs_bits[2];
    uint8_t f_history[32768];
    uint32_t f_history_index;
    uint8_t f_code_lengths[320];

    struct {
      uint32_t coro_susp_point;
      puffs_flate_status v_z;
      uint64_t v_n;
      uint32_t v_already_full;
    } c_decode[1];
    struct {
      uint32_t coro_susp_point;
      uint32_t v_final;
      uint32_t v_type;
    } c_decode_blocks[1];
    struct {
      uint32_t coro_susp_point;
      uint32_t v_n;
      uint64_t scratch;
    } c_decode_uncompressed[1];
    struct {
      uint32_t coro_susp_point;
      uint32_t v_bits;
      uint32_t v_n_bits;
      uint32_t v_table_entry;
      uint32_t v_table_entry_n_bits;
      uint32_t v_lmask;
      uint32_t v_dmask;
      uint32_t v_redir_top;
      uint32_t v_redir_mask;
      uint32_t v_length;
      uint32_t v_distance;
      uint64_t scratch;
    } c_decode_huffman[1];
    struct {
      uint32_t coro_susp_point;
      uint32_t v_i;
    } c_init_fixed_huffman[1];
    struct {
      uint32_t coro_susp_point;
      uint32_t v_bits;
      uint32_t v_n_bits;
      uint32_t v_n_lit;
      uint32_t v_n_dist;
      uint32_t v_n_clen;
      uint32_t v_i;
      uint32_t v_mask;
      uint32_t v_table_entry;
      uint32_t v_table_entry_n_bits;
      uint32_t v_n_extra_bits;
      uint8_t v_rep_symbol;
      uint32_t v_rep_count;
    } c_init_dynamic_huffman[1];
  } private_impl;
} puffs_flate_decoder;

typedef struct {
  // Do not access the private_impl's fields directly. There is no API/ABI
  // compatibility or safety guarantee if you do so. Instead, use the
  // puffs_flate_zlib_decoder_etc functions.
  //
  // In C++, these fields would be "private", but C does not support that.
  //
  // It is a struct, not a struct*, so that it can be stack allocated.
  struct {
    puffs_flate_status status;
    uint32_t magic;

    puffs_flate_decoder f_dec;

    struct {
      uint32_t coro_susp_point;
      uint16_t v_x;
      uint32_t v_checksum;
      uint64_t scratch;
    } c_decode[1];
  } private_impl;
} puffs_flate_zlib_decoder;

// ---------------- Public Initializer Prototypes

// puffs_flate_decoder_initialize is an initializer function.
//
// It should be called before any other puffs_flate_decoder_* function.
//
// Pass PUFFS_VERSION and 0 for puffs_version and for_internal_use_only.
void puffs_flate_decoder_initialize(puffs_flate_decoder* self,
                                    uint32_t puffs_version,
                                    uint32_t for_internal_use_only);

// puffs_flate_zlib_decoder_initialize is an initializer function.
//
// It should be called before any other puffs_flate_zlib_decoder_* function.
//
// Pass PUFFS_VERSION and 0 for puffs_version and for_internal_use_only.
void puffs_flate_zlib_decoder_initialize(puffs_flate_zlib_decoder* self,
                                         uint32_t puffs_version,
                                         uint32_t for_internal_use_only);

// ---------------- Public Function Prototypes

puffs_flate_status puffs_flate_decoder_decode(puffs_flate_decoder* self,
                                              puffs_base_writer1 a_dst,
                                              puffs_base_reader1 a_src);

puffs_flate_status puffs_flate_zlib_decoder_decode(
    puffs_flate_zlib_decoder* self,
    puffs_base_writer1 a_dst,
    puffs_base_reader1 a_src);

#ifdef __cplusplus
}  // extern "C"
#endif

#endif  // PUFFS_FLATE_H

// C HEADER ENDS HERE.

#ifndef PUFFS_BASE_IMPL_H
#define PUFFS_BASE_IMPL_H

// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file.

#define PUFFS_IGNORE_POTENTIALLY_UNUSED_VARIABLE(x) (void)(x)

// Use switch cases for coroutine suspension points, similar to the technique
// in https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html
//
// We use a trivial macro instead of an explicit assignment and case statement
// so that clang-format doesn't get confused by the unusual "case"s.
#define PUFFS_COROUTINE_SUSPENSION_POINT(n) \
  coro_susp_point = n;                      \
  case n:

// Clang also defines "__GNUC__".
#if defined(__GNUC__)
#define PUFFS_LIKELY(expr) (__builtin_expect(!!(expr), 1))
#define PUFFS_UNLIKELY(expr) (__builtin_expect(!!(expr), 0))
// Declare the printf prototype. The generated code shouldn't need this at all,
// but it's useful for manual printf debugging.
extern int printf(const char* __restrict __format, ...);
#else
#define PUFFS_LIKELY(expr) (expr)
#define PUFFS_UNLIKELY(expr) (expr)
#endif

// ---------------- Static Inline Functions
//
// The helpers below are functions, instead of macros, because their arguments
// can be an expression that we shouldn't evaluate more than once.
//
// They are in base-impl.h and hence copy/pasted into every generated C file,
// instead of being in some "base.c" file, since a design goal is that users of
// the generated C code can often just #include a single .c file, such as
// "gif.c", without having to additionally include or otherwise build and link
// a "base.c" file.
//
// They are static, so that linking multiple puffs .o files won't complain about
// duplicate function definitions.
//
// They are explicitly marked inline, even if modern compilers don't use the
// inline attribute to guide optimizations such as inlining, to avoid the
// -Wunused-function warning, and we like to compile with -Wall -Werror.

static inline uint16_t puffs_base_load_u16be(uint8_t* p) {
  return ((uint16_t)(p[0]) << 8) | ((uint16_t)(p[1]) << 0);
}

static inline uint16_t puffs_base_load_u16le(uint8_t* p) {
  return ((uint16_t)(p[0]) << 0) | ((uint16_t)(p[1]) << 8);
}

static inline uint32_t puffs_base_load_u32be(uint8_t* p) {
  return ((uint32_t)(p[0]) << 24) | ((uint32_t)(p[1]) << 16) |
         ((uint32_t)(p[2]) << 8) | ((uint32_t)(p[3]) << 0);
}

static inline uint32_t puffs_base_load_u32le(uint8_t* p) {
  return ((uint32_t)(p[0]) << 0) | ((uint32_t)(p[1]) << 8) |
         ((uint32_t)(p[2]) << 16) | ((uint32_t)(p[3]) << 24);
}

static inline puffs_base_slice_u8 puffs_base_slice_u8_subslice_i(
    puffs_base_slice_u8 s,
    uint64_t i) {
  if ((i <= SIZE_MAX) && (i <= s.len)) {
    return ((puffs_base_slice_u8){
        .ptr = s.ptr + i,
        .len = s.len - i,
    });
  }
  return ((puffs_base_slice_u8){});
}

static inline puffs_base_slice_u8 puffs_base_slice_u8_subslice_j(
    puffs_base_slice_u8 s,
    uint64_t j) {
  if ((j <= SIZE_MAX) && (j <= s.len)) {
    return ((puffs_base_slice_u8){.ptr = s.ptr, .len = j});
  }
  return ((puffs_base_slice_u8){});
}

static inline puffs_base_slice_u8
puffs_base_slice_u8_subslice_ij(puffs_base_slice_u8 s, uint64_t i, uint64_t j) {
  if ((i <= j) && (j <= SIZE_MAX) && (j <= s.len)) {
    return ((puffs_base_slice_u8){
        .ptr = s.ptr + i,
        .len = j - i,
    });
  }
  return ((puffs_base_slice_u8){});
}

// puffs_base_slice_u8_prefix returns up to the first n bytes of s.
static inline puffs_base_slice_u8 puffs_base_slice_u8_prefix(
    puffs_base_slice_u8 s,
    uint64_t n) {
  if ((uint64_t)(s.len) > n) {
    s.len = n;
  }
  return s;
}

// puffs_base_slice_u8_suffix returns up to the last n bytes of s.
static inline puffs_base_slice_u8 puffs_base_slice_u8_suffix(
    puffs_base_slice_u8 s,
    uint64_t n) {
  if ((uint64_t)(s.len) > n) {
    s.ptr += (uint64_t)(s.len) - n;
    s.len = n;
  }
  return s;
}

// puffs_base_slice_u8_copy_from calls memmove(dst.ptr, src.ptr, n) where n is
// the minimum of dst.len and src.len.
//
// Passing a puffs_base_slice_u8 with all fields NULL or zero (a valid, empty
// slice) is valid and results in a no-op.
static inline uint64_t puffs_base_slice_u8_copy_from(puffs_base_slice_u8 dst,
                                                     puffs_base_slice_u8 src) {
  size_t n = dst.len < src.len ? dst.len : src.len;
  if (n > 0) {
    memmove(dst.ptr, src.ptr, n);
  }
  return n;
}

#endif  // PUFFS_BASE_IMPL_H

// ---------------- Status Codes Implementations

bool puffs_flate_status_is_error(puffs_flate_status s) {
  return s < 0;
}

const char* puffs_flate_status_strings0[11] = {
    "flate: ok",
    "flate: bad puffs version",
    "flate: bad receiver",
    "flate: bad argument",
    "flate: initializer not called",
    "flate: closed for writes",
    "flate: unexpected EOF",
    "flate: short read",
    "flate: short write",
    "flate: limited read",
    "flate: limited write",
};

const char* puffs_flate_status_strings1[18] = {
    "flate: bad Huffman code (over-subscribed)",
    "flate: bad Huffman code (under-subscribed)",
    "flate: bad Huffman code length count",
    "flate: bad Huffman code length repetition",
    "flate: bad Huffman code",
    "flate: bad Huffman minimum code length",
    "flate: bad distance code count",
    "flate: bad flate block",
    "flate: bad literal/length code count",
    "flate: inconsistent stored block length",
    "flate: internal error: inconsistent Huffman decoder state",
    "flate: internal error: inconsistent n_bits",
    "flate: missing end-of-block code",
    "flate: no Huffman codes",
    "flate: invalid zlib compression method",
    "flate: invalid zlib compression window size",
    "flate: invalid zlib parity check",
    "flate: TODO: unsupported zlib preset dictionary",
};

const char* puffs_flate_status_string(puffs_flate_status s) {
  const char** a = NULL;
  uint32_t n = 0;
  switch ((s >> 10) & 0x1fffff) {
    case 0:
      a = puffs_flate_status_strings0;
      n = 11;
      break;
    case puffs_flate_packageid:
      a = puffs_flate_status_strings1;
      n = 18;
      break;
  }
  uint32_t i = s & 0xff;
  return i < n ? a[i] : "flate: unknown status";
}

// ---------------- Private Consts

static const uint8_t puffs_flate_code_order[19] = {
    16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
};

static const uint8_t puffs_flate_reverse8[256] = {
    0,  128, 64, 192, 32, 160, 96,  224, 16, 144, 80, 208, 48, 176, 112, 240,
    8,  136, 72, 200, 40, 168, 104, 232, 24, 152, 88, 216, 56, 184, 120, 248,
    4,  132, 68, 196, 36, 164, 100, 228, 20, 148, 84, 212, 52, 180, 116, 244,
    12, 140, 76, 204, 44, 172, 108, 236, 28, 156, 92, 220, 60, 188, 124, 252,
    2,  130, 66, 194, 34, 162, 98,  226, 18, 146, 82, 210, 50, 178, 114, 242,
    10, 138, 74, 202, 42, 170, 106, 234, 26, 154, 90, 218, 58, 186, 122, 250,
    6,  134, 70, 198, 38, 166, 102, 230, 22, 150, 86, 214, 54, 182, 118, 246,
    14, 142, 78, 206, 46, 174, 110, 238, 30, 158, 94, 222, 62, 190, 126, 254,
    1,  129, 65, 193, 33, 161, 97,  225, 17, 145, 81, 209, 49, 177, 113, 241,
    9,  137, 73, 201, 41, 169, 105, 233, 25, 153, 89, 217, 57, 185, 121, 249,
    5,  133, 69, 197, 37, 165, 101, 229, 21, 149, 85, 213, 53, 181, 117, 245,
    13, 141, 77, 205, 45, 173, 109, 237, 29, 157, 93, 221, 61, 189, 125, 253,
    3,  131, 67, 195, 35, 163, 99,  227, 19, 147, 83, 211, 51, 179, 115, 243,
    11, 139, 75, 203, 43, 171, 107, 235, 27, 155, 91, 219, 59, 187, 123, 251,
    7,  135, 71, 199, 39, 167, 103, 231, 23, 151, 87, 215, 55, 183, 119, 247,
    15, 143, 79, 207, 47, 175, 111, 239, 31, 159, 95, 223, 63, 191, 127, 255,
};

static const uint32_t puffs_flate_lcode_magic_numbers[32] = {
    1073742592, 1073742848, 1073743104, 1073743360, 1073743616, 1073743872,
    1073744128, 1073744384, 1073744656, 1073745168, 1073745680, 1073746192,
    1073746720, 1073747744, 1073748768, 1073749792, 1073750832, 1073752880,
    1073754928, 1073756976, 1073759040, 1073763136, 1073767232, 1073771328,
    1073775440, 1073783632, 1073791824, 1073800016, 1073807872, 134217728,
    134217728,  134217728,
};

static const uint32_t puffs_flate_dcode_magic_numbers[32] = {
    1073742080, 1073742336, 1073742592, 1073742848, 1073743120, 1073743632,
    1073744160, 1073745184, 1073746224, 1073748272, 1073750336, 1073754432,
    1073758544, 1073766736, 1073774944, 1073791328, 1073807728, 1073840496,
    1073873280, 1073938816, 1074004368, 1074135440, 1074266528, 1074528672,
    1074790832, 1075315120, 1075839424, 1076888000, 1077936592, 1080033744,
    134217728,  134217728,
};

// ---------------- Private Initializer Prototypes

// ---------------- Private Function Prototypes

puffs_flate_status puffs_flate_decoder_decode_blocks(puffs_flate_decoder* self,
                                                     puffs_base_writer1 a_dst,
                                                     puffs_base_reader1 a_src);

puffs_flate_status puffs_flate_decoder_decode_uncompressed(
    puffs_flate_decoder* self,
    puffs_base_writer1 a_dst,
    puffs_base_reader1 a_src);

puffs_flate_status puffs_flate_decoder_decode_huffman(puffs_flate_decoder* self,
                                                      puffs_base_writer1 a_dst,
                                                      puffs_base_reader1 a_src);

puffs_flate_status puffs_flate_decoder_init_fixed_huffman(
    puffs_flate_decoder* self);

puffs_flate_status puffs_flate_decoder_init_dynamic_huffman(
    puffs_flate_decoder* self,
    puffs_base_reader1 a_src);

puffs_flate_status puffs_flate_decoder_init_huff(puffs_flate_decoder* self,
                                                 uint32_t a_which,
                                                 uint32_t a_n_codes0,
                                                 uint32_t a_n_codes1,
                                                 uint32_t a_base_symbol);

// ---------------- Initializer Implementations

// PUFFS_MAGIC is a magic number to check that initializers are called. It's
// not foolproof, given C doesn't automatically zero memory before use, but it
// should catch 99.99% of cases.
//
// Its (non-zero) value is arbitrary, based on md5sum("puffs").
#define PUFFS_MAGIC (0xCB3699CCU)

// PUFFS_ALREADY_ZEROED is passed from a container struct's initializer to a
// containee struct's initializer when the container has already zeroed the
// containee's memory.
//
// Its (non-zero) value is arbitrary, based on md5sum("zeroed").
#define PUFFS_ALREADY_ZEROED (0x68602EF1U)

void puffs_flate_decoder_initialize(puffs_flate_decoder* self,
                                    uint32_t puffs_version,
                                    uint32_t for_internal_use_only) {
  if (!self) {
    return;
  }
  if (puffs_version != PUFFS_VERSION) {
    self->private_impl.status = PUFFS_FLATE_ERROR_BAD_PUFFS_VERSION;
    return;
  }
  if (for_internal_use_only != PUFFS_ALREADY_ZEROED) {
    memset(self, 0, sizeof(*self));
  }
  self->private_impl.magic = PUFFS_MAGIC;
}

void puffs_flate_zlib_decoder_initialize(puffs_flate_zlib_decoder* self,
                                         uint32_t puffs_version,
                                         uint32_t for_internal_use_only) {
  if (!self) {
    return;
  }
  if (puffs_version != PUFFS_VERSION) {
    self->private_impl.status = PUFFS_FLATE_ERROR_BAD_PUFFS_VERSION;
    return;
  }
  if (for_internal_use_only != PUFFS_ALREADY_ZEROED) {
    memset(self, 0, sizeof(*self));
  }
  self->private_impl.magic = PUFFS_MAGIC;
  puffs_flate_decoder_initialize(&self->private_impl.f_dec, PUFFS_VERSION,
                                 PUFFS_ALREADY_ZEROED);
}

// ---------------- Function Implementations

puffs_flate_status puffs_flate_decoder_decode(puffs_flate_decoder* self,
                                              puffs_base_writer1 a_dst,
                                              puffs_base_reader1 a_src) {
  if (!self) {
    return PUFFS_FLATE_ERROR_BAD_RECEIVER;
  }
  if (self->private_impl.magic != PUFFS_MAGIC) {
    self->private_impl.status = PUFFS_FLATE_ERROR_INITIALIZER_NOT_CALLED;
  }
  if (self->private_impl.status < 0) {
    return self->private_impl.status;
  }
  puffs_flate_status status = PUFFS_FLATE_STATUS_OK;

  puffs_flate_status v_z;
  puffs_base_slice_u8 v_written;
  uint64_t v_n;
  uint32_t v_already_full;

  uint8_t* b_wptr_dst = NULL;
  uint8_t* b_wstart_dst = NULL;
  uint8_t* b_wend_dst = NULL;
  if (a_dst.buf) {
    b_wptr_dst = a_dst.buf->ptr + a_dst.buf->wi;
    b_wstart_dst = b_wptr_dst;
    size_t len = a_dst.buf->len - a_dst.buf->wi;
    puffs_base_limit1* lim;
    for (lim = &a_dst.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len && (len > *lim->ptr_to_len)) {
        len = *lim->ptr_to_len;
      }
    }
    b_wend_dst = b_wptr_dst + len;
  }

  uint32_t coro_susp_point = self->private_impl.c_decode[0].coro_susp_point;
  if (coro_susp_point) {
    v_z = self->private_impl.c_decode[0].v_z;
    v_written = ((puffs_base_slice_u8){});
    v_n = self->private_impl.c_decode[0].v_n;
    v_already_full = self->private_impl.c_decode[0].v_already_full;
  }
  switch (coro_susp_point) {
    PUFFS_COROUTINE_SUSPENSION_POINT(0);

    PUFFS_COROUTINE_SUSPENSION_POINT(1);
    if (a_dst.buf) {
      size_t n = b_wptr_dst - (a_dst.buf->ptr + a_dst.buf->wi);
      a_dst.buf->wi += n;
      puffs_base_limit1* lim;
      for (lim = &a_dst.limit; lim; lim = lim->next) {
        if (lim->ptr_to_len) {
          *lim->ptr_to_len -= n;
        }
      }
    }
    puffs_flate_status t_0 =
        puffs_flate_decoder_decode_blocks(self, a_dst, a_src);
    if (a_dst.buf) {
      b_wptr_dst = a_dst.buf->ptr + a_dst.buf->wi;
      size_t len = a_dst.buf->len - a_dst.buf->wi;
      puffs_base_limit1* lim;
      for (lim = &a_dst.limit; lim; lim = lim->next) {
        if (lim->ptr_to_len && (len > *lim->ptr_to_len)) {
          len = *lim->ptr_to_len;
        }
      }
      b_wend_dst = b_wptr_dst + len;
    }
    v_z = t_0;
    if (v_z > 0) {
      v_written = ((puffs_base_slice_u8){
          .ptr = b_wstart_dst,
          .len = b_wptr_dst - b_wstart_dst,
      });
      if (((uint64_t)(v_written.len)) >= 32768) {
        v_written = puffs_base_slice_u8_suffix(v_written, 32768);
        puffs_base_slice_u8_copy_from(
            ((puffs_base_slice_u8){.ptr = self->private_impl.f_history,
                                   .len = 32768}),
            v_written);
        self->private_impl.f_history_index = 32768;
      } else {
        v_n = puffs_base_slice_u8_copy_from(
            puffs_base_slice_u8_subslice_i(
                ((puffs_base_slice_u8){.ptr = self->private_impl.f_history,
                                       .len = 32768}),
                self->private_impl.f_history_index & 32767),
            v_written);
        if (v_n < ((uint64_t)(v_written.len))) {
          v_written = puffs_base_slice_u8_subslice_i(v_written, v_n);
          v_n = puffs_base_slice_u8_copy_from(
              ((puffs_base_slice_u8){.ptr = self->private_impl.f_history,
                                     .len = 32768}),
              v_written);
          self->private_impl.f_history_index =
              (((uint32_t)((v_n & 32767))) + 32768);
        } else {
          v_already_full = 0;
          if (self->private_impl.f_history_index >= 32768) {
            v_already_full = 32768;
          }
          self->private_impl.f_history_index =
              ((self->private_impl.f_history_index & 32767) +
               ((uint32_t)((v_n & 32767))) + v_already_full);
        }
      }
    }
    status = v_z;
    goto suspend;
    self->private_impl.c_decode[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode[0].v_z = v_z;
  self->private_impl.c_decode[0].v_n = v_n;
  self->private_impl.c_decode[0].v_already_full = v_already_full;

exit:
  if (a_dst.buf) {
    size_t n = b_wptr_dst - (a_dst.buf->ptr + a_dst.buf->wi);
    a_dst.buf->wi += n;
    puffs_base_limit1* lim;
    for (lim = &a_dst.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len) {
        *lim->ptr_to_len -= n;
      }
    }
    PUFFS_IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_wstart_dst);
    PUFFS_IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_wend_dst);
  }

  self->private_impl.status = status;
  return status;
}

puffs_flate_status puffs_flate_decoder_decode_blocks(puffs_flate_decoder* self,
                                                     puffs_base_writer1 a_dst,
                                                     puffs_base_reader1 a_src) {
  puffs_flate_status status = PUFFS_FLATE_STATUS_OK;

  uint32_t v_final;
  uint32_t v_type;

  uint8_t* b_rptr_src = NULL;
  uint8_t* b_rstart_src = NULL;
  uint8_t* b_rend_src = NULL;
  if (a_src.buf) {
    b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
    b_rstart_src = b_rptr_src;
    size_t len = a_src.buf->wi - a_src.buf->ri;
    puffs_base_limit1* lim;
    for (lim = &a_src.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len && (len > *lim->ptr_to_len)) {
        len = *lim->ptr_to_len;
      }
    }
    b_rend_src = b_rptr_src + len;
  }

  uint32_t coro_susp_point =
      self->private_impl.c_decode_blocks[0].coro_susp_point;
  if (coro_susp_point) {
    v_final = self->private_impl.c_decode_blocks[0].v_final;
    v_type = self->private_impl.c_decode_blocks[0].v_type;
  }
  switch (coro_susp_point) {
    PUFFS_COROUTINE_SUSPENSION_POINT(0);

    v_final = 0;
  label_0_continue:;
    while (v_final == 0) {
      while (self->private_impl.f_n_bits < 3) {
        PUFFS_COROUTINE_SUSPENSION_POINT(1);
        if (PUFFS_UNLIKELY(b_rptr_src == b_rend_src)) {
          goto short_read_src;
        }
        uint8_t t_0 = *b_rptr_src++;
        self->private_impl.f_bits |=
            (((uint32_t)(t_0)) << self->private_impl.f_n_bits);
        self->private_impl.f_n_bits += 8;
      }
      v_final = (self->private_impl.f_bits & 1);
      v_type = ((self->private_impl.f_bits >> 1) & 3);
      self->private_impl.f_bits >>= 3;
      self->private_impl.f_n_bits -= 3;
      if (v_type == 0) {
        PUFFS_COROUTINE_SUSPENSION_POINT(2);
        if (a_src.buf) {
          size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
          a_src.buf->ri += n;
          puffs_base_limit1* lim;
          for (lim = &a_src.limit; lim; lim = lim->next) {
            if (lim->ptr_to_len) {
              *lim->ptr_to_len -= n;
            }
          }
        }
        status = puffs_flate_decoder_decode_uncompressed(self, a_dst, a_src);
        if (a_src.buf) {
          b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
          size_t len = a_src.buf->wi - a_src.buf->ri;
          puffs_base_limit1* lim;
          for (lim = &a_src.limit; lim; lim = lim->next) {
            if (lim->ptr_to_len && (len > *lim->ptr_to_len)) {
              len = *lim->ptr_to_len;
            }
          }
          b_rend_src = b_rptr_src + len;
        }
        if (status) {
          goto suspend;
        }
        goto label_0_continue;
      } else if (v_type == 1) {
        PUFFS_COROUTINE_SUSPENSION_POINT(3);
        status = puffs_flate_decoder_init_fixed_huffman(self);
        if (status) {
          goto suspend;
        }
      } else if (v_type == 2) {
        PUFFS_COROUTINE_SUSPENSION_POINT(4);
        if (a_src.buf) {
          size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
          a_src.buf->ri += n;
          puffs_base_limit1* lim;
          for (lim = &a_src.limit; lim; lim = lim->next) {
            if (lim->ptr_to_len) {
              *lim->ptr_to_len -= n;
            }
          }
        }
        status = puffs_flate_decoder_init_dynamic_huffman(self, a_src);
        if (a_src.buf) {
          b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
          size_t len = a_src.buf->wi - a_src.buf->ri;
          puffs_base_limit1* lim;
          for (lim = &a_src.limit; lim; lim = lim->next) {
            if (lim->ptr_to_len && (len > *lim->ptr_to_len)) {
              len = *lim->ptr_to_len;
            }
          }
          b_rend_src = b_rptr_src + len;
        }
        if (status) {
          goto suspend;
        }
      } else {
        status = PUFFS_FLATE_ERROR_BAD_FLATE_BLOCK;
        goto exit;
      }
      PUFFS_COROUTINE_SUSPENSION_POINT(5);
      if (a_src.buf) {
        size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
        a_src.buf->ri += n;
        puffs_base_limit1* lim;
        for (lim = &a_src.limit; lim; lim = lim->next) {
          if (lim->ptr_to_len) {
            *lim->ptr_to_len -= n;
          }
        }
      }
      status = puffs_flate_decoder_decode_huffman(self, a_dst, a_src);
      if (a_src.buf) {
        b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
        size_t len = a_src.buf->wi - a_src.buf->ri;
        puffs_base_limit1* lim;
        for (lim = &a_src.limit; lim; lim = lim->next) {
          if (lim->ptr_to_len && (len > *lim->ptr_to_len)) {
            len = *lim->ptr_to_len;
          }
        }
        b_rend_src = b_rptr_src + len;
      }
      if (status) {
        goto suspend;
      }
    }
    self->private_impl.c_decode_blocks[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_blocks[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode_blocks[0].v_final = v_final;
  self->private_impl.c_decode_blocks[0].v_type = v_type;

exit:
  if (a_src.buf) {
    size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
    a_src.buf->ri += n;
    puffs_base_limit1* lim;
    for (lim = &a_src.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len) {
        *lim->ptr_to_len -= n;
      }
    }
    PUFFS_IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rstart_src);
    PUFFS_IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rend_src);
  }

  return status;

short_read_src:
  if (a_src.limit.ptr_to_len) {
    status = PUFFS_FLATE_SUSPENSION_LIMITED_READ;
  } else if (a_src.buf && a_src.buf->closed) {
    status = PUFFS_FLATE_ERROR_UNEXPECTED_EOF;
    goto exit;
  } else {
    status = PUFFS_FLATE_SUSPENSION_SHORT_READ;
  }
  goto suspend;
}

puffs_flate_status puffs_flate_decoder_decode_uncompressed(
    puffs_flate_decoder* self,
    puffs_base_writer1 a_dst,
    puffs_base_reader1 a_src) {
  puffs_flate_status status = PUFFS_FLATE_STATUS_OK;

  uint32_t v_n;

  uint8_t* b_wptr_dst = NULL;
  uint8_t* b_wstart_dst = NULL;
  uint8_t* b_wend_dst = NULL;
  if (a_dst.buf) {
    b_wptr_dst = a_dst.buf->ptr + a_dst.buf->wi;
    b_wstart_dst = b_wptr_dst;
    size_t len = a_dst.buf->len - a_dst.buf->wi;
    puffs_base_limit1* lim;
    for (lim = &a_dst.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len && (len > *lim->ptr_to_len)) {
        len = *lim->ptr_to_len;
      }
    }
    b_wend_dst = b_wptr_dst + len;
  }
  uint8_t* b_rptr_src = NULL;
  uint8_t* b_rstart_src = NULL;
  uint8_t* b_rend_src = NULL;
  if (a_src.buf) {
    b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
    b_rstart_src = b_rptr_src;
    size_t len = a_src.buf->wi - a_src.buf->ri;
    puffs_base_limit1* lim;
    for (lim = &a_src.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len && (len > *lim->ptr_to_len)) {
        len = *lim->ptr_to_len;
      }
    }
    b_rend_src = b_rptr_src + len;
  }

  uint32_t coro_susp_point =
      self->private_impl.c_decode_uncompressed[0].coro_susp_point;
  if (coro_susp_point) {
    v_n = self->private_impl.c_decode_uncompressed[0].v_n;
  }
  switch (coro_susp_point) {
    PUFFS_COROUTINE_SUSPENSION_POINT(0);

    if (self->private_impl.f_n_bits >= 8) {
      status = PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_N_BITS;
      goto exit;
    }
    self->private_impl.f_n_bits = 0;
    PUFFS_COROUTINE_SUSPENSION_POINT(1);
    uint32_t t_1;
    if (PUFFS_LIKELY(b_rend_src - b_rptr_src >= 4)) {
      t_1 = puffs_base_load_u32le(b_rptr_src);
      b_rptr_src += 4;
    } else {
      self->private_impl.c_decode_uncompressed[0].scratch = 0;
      PUFFS_COROUTINE_SUSPENSION_POINT(2);
      while (true) {
        if (PUFFS_UNLIKELY(b_rptr_src == b_rend_src)) {
          goto short_read_src;
        }
        uint32_t t_0 =
            self->private_impl.c_decode_uncompressed[0].scratch >> 56;
        self->private_impl.c_decode_uncompressed[0].scratch <<= 8;
        self->private_impl.c_decode_uncompressed[0].scratch >>= 8;
        self->private_impl.c_decode_uncompressed[0].scratch |=
            ((uint64_t)(*b_rptr_src++)) << t_0;
        if (t_0 == 24) {
          t_1 = self->private_impl.c_decode_uncompressed[0].scratch;
          break;
        }
        t_0 += 8;
        self->private_impl.c_decode_uncompressed[0].scratch |= ((uint64_t)(t_0))
                                                               << 56;
      }
    }
    v_n = t_1;
    if ((((v_n) & ((1 << (16)) - 1)) + ((v_n) >> (32 - (16)))) != 65535) {
      status = PUFFS_FLATE_ERROR_INCONSISTENT_STORED_BLOCK_LENGTH;
      goto exit;
    }
    PUFFS_COROUTINE_SUSPENSION_POINT(3);
    {
      self->private_impl.c_decode_uncompressed[0].scratch =
          ((v_n) & ((1 << (16)) - 1));
      PUFFS_COROUTINE_SUSPENSION_POINT(4);
      size_t t_2 = self->private_impl.c_decode_uncompressed[0].scratch;
      if (t_2 > b_wend_dst - b_wptr_dst) {
        t_2 = b_wend_dst - b_wptr_dst;
        status = PUFFS_FLATE_SUSPENSION_SHORT_WRITE;
      }
      if (t_2 > b_rend_src - b_rptr_src) {
        t_2 = b_rend_src - b_rptr_src;
        status = PUFFS_FLATE_SUSPENSION_SHORT_READ;
      }
      memmove(b_wptr_dst, b_rptr_src, t_2);
      b_wptr_dst += t_2;
      b_rptr_src += t_2;
      if (status) {
        self->private_impl.c_decode_uncompressed[0].scratch -= t_2;
        goto suspend;
      }
    }
    self->private_impl.c_decode_uncompressed[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_uncompressed[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode_uncompressed[0].v_n = v_n;

exit:
  if (a_dst.buf) {
    size_t n = b_wptr_dst - (a_dst.buf->ptr + a_dst.buf->wi);
    a_dst.buf->wi += n;
    puffs_base_limit1* lim;
    for (lim = &a_dst.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len) {
        *lim->ptr_to_len -= n;
      }
    }
    PUFFS_IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_wstart_dst);
    PUFFS_IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_wend_dst);
  }
  if (a_src.buf) {
    size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
    a_src.buf->ri += n;
    puffs_base_limit1* lim;
    for (lim = &a_src.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len) {
        *lim->ptr_to_len -= n;
      }
    }
    PUFFS_IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rstart_src);
    PUFFS_IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rend_src);
  }

  return status;

short_read_src:
  if (a_src.limit.ptr_to_len) {
    status = PUFFS_FLATE_SUSPENSION_LIMITED_READ;
  } else if (a_src.buf && a_src.buf->closed) {
    status = PUFFS_FLATE_ERROR_UNEXPECTED_EOF;
    goto exit;
  } else {
    status = PUFFS_FLATE_SUSPENSION_SHORT_READ;
  }
  goto suspend;
}

puffs_flate_status puffs_flate_decoder_decode_huffman(
    puffs_flate_decoder* self,
    puffs_base_writer1 a_dst,
    puffs_base_reader1 a_src) {
  puffs_flate_status status = PUFFS_FLATE_STATUS_OK;

  uint32_t v_bits;
  uint32_t v_n_bits;
  uint32_t v_table_entry;
  uint32_t v_table_entry_n_bits;
  uint32_t v_lmask;
  uint32_t v_dmask;
  uint32_t v_redir_top;
  uint32_t v_redir_mask;
  uint32_t v_length;
  uint32_t v_distance;

  uint8_t* b_wptr_dst = NULL;
  uint8_t* b_wstart_dst = NULL;
  uint8_t* b_wend_dst = NULL;
  if (a_dst.buf) {
    b_wptr_dst = a_dst.buf->ptr + a_dst.buf->wi;
    b_wstart_dst = b_wptr_dst;
    size_t len = a_dst.buf->len - a_dst.buf->wi;
    puffs_base_limit1* lim;
    for (lim = &a_dst.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len && (len > *lim->ptr_to_len)) {
        len = *lim->ptr_to_len;
      }
    }
    b_wend_dst = b_wptr_dst + len;
  }
  uint8_t* b_rptr_src = NULL;
  uint8_t* b_rstart_src = NULL;
  uint8_t* b_rend_src = NULL;
  if (a_src.buf) {
    b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
    b_rstart_src = b_rptr_src;
    size_t len = a_src.buf->wi - a_src.buf->ri;
    puffs_base_limit1* lim;
    for (lim = &a_src.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len && (len > *lim->ptr_to_len)) {
        len = *lim->ptr_to_len;
      }
    }
    b_rend_src = b_rptr_src + len;
  }

  uint32_t coro_susp_point =
      self->private_impl.c_decode_huffman[0].coro_susp_point;
  if (coro_susp_point) {
    v_bits = self->private_impl.c_decode_huffman[0].v_bits;
    v_n_bits = self->private_impl.c_decode_huffman[0].v_n_bits;
    v_table_entry = self->private_impl.c_decode_huffman[0].v_table_entry;
    v_table_entry_n_bits =
        self->private_impl.c_decode_huffman[0].v_table_entry_n_bits;
    v_lmask = self->private_impl.c_decode_huffman[0].v_lmask;
    v_dmask = self->private_impl.c_decode_huffman[0].v_dmask;
    v_redir_top = self->private_impl.c_decode_huffman[0].v_redir_top;
    v_redir_mask = self->private_impl.c_decode_huffman[0].v_redir_mask;
    v_length = self->private_impl.c_decode_huffman[0].v_length;
    v_distance = self->private_impl.c_decode_huffman[0].v_distance;
  }
  switch (coro_susp_point) {
    PUFFS_COROUTINE_SUSPENSION_POINT(0);

    v_bits = self->private_impl.f_bits;
    v_n_bits = self->private_impl.f_n_bits;
    v_table_entry = 0;
    v_table_entry_n_bits = 0;
    v_lmask = ((((uint32_t)(1)) << self->private_impl.f_n_huffs_bits[0]) - 1);
    v_dmask = ((((uint32_t)(1)) << self->private_impl.f_n_huffs_bits[1]) - 1);
  label_0_continue:;
    while (true) {
      while (true) {
        v_table_entry = self->private_impl.f_huffs[0][v_bits & v_lmask];
        v_table_entry_n_bits = (v_table_entry & 15);
        if (v_n_bits >= v_table_entry_n_bits) {
          v_bits >>= v_table_entry_n_bits;
          v_n_bits -= v_table_entry_n_bits;
          goto label_1_break;
        }
        PUFFS_COROUTINE_SUSPENSION_POINT(1);
        if (PUFFS_UNLIKELY(b_rptr_src == b_rend_src)) {
          goto short_read_src;
        }
        uint8_t t_0 = *b_rptr_src++;
        v_bits |= (((uint32_t)(t_0)) << v_n_bits);
        v_n_bits += 8;
      }
    label_1_break:;
      if ((v_table_entry >> 28) == 1) {
        v_redir_top = ((v_table_entry >> 8) & 65535);
        v_redir_mask = ((((uint32_t)(1)) << ((v_table_entry >> 4) & 15)) - 1);
        while (true) {
          if ((v_redir_top + (v_bits & v_redir_mask)) >= 1234) {
            status =
                PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
            goto exit;
          }
          v_table_entry =
              self->private_impl
                  .f_huffs[0][v_redir_top + (v_bits & v_redir_mask)];
          v_table_entry_n_bits = (v_table_entry & 15);
          if (v_n_bits >= v_table_entry_n_bits) {
            v_bits >>= v_table_entry_n_bits;
            v_n_bits -= v_table_entry_n_bits;
            goto label_2_break;
          }
          PUFFS_COROUTINE_SUSPENSION_POINT(2);
          if (PUFFS_UNLIKELY(b_rptr_src == b_rend_src)) {
            goto short_read_src;
          }
          uint8_t t_1 = *b_rptr_src++;
          v_bits |= (((uint32_t)(t_1)) << v_n_bits);
          v_n_bits += 8;
        }
      label_2_break:;
        if ((v_table_entry >> 28) == 1) {
          status =
              PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
          goto exit;
        }
      }
      if ((v_table_entry >> 31) != 0) {
        PUFFS_COROUTINE_SUSPENSION_POINT(3);
        if (b_wptr_dst == b_wend_dst) {
          status = PUFFS_FLATE_SUSPENSION_SHORT_WRITE;
          goto suspend;
        }
        *b_wptr_dst++ = ((v_table_entry >> 8) & 255);
        goto label_0_continue;
      } else if ((v_table_entry >> 30) != 0) {
      } else if ((v_table_entry >> 29) != 0) {
        goto label_0_break;
      } else if ((v_table_entry >> 24) == 8) {
        status = PUFFS_FLATE_ERROR_BAD_HUFFMAN_CODE;
        goto exit;
      } else {
        status =
            PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
        goto exit;
      }
      v_length = ((v_table_entry >> 8) & 65535);
      if (v_length > 65535) {
        status =
            PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
        goto exit;
      }
      v_table_entry_n_bits = ((v_table_entry >> 4) & 15);
      while (v_n_bits < v_table_entry_n_bits) {
        PUFFS_COROUTINE_SUSPENSION_POINT(4);
        if (PUFFS_UNLIKELY(b_rptr_src == b_rend_src)) {
          goto short_read_src;
        }
        uint8_t t_2 = *b_rptr_src++;
        v_bits |= (((uint32_t)(t_2)) << v_n_bits);
        v_n_bits += 8;
      }
      v_length += ((v_bits) & ((1 << (v_table_entry_n_bits)) - 1));
      v_bits >>= v_table_entry_n_bits;
      v_n_bits -= v_table_entry_n_bits;
      while (true) {
        v_table_entry = self->private_impl.f_huffs[1][v_bits & v_dmask];
        v_table_entry_n_bits = (v_table_entry & 15);
        if (v_n_bits >= v_table_entry_n_bits) {
          v_bits >>= v_table_entry_n_bits;
          v_n_bits -= v_table_entry_n_bits;
          goto label_3_break;
        }
        PUFFS_COROUTINE_SUSPENSION_POINT(5);
        if (PUFFS_UNLIKELY(b_rptr_src == b_rend_src)) {
          goto short_read_src;
        }
        uint8_t t_3 = *b_rptr_src++;
        v_bits |= (((uint32_t)(t_3)) << v_n_bits);
        v_n_bits += 8;
      }
    label_3_break:;
      if ((v_table_entry >> 28) == 1) {
        v_redir_top = ((v_table_entry >> 8) & 65535);
        v_redir_mask = ((((uint32_t)(1)) << ((v_table_entry >> 4) & 15)) - 1);
        while (true) {
          if ((v_redir_top + (v_bits & v_redir_mask)) >= 1234) {
            status =
                PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
            goto exit;
          }
          v_table_entry =
              self->private_impl
                  .f_huffs[1][v_redir_top + (v_bits & v_redir_mask)];
          v_table_entry_n_bits = (v_table_entry & 15);
          if (v_n_bits >= v_table_entry_n_bits) {
            v_bits >>= v_table_entry_n_bits;
            v_n_bits -= v_table_entry_n_bits;
            goto label_4_break;
          }
          PUFFS_COROUTINE_SUSPENSION_POINT(6);
          if (PUFFS_UNLIKELY(b_rptr_src == b_rend_src)) {
            goto short_read_src;
          }
          uint8_t t_4 = *b_rptr_src++;
          v_bits |= (((uint32_t)(t_4)) << v_n_bits);
          v_n_bits += 8;
        }
      label_4_break:;
        if ((v_table_entry >> 31) != 0) {
          status =
              PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
          goto exit;
        }
      }
      if ((v_table_entry >> 24) != 64) {
        if ((v_table_entry >> 24) == 8) {
          status = PUFFS_FLATE_ERROR_BAD_HUFFMAN_CODE;
          goto exit;
        }
        status =
            PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
        goto exit;
      }
      v_distance = ((v_table_entry >> 8) & 65535);
      if (v_distance > 65535) {
        status =
            PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
        goto exit;
      }
      v_table_entry_n_bits = ((v_table_entry >> 4) & 15);
      while (v_n_bits < v_table_entry_n_bits) {
        PUFFS_COROUTINE_SUSPENSION_POINT(7);
        if (PUFFS_UNLIKELY(b_rptr_src == b_rend_src)) {
          goto short_read_src;
        }
        uint8_t t_5 = *b_rptr_src++;
        v_bits |= (((uint32_t)(t_5)) << v_n_bits);
        v_n_bits += 8;
      }
      v_distance += ((v_bits) & ((1 << (v_table_entry_n_bits)) - 1));
      v_bits >>= v_table_entry_n_bits;
      v_n_bits -= v_table_entry_n_bits;
      PUFFS_COROUTINE_SUSPENSION_POINT(8);
      {
        self->private_impl.c_decode_huffman[0].scratch =
            ((uint64_t)(v_distance) << 32) | (uint64_t)(v_length);
        PUFFS_COROUTINE_SUSPENSION_POINT(9);
        size_t t_6 =
            (size_t)(self->private_impl.c_decode_huffman[0].scratch >> 32);
        if (PUFFS_UNLIKELY((t_6 == 0) || (t_6 > (b_wptr_dst - b_wstart_dst)))) {
          status = PUFFS_FLATE_ERROR_BAD_ARGUMENT;
          goto exit;
        }
        uint8_t* t_7 = b_wptr_dst - t_6;
        uint32_t t_8 =
            (uint32_t)(self->private_impl.c_decode_huffman[0].scratch);
        if (PUFFS_LIKELY((size_t)(t_8) <= (b_wend_dst - b_wptr_dst))) {
          for (; t_8 >= 8; t_8 -= 8) {
            *b_wptr_dst++ = *t_7++;
            *b_wptr_dst++ = *t_7++;
            *b_wptr_dst++ = *t_7++;
            *b_wptr_dst++ = *t_7++;
            *b_wptr_dst++ = *t_7++;
            *b_wptr_dst++ = *t_7++;
            *b_wptr_dst++ = *t_7++;
            *b_wptr_dst++ = *t_7++;
          }
          for (; t_8; t_8--) {
            *b_wptr_dst++ = *t_7++;
          }
        } else {
          t_8 = (uint32_t)(b_wend_dst - b_wptr_dst);
          self->private_impl.c_decode_huffman[0].scratch -= (uint64_t)(t_8);
          for (; t_8; t_8--) {
            *b_wptr_dst++ = *t_7++;
          }
          status = PUFFS_FLATE_SUSPENSION_SHORT_WRITE;
          goto suspend;
        }
      }
    }
  label_0_break:;
    self->private_impl.f_bits = v_bits;
    self->private_impl.f_n_bits = v_n_bits;
    self->private_impl.c_decode_huffman[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode_huffman[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode_huffman[0].v_bits = v_bits;
  self->private_impl.c_decode_huffman[0].v_n_bits = v_n_bits;
  self->private_impl.c_decode_huffman[0].v_table_entry = v_table_entry;
  self->private_impl.c_decode_huffman[0].v_table_entry_n_bits =
      v_table_entry_n_bits;
  self->private_impl.c_decode_huffman[0].v_lmask = v_lmask;
  self->private_impl.c_decode_huffman[0].v_dmask = v_dmask;
  self->private_impl.c_decode_huffman[0].v_redir_top = v_redir_top;
  self->private_impl.c_decode_huffman[0].v_redir_mask = v_redir_mask;
  self->private_impl.c_decode_huffman[0].v_length = v_length;
  self->private_impl.c_decode_huffman[0].v_distance = v_distance;

exit:
  if (a_dst.buf) {
    size_t n = b_wptr_dst - (a_dst.buf->ptr + a_dst.buf->wi);
    a_dst.buf->wi += n;
    puffs_base_limit1* lim;
    for (lim = &a_dst.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len) {
        *lim->ptr_to_len -= n;
      }
    }
    PUFFS_IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_wstart_dst);
    PUFFS_IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_wend_dst);
  }
  if (a_src.buf) {
    size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
    a_src.buf->ri += n;
    puffs_base_limit1* lim;
    for (lim = &a_src.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len) {
        *lim->ptr_to_len -= n;
      }
    }
    PUFFS_IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rstart_src);
    PUFFS_IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rend_src);
  }

  return status;

short_read_src:
  if (a_src.limit.ptr_to_len) {
    status = PUFFS_FLATE_SUSPENSION_LIMITED_READ;
  } else if (a_src.buf && a_src.buf->closed) {
    status = PUFFS_FLATE_ERROR_UNEXPECTED_EOF;
    goto exit;
  } else {
    status = PUFFS_FLATE_SUSPENSION_SHORT_READ;
  }
  goto suspend;
}

puffs_flate_status puffs_flate_decoder_init_fixed_huffman(
    puffs_flate_decoder* self) {
  puffs_flate_status status = PUFFS_FLATE_STATUS_OK;

  uint32_t v_i;

  uint32_t coro_susp_point =
      self->private_impl.c_init_fixed_huffman[0].coro_susp_point;
  if (coro_susp_point) {
    v_i = self->private_impl.c_init_fixed_huffman[0].v_i;
  }
  switch (coro_susp_point) {
    PUFFS_COROUTINE_SUSPENSION_POINT(0);

    v_i = 0;
    while (v_i < 144) {
      self->private_impl.f_code_lengths[v_i] = 8;
      v_i += 1;
    }
    while (v_i < 256) {
      self->private_impl.f_code_lengths[v_i] = 9;
      v_i += 1;
    }
    while (v_i < 280) {
      self->private_impl.f_code_lengths[v_i] = 7;
      v_i += 1;
    }
    while (v_i < 288) {
      self->private_impl.f_code_lengths[v_i] = 8;
      v_i += 1;
    }
    while (v_i < 320) {
      self->private_impl.f_code_lengths[v_i] = 5;
      v_i += 1;
    }
    PUFFS_COROUTINE_SUSPENSION_POINT(1);
    status = puffs_flate_decoder_init_huff(self, 0, 0, 288, 257);
    if (status) {
      goto suspend;
    }
    PUFFS_COROUTINE_SUSPENSION_POINT(2);
    status = puffs_flate_decoder_init_huff(self, 1, 288, 320, 0);
    if (status) {
      goto suspend;
    }
    self->private_impl.c_init_fixed_huffman[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_init_fixed_huffman[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_init_fixed_huffman[0].v_i = v_i;

exit:
  return status;
}

puffs_flate_status puffs_flate_decoder_init_dynamic_huffman(
    puffs_flate_decoder* self,
    puffs_base_reader1 a_src) {
  puffs_flate_status status = PUFFS_FLATE_STATUS_OK;

  uint32_t v_bits;
  uint32_t v_n_bits;
  uint32_t v_n_lit;
  uint32_t v_n_dist;
  uint32_t v_n_clen;
  uint32_t v_i;
  uint32_t v_mask;
  uint32_t v_table_entry;
  uint32_t v_table_entry_n_bits;
  uint32_t v_n_extra_bits;
  uint8_t v_rep_symbol;
  uint32_t v_rep_count;

  uint8_t* b_rptr_src = NULL;
  uint8_t* b_rstart_src = NULL;
  uint8_t* b_rend_src = NULL;
  if (a_src.buf) {
    b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
    b_rstart_src = b_rptr_src;
    size_t len = a_src.buf->wi - a_src.buf->ri;
    puffs_base_limit1* lim;
    for (lim = &a_src.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len && (len > *lim->ptr_to_len)) {
        len = *lim->ptr_to_len;
      }
    }
    b_rend_src = b_rptr_src + len;
  }

  uint32_t coro_susp_point =
      self->private_impl.c_init_dynamic_huffman[0].coro_susp_point;
  if (coro_susp_point) {
    v_bits = self->private_impl.c_init_dynamic_huffman[0].v_bits;
    v_n_bits = self->private_impl.c_init_dynamic_huffman[0].v_n_bits;
    v_n_lit = self->private_impl.c_init_dynamic_huffman[0].v_n_lit;
    v_n_dist = self->private_impl.c_init_dynamic_huffman[0].v_n_dist;
    v_n_clen = self->private_impl.c_init_dynamic_huffman[0].v_n_clen;
    v_i = self->private_impl.c_init_dynamic_huffman[0].v_i;
    v_mask = self->private_impl.c_init_dynamic_huffman[0].v_mask;
    v_table_entry = self->private_impl.c_init_dynamic_huffman[0].v_table_entry;
    v_table_entry_n_bits =
        self->private_impl.c_init_dynamic_huffman[0].v_table_entry_n_bits;
    v_n_extra_bits =
        self->private_impl.c_init_dynamic_huffman[0].v_n_extra_bits;
    v_rep_symbol = self->private_impl.c_init_dynamic_huffman[0].v_rep_symbol;
    v_rep_count = self->private_impl.c_init_dynamic_huffman[0].v_rep_count;
  }
  switch (coro_susp_point) {
    PUFFS_COROUTINE_SUSPENSION_POINT(0);

    v_bits = self->private_impl.f_bits;
    v_n_bits = self->private_impl.f_n_bits;
    while (v_n_bits < 14) {
      PUFFS_COROUTINE_SUSPENSION_POINT(1);
      if (PUFFS_UNLIKELY(b_rptr_src == b_rend_src)) {
        goto short_read_src;
      }
      uint8_t t_0 = *b_rptr_src++;
      v_bits |= (((uint32_t)(t_0)) << v_n_bits);
      v_n_bits += 8;
    }
    v_n_lit = (((v_bits) & ((1 << (5)) - 1)) + 257);
    if (v_n_lit > 286) {
      status = PUFFS_FLATE_ERROR_BAD_LITERAL_LENGTH_CODE_COUNT;
      goto exit;
    }
    v_bits >>= 5;
    v_n_dist = (((v_bits) & ((1 << (5)) - 1)) + 1);
    if (v_n_dist > 30) {
      status = PUFFS_FLATE_ERROR_BAD_DISTANCE_CODE_COUNT;
      goto exit;
    }
    v_bits >>= 5;
    v_n_clen = (((v_bits) & ((1 << (4)) - 1)) + 4);
    v_bits >>= 4;
    v_n_bits -= 14;
    v_i = 0;
    while (v_i < v_n_clen) {
      while (v_n_bits < 3) {
        PUFFS_COROUTINE_SUSPENSION_POINT(2);
        if (PUFFS_UNLIKELY(b_rptr_src == b_rend_src)) {
          goto short_read_src;
        }
        uint8_t t_1 = *b_rptr_src++;
        v_bits |= (((uint32_t)(t_1)) << v_n_bits);
        v_n_bits += 8;
      }
      self->private_impl.f_code_lengths[puffs_flate_code_order[v_i]] =
          ((uint8_t)((v_bits & 7)));
      v_bits >>= 3;
      v_n_bits -= 3;
      v_i += 1;
    }
    while (v_i < 19) {
      self->private_impl.f_code_lengths[puffs_flate_code_order[v_i]] = 0;
      v_i += 1;
    }
    PUFFS_COROUTINE_SUSPENSION_POINT(3);
    status = puffs_flate_decoder_init_huff(self, 0, 0, 19, 4095);
    if (status) {
      goto suspend;
    }
    v_mask = ((((uint32_t)(1)) << self->private_impl.f_n_huffs_bits[0]) - 1);
    v_i = 0;
  label_0_continue:;
    while (v_i < (v_n_lit + v_n_dist)) {
      v_table_entry = 0;
      while (true) {
        v_table_entry = self->private_impl.f_huffs[0][v_bits & v_mask];
        v_table_entry_n_bits = (v_table_entry & 15);
        if (v_n_bits >= v_table_entry_n_bits) {
          v_bits >>= v_table_entry_n_bits;
          v_n_bits -= v_table_entry_n_bits;
          goto label_1_break;
        }
        PUFFS_COROUTINE_SUSPENSION_POINT(4);
        if (PUFFS_UNLIKELY(b_rptr_src == b_rend_src)) {
          goto short_read_src;
        }
        uint8_t t_2 = *b_rptr_src++;
        v_bits |= (((uint32_t)(t_2)) << v_n_bits);
        v_n_bits += 8;
      }
    label_1_break:;
      if ((v_table_entry >> 24) != 128) {
        status =
            PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
        goto exit;
      }
      v_table_entry = ((v_table_entry >> 8) & 255);
      if (v_table_entry < 16) {
        self->private_impl.f_code_lengths[v_i] = ((uint8_t)(v_table_entry));
        v_i += 1;
        goto label_0_continue;
      }
      v_n_extra_bits = 0;
      v_rep_symbol = 0;
      v_rep_count = 0;
      if (v_table_entry == 16) {
        v_n_extra_bits = 2;
        if (v_i <= 0) {
          status = PUFFS_FLATE_ERROR_BAD_HUFFMAN_CODE_LENGTH_REPETITION;
          goto exit;
        }
        v_rep_symbol = self->private_impl.f_code_lengths[v_i - 1];
        v_rep_count = 3;
      } else if (v_table_entry == 17) {
        v_n_extra_bits = 3;
        v_rep_symbol = 0;
        v_rep_count = 3;
      } else if (v_table_entry == 18) {
        v_n_extra_bits = 7;
        v_rep_symbol = 0;
        v_rep_count = 11;
      } else {
        status =
            PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
        goto exit;
      }
      while (v_n_bits < v_n_extra_bits) {
        PUFFS_COROUTINE_SUSPENSION_POINT(5);
        if (PUFFS_UNLIKELY(b_rptr_src == b_rend_src)) {
          goto short_read_src;
        }
        uint8_t t_3 = *b_rptr_src++;
        v_bits |= (((uint32_t)(t_3)) << v_n_bits);
        v_n_bits += 8;
      }
      v_rep_count += ((v_bits) & ((1 << (v_n_extra_bits)) - 1));
      v_bits >>= v_n_extra_bits;
      v_n_bits -= v_n_extra_bits;
      while (v_rep_count > 0) {
        if (v_i >= (v_n_lit + v_n_dist)) {
          status = PUFFS_FLATE_ERROR_BAD_HUFFMAN_CODE_LENGTH_COUNT;
          goto exit;
        }
        self->private_impl.f_code_lengths[v_i] = v_rep_symbol;
        v_i += 1;
        v_rep_count -= 1;
      }
    }
    if (v_i != (v_n_lit + v_n_dist)) {
      status = PUFFS_FLATE_ERROR_BAD_HUFFMAN_CODE_LENGTH_COUNT;
      goto exit;
    }
    if (self->private_impl.f_code_lengths[256] == 0) {
      status = PUFFS_FLATE_ERROR_MISSING_END_OF_BLOCK_CODE;
      goto exit;
    }
    PUFFS_COROUTINE_SUSPENSION_POINT(6);
    status = puffs_flate_decoder_init_huff(self, 0, 0, v_n_lit, 257);
    if (status) {
      goto suspend;
    }
    PUFFS_COROUTINE_SUSPENSION_POINT(7);
    status = puffs_flate_decoder_init_huff(self, 1, v_n_lit,
                                           (v_n_lit + v_n_dist), 0);
    if (status) {
      goto suspend;
    }
    self->private_impl.f_bits = v_bits;
    self->private_impl.f_n_bits = v_n_bits;
    self->private_impl.c_init_dynamic_huffman[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_init_dynamic_huffman[0].coro_susp_point =
      coro_susp_point;
  self->private_impl.c_init_dynamic_huffman[0].v_bits = v_bits;
  self->private_impl.c_init_dynamic_huffman[0].v_n_bits = v_n_bits;
  self->private_impl.c_init_dynamic_huffman[0].v_n_lit = v_n_lit;
  self->private_impl.c_init_dynamic_huffman[0].v_n_dist = v_n_dist;
  self->private_impl.c_init_dynamic_huffman[0].v_n_clen = v_n_clen;
  self->private_impl.c_init_dynamic_huffman[0].v_i = v_i;
  self->private_impl.c_init_dynamic_huffman[0].v_mask = v_mask;
  self->private_impl.c_init_dynamic_huffman[0].v_table_entry = v_table_entry;
  self->private_impl.c_init_dynamic_huffman[0].v_table_entry_n_bits =
      v_table_entry_n_bits;
  self->private_impl.c_init_dynamic_huffman[0].v_n_extra_bits = v_n_extra_bits;
  self->private_impl.c_init_dynamic_huffman[0].v_rep_symbol = v_rep_symbol;
  self->private_impl.c_init_dynamic_huffman[0].v_rep_count = v_rep_count;

exit:
  if (a_src.buf) {
    size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
    a_src.buf->ri += n;
    puffs_base_limit1* lim;
    for (lim = &a_src.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len) {
        *lim->ptr_to_len -= n;
      }
    }
    PUFFS_IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rstart_src);
    PUFFS_IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rend_src);
  }

  return status;

short_read_src:
  if (a_src.limit.ptr_to_len) {
    status = PUFFS_FLATE_SUSPENSION_LIMITED_READ;
  } else if (a_src.buf && a_src.buf->closed) {
    status = PUFFS_FLATE_ERROR_UNEXPECTED_EOF;
    goto exit;
  } else {
    status = PUFFS_FLATE_SUSPENSION_SHORT_READ;
  }
  goto suspend;
}

puffs_flate_status puffs_flate_decoder_init_huff(puffs_flate_decoder* self,
                                                 uint32_t a_which,
                                                 uint32_t a_n_codes0,
                                                 uint32_t a_n_codes1,
                                                 uint32_t a_base_symbol) {
  puffs_flate_status status = PUFFS_FLATE_STATUS_OK;

  uint16_t v_counts[16];
  uint32_t v_i;
  uint32_t v_remaining;
  uint16_t v_offsets[16];
  uint32_t v_n_symbols;
  uint32_t v_count;
  uint16_t v_symbols[320];
  uint32_t v_min_cl;
  uint32_t v_max_cl;
  uint32_t v_initial_high_bits;
  uint32_t v_prev_cl;
  uint32_t v_prev_redirect_key;
  uint32_t v_top;
  uint32_t v_next_top;
  uint32_t v_code;
  uint32_t v_key;
  uint32_t v_value;
  uint32_t v_cl;
  uint32_t v_tmp;
  uint32_t v_redirect_key;
  uint32_t v_j;
  uint32_t v_reversed_key;
  uint32_t v_symbol;
  uint32_t v_high_bits;
  uint32_t v_delta;

  memset(v_counts, 0, sizeof(v_counts));
  v_i = a_n_codes0;
  while (v_i < a_n_codes1) {
    if (v_counts[self->private_impl.f_code_lengths[v_i]] >= 320) {
      status =
          PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
      goto exit;
    }
    v_counts[self->private_impl.f_code_lengths[v_i]] += 1;
    v_i += 1;
  }
  if ((((uint32_t)(v_counts[0])) + a_n_codes0) == a_n_codes1) {
    status = PUFFS_FLATE_ERROR_NO_HUFFMAN_CODES;
    goto exit;
  }
  v_remaining = 1;
  v_i = 1;
  while (v_i <= 15) {
    if (v_remaining > 1073741824) {
      status =
          PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
      goto exit;
    }
    v_remaining <<= 1;
    if (v_remaining < ((uint32_t)(v_counts[v_i]))) {
      status = PUFFS_FLATE_ERROR_BAD_HUFFMAN_CODE_OVER_SUBSCRIBED;
      goto exit;
    }
    v_remaining -= ((uint32_t)(v_counts[v_i]));
    v_i += 1;
  }
  if (v_remaining != 0) {
    status = PUFFS_FLATE_ERROR_BAD_HUFFMAN_CODE_UNDER_SUBSCRIBED;
    goto exit;
  }
  memset(v_offsets, 0, sizeof(v_offsets));
  v_n_symbols = 0;
  v_i = 1;
  while (v_i <= 15) {
    v_offsets[v_i] = ((uint16_t)(v_n_symbols));
    v_count = ((uint32_t)(v_counts[v_i]));
    if (v_n_symbols > (320 - v_count)) {
      status =
          PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
      goto exit;
    }
    v_n_symbols = (v_n_symbols + v_count);
    v_i += 1;
  }
  if (v_n_symbols > 288) {
    status =
        PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
    goto exit;
  }
  memset(v_symbols, 0, sizeof(v_symbols));
  v_i = a_n_codes0;
  while (v_i < a_n_codes1) {
    if (v_i < a_n_codes0) {
      status =
          PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
      goto exit;
    }
    if (self->private_impl.f_code_lengths[v_i] != 0) {
      if (v_offsets[self->private_impl.f_code_lengths[v_i]] >= 320) {
        status =
            PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
        goto exit;
      }
      v_symbols[v_offsets[self->private_impl.f_code_lengths[v_i]]] =
          ((uint16_t)((v_i - a_n_codes0)));
      v_offsets[self->private_impl.f_code_lengths[v_i]] += 1;
    }
    v_i += 1;
  }
  v_min_cl = 1;
  while (true) {
    if (v_counts[v_min_cl] != 0) {
      goto label_0_break;
    }
    if (v_min_cl >= 9) {
      status = PUFFS_FLATE_ERROR_BAD_HUFFMAN_MINIMUM_CODE_LENGTH;
      goto exit;
    }
    v_min_cl += 1;
  }
label_0_break:;
  v_max_cl = 15;
  while (true) {
    if (v_counts[v_max_cl] != 0) {
      goto label_1_break;
    }
    if (v_max_cl <= 1) {
      status = PUFFS_FLATE_ERROR_NO_HUFFMAN_CODES;
      goto exit;
    }
    v_max_cl -= 1;
  }
label_1_break:;
  if (v_max_cl <= 9) {
    self->private_impl.f_n_huffs_bits[a_which] = v_max_cl;
  } else {
    self->private_impl.f_n_huffs_bits[a_which] = 9;
  }
  v_i = 0;
  if ((v_n_symbols != ((uint32_t)(v_offsets[v_max_cl]))) ||
      (v_n_symbols != ((uint32_t)(v_offsets[15])))) {
    status =
        PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
    goto exit;
  }
  if ((a_n_codes0 + ((uint32_t)(v_symbols[0]))) >= 320) {
    status =
        PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
    goto exit;
  }
  v_initial_high_bits = 512;
  if (v_max_cl < 9) {
    v_initial_high_bits = (((uint32_t)(1)) << v_max_cl);
  }
  v_prev_cl = ((uint32_t)(
      self->private_impl
          .f_code_lengths[a_n_codes0 + ((uint32_t)(v_symbols[0]))]));
  v_prev_redirect_key = 4294967295;
  v_top = 0;
  v_next_top = 512;
  v_code = 0;
  v_key = 0;
  v_value = 0;
  while (true) {
    if ((a_n_codes0 + ((uint32_t)(v_symbols[v_i]))) >= 320) {
      status =
          PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
      goto exit;
    }
    v_cl = ((uint32_t)(
        self->private_impl
            .f_code_lengths[a_n_codes0 + ((uint32_t)(v_symbols[v_i]))]));
    if (v_cl > v_prev_cl) {
      v_code <<= (v_cl - v_prev_cl);
      if (v_code >= 32768) {
        status =
            PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
        goto exit;
      }
    }
    v_prev_cl = v_cl;
    v_key = v_code;
    if (v_cl > 9) {
      v_tmp = (v_cl - 9);
      v_cl = v_tmp;
      v_redirect_key = ((v_key >> v_tmp) & 511);
      v_key = ((v_key) & ((1 << (v_tmp)) - 1));
      if (v_prev_redirect_key != v_redirect_key) {
        v_prev_redirect_key = v_redirect_key;
        v_remaining = (((uint32_t)(1)) << v_cl);
        v_j = v_prev_cl;
        while (v_j <= 15) {
          if (v_remaining <= ((uint32_t)(v_counts[v_j]))) {
            goto label_2_break;
          }
          v_remaining -= ((uint32_t)(v_counts[v_j]));
          if (v_remaining > 1073741824) {
            status =
                PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
            goto exit;
          }
          v_remaining <<= 1;
          v_j += 1;
        }
      label_2_break:;
        if ((v_j <= 9) || (15 < v_j)) {
          status =
              PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
          goto exit;
        }
        v_tmp = (v_j - 9);
        v_initial_high_bits = (((uint32_t)(1)) << v_tmp);
        v_top = v_next_top;
        if ((v_top + (((uint32_t)(1)) << v_tmp)) > 1234) {
          status =
              PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
          goto exit;
        }
        v_next_top = (v_top + (((uint32_t)(1)) << v_tmp));
        v_redirect_key =
            (((uint32_t)(puffs_flate_reverse8[v_redirect_key >> 1])) |
             ((v_redirect_key & 1) << 8));
        self->private_impl.f_huffs[a_which][v_redirect_key] =
            (268435465 | (v_top << 8) | (v_tmp << 4));
      }
    }
    if ((v_key >= 512) || (v_counts[v_prev_cl] <= 0)) {
      status =
          PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
      goto exit;
    }
    v_counts[v_prev_cl] -= 1;
    v_reversed_key =
        (((uint32_t)(puffs_flate_reverse8[v_key >> 1])) | ((v_key & 1) << 8));
    v_reversed_key >>= (9 - v_cl);
    v_symbol = ((uint32_t)(v_symbols[v_i]));
    if (v_symbol == 256) {
      v_value = (536870912 | v_cl);
    } else if ((v_symbol < 256) && (a_which == 0)) {
      v_value = (2147483648 | (v_symbol << 8) | v_cl);
    } else if (v_symbol >= a_base_symbol) {
      v_symbol -= a_base_symbol;
      if (a_which == 0) {
        v_value = (puffs_flate_lcode_magic_numbers[v_symbol & 31] | v_cl);
      } else {
        v_value = (puffs_flate_dcode_magic_numbers[v_symbol & 31] | v_cl);
      }
    } else {
      status =
          PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
      goto exit;
    }
    v_high_bits = v_initial_high_bits;
    v_delta = (((uint32_t)(1)) << v_cl);
    while (v_high_bits >= v_delta) {
      v_high_bits -= v_delta;
      if ((v_top + ((v_high_bits | v_reversed_key) & 511)) >= 1234) {
        status =
            PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
        goto exit;
      }
      self->private_impl
          .f_huffs[a_which][v_top + ((v_high_bits | v_reversed_key) & 511)] =
          v_value;
    }
    v_i += 1;
    if (v_i >= v_n_symbols) {
      goto label_3_break;
    }
    v_code += 1;
    if (v_code >= 32768) {
      status =
          PUFFS_FLATE_ERROR_INTERNAL_ERROR_INCONSISTENT_HUFFMAN_DECODER_STATE;
      goto exit;
    }
  }
label_3_break:;
exit:
  return status;
}

puffs_flate_status puffs_flate_zlib_decoder_decode(
    puffs_flate_zlib_decoder* self,
    puffs_base_writer1 a_dst,
    puffs_base_reader1 a_src) {
  if (!self) {
    return PUFFS_FLATE_ERROR_BAD_RECEIVER;
  }
  if (self->private_impl.magic != PUFFS_MAGIC) {
    self->private_impl.status = PUFFS_FLATE_ERROR_INITIALIZER_NOT_CALLED;
  }
  if (self->private_impl.status < 0) {
    return self->private_impl.status;
  }
  puffs_flate_status status = PUFFS_FLATE_STATUS_OK;

  uint16_t v_x;
  uint32_t v_checksum;

  uint8_t* b_rptr_src = NULL;
  uint8_t* b_rstart_src = NULL;
  uint8_t* b_rend_src = NULL;
  if (a_src.buf) {
    b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
    b_rstart_src = b_rptr_src;
    size_t len = a_src.buf->wi - a_src.buf->ri;
    puffs_base_limit1* lim;
    for (lim = &a_src.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len && (len > *lim->ptr_to_len)) {
        len = *lim->ptr_to_len;
      }
    }
    b_rend_src = b_rptr_src + len;
  }

  uint32_t coro_susp_point = self->private_impl.c_decode[0].coro_susp_point;
  if (coro_susp_point) {
    v_x = self->private_impl.c_decode[0].v_x;
    v_checksum = self->private_impl.c_decode[0].v_checksum;
  }
  switch (coro_susp_point) {
    PUFFS_COROUTINE_SUSPENSION_POINT(0);

    PUFFS_COROUTINE_SUSPENSION_POINT(1);
    uint16_t t_1;
    if (PUFFS_LIKELY(b_rend_src - b_rptr_src >= 2)) {
      t_1 = puffs_base_load_u16be(b_rptr_src);
      b_rptr_src += 2;
    } else {
      self->private_impl.c_decode[0].scratch = 0;
      PUFFS_COROUTINE_SUSPENSION_POINT(2);
      while (true) {
        if (PUFFS_UNLIKELY(b_rptr_src == b_rend_src)) {
          goto short_read_src;
        }
        uint32_t t_0 = self->private_impl.c_decode[0].scratch & 0xFF;
        self->private_impl.c_decode[0].scratch >>= 8;
        self->private_impl.c_decode[0].scratch <<= 8;
        self->private_impl.c_decode[0].scratch |= ((uint64_t)(*b_rptr_src++))
                                                  << (64 - t_0);
        if (t_0 == 8) {
          t_1 = self->private_impl.c_decode[0].scratch >> (64 - 16);
          break;
        }
        t_0 += 8;
        self->private_impl.c_decode[0].scratch |= ((uint64_t)(t_0));
      }
    }
    v_x = t_1;
    if (((v_x >> 8) & 15) != 8) {
      status = PUFFS_FLATE_ERROR_INVALID_ZLIB_COMPRESSION_METHOD;
      goto exit;
    }
    if ((v_x >> 12) > 7) {
      status = PUFFS_FLATE_ERROR_INVALID_ZLIB_COMPRESSION_WINDOW_SIZE;
      goto exit;
    }
    if ((v_x & 32) != 0) {
      status = PUFFS_FLATE_ERROR_TODO_UNSUPPORTED_ZLIB_PRESET_DICTIONARY;
      goto exit;
    }
    if ((v_x % 31) != 0) {
      status = PUFFS_FLATE_ERROR_INVALID_ZLIB_PARITY_CHECK;
      goto exit;
    }
    PUFFS_COROUTINE_SUSPENSION_POINT(3);
    if (a_src.buf) {
      size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
      a_src.buf->ri += n;
      puffs_base_limit1* lim;
      for (lim = &a_src.limit; lim; lim = lim->next) {
        if (lim->ptr_to_len) {
          *lim->ptr_to_len -= n;
        }
      }
    }
    status =
        puffs_flate_decoder_decode(&self->private_impl.f_dec, a_dst, a_src);
    if (a_src.buf) {
      b_rptr_src = a_src.buf->ptr + a_src.buf->ri;
      size_t len = a_src.buf->wi - a_src.buf->ri;
      puffs_base_limit1* lim;
      for (lim = &a_src.limit; lim; lim = lim->next) {
        if (lim->ptr_to_len && (len > *lim->ptr_to_len)) {
          len = *lim->ptr_to_len;
        }
      }
      b_rend_src = b_rptr_src + len;
    }
    if (status) {
      goto suspend;
    }
    PUFFS_COROUTINE_SUSPENSION_POINT(4);
    uint32_t t_3;
    if (PUFFS_LIKELY(b_rend_src - b_rptr_src >= 4)) {
      t_3 = puffs_base_load_u32be(b_rptr_src);
      b_rptr_src += 4;
    } else {
      self->private_impl.c_decode[0].scratch = 0;
      PUFFS_COROUTINE_SUSPENSION_POINT(5);
      while (true) {
        if (PUFFS_UNLIKELY(b_rptr_src == b_rend_src)) {
          goto short_read_src;
        }
        uint32_t t_2 = self->private_impl.c_decode[0].scratch & 0xFF;
        self->private_impl.c_decode[0].scratch >>= 8;
        self->private_impl.c_decode[0].scratch <<= 8;
        self->private_impl.c_decode[0].scratch |= ((uint64_t)(*b_rptr_src++))
                                                  << (64 - t_2);
        if (t_2 == 24) {
          t_3 = self->private_impl.c_decode[0].scratch >> (64 - 32);
          break;
        }
        t_2 += 8;
        self->private_impl.c_decode[0].scratch |= ((uint64_t)(t_2));
      }
    }
    v_checksum = t_3;
    self->private_impl.c_decode[0].coro_susp_point = 0;
    goto exit;
  }

  goto suspend;
suspend:
  self->private_impl.c_decode[0].coro_susp_point = coro_susp_point;
  self->private_impl.c_decode[0].v_x = v_x;
  self->private_impl.c_decode[0].v_checksum = v_checksum;

exit:
  if (a_src.buf) {
    size_t n = b_rptr_src - (a_src.buf->ptr + a_src.buf->ri);
    a_src.buf->ri += n;
    puffs_base_limit1* lim;
    for (lim = &a_src.limit; lim; lim = lim->next) {
      if (lim->ptr_to_len) {
        *lim->ptr_to_len -= n;
      }
    }
    PUFFS_IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rstart_src);
    PUFFS_IGNORE_POTENTIALLY_UNUSED_VARIABLE(b_rend_src);
  }

  self->private_impl.status = status;
  return status;

short_read_src:
  if (a_src.limit.ptr_to_len) {
    status = PUFFS_FLATE_SUSPENSION_LIMITED_READ;
  } else if (a_src.buf && a_src.buf->closed) {
    status = PUFFS_FLATE_ERROR_UNEXPECTED_EOF;
    goto exit;
  } else {
    status = PUFFS_FLATE_SUSPENSION_SHORT_READ;
  }
  goto suspend;
}
