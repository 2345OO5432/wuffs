// Code generated by running "go generate". DO NOT EDIT.

// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file.

package check

import (
	a "github.com/google/puffs/lang/ast"
	t "github.com/google/puffs/lang/token"
)

var reasons = [...]struct {
	s string
	r reason
}{

	{`"a < b: a < c; c < b"`, func(q *checker, n *a.Assert) error {
		op, xa, xb := parseBinaryOp(n.Condition())
		if op.Key() != t.KeyXBinaryLessThan {
			return errFailed
		}
		// a < c
		xc := argValue(q.tm, n.Args(), "c")
		if xc == nil {
			return errFailed
		}
		if err := proveReasonRequirement(q, t.IDXBinaryLessThan, xa, xc); err != nil {
			return err
		}
		// c < b
		if err := proveReasonRequirement(q, t.IDXBinaryLessThan, xc, xb); err != nil {
			return err
		}
		return nil
	}},

	{`"a < b: a < c; c == b"`, func(q *checker, n *a.Assert) error {
		op, xa, xb := parseBinaryOp(n.Condition())
		if op.Key() != t.KeyXBinaryLessThan {
			return errFailed
		}
		// a < c
		xc := argValue(q.tm, n.Args(), "c")
		if xc == nil {
			return errFailed
		}
		if err := proveReasonRequirement(q, t.IDXBinaryLessThan, xa, xc); err != nil {
			return err
		}
		// c == b
		if err := proveReasonRequirement(q, t.IDXBinaryEqEq, xc, xb); err != nil {
			return err
		}
		return nil
	}},

	{`"a < b: a == c; c < b"`, func(q *checker, n *a.Assert) error {
		op, xa, xb := parseBinaryOp(n.Condition())
		if op.Key() != t.KeyXBinaryLessThan {
			return errFailed
		}
		// a == c
		xc := argValue(q.tm, n.Args(), "c")
		if xc == nil {
			return errFailed
		}
		if err := proveReasonRequirement(q, t.IDXBinaryEqEq, xa, xc); err != nil {
			return err
		}
		// c < b
		if err := proveReasonRequirement(q, t.IDXBinaryLessThan, xc, xb); err != nil {
			return err
		}
		return nil
	}},

	{`"a < b: a < c; c <= b"`, func(q *checker, n *a.Assert) error {
		op, xa, xb := parseBinaryOp(n.Condition())
		if op.Key() != t.KeyXBinaryLessThan {
			return errFailed
		}
		// a < c
		xc := argValue(q.tm, n.Args(), "c")
		if xc == nil {
			return errFailed
		}
		if err := proveReasonRequirement(q, t.IDXBinaryLessThan, xa, xc); err != nil {
			return err
		}
		// c <= b
		if err := proveReasonRequirement(q, t.IDXBinaryLessEq, xc, xb); err != nil {
			return err
		}
		return nil
	}},

	{`"a < b: a <= c; c < b"`, func(q *checker, n *a.Assert) error {
		op, xa, xb := parseBinaryOp(n.Condition())
		if op.Key() != t.KeyXBinaryLessThan {
			return errFailed
		}
		// a <= c
		xc := argValue(q.tm, n.Args(), "c")
		if xc == nil {
			return errFailed
		}
		if err := proveReasonRequirement(q, t.IDXBinaryLessEq, xa, xc); err != nil {
			return err
		}
		// c < b
		if err := proveReasonRequirement(q, t.IDXBinaryLessThan, xc, xb); err != nil {
			return err
		}
		return nil
	}},

	{`"a <= b: a <= c; c <= b"`, func(q *checker, n *a.Assert) error {
		op, xa, xb := parseBinaryOp(n.Condition())
		if op.Key() != t.KeyXBinaryLessEq {
			return errFailed
		}
		// a <= c
		xc := argValue(q.tm, n.Args(), "c")
		if xc == nil {
			return errFailed
		}
		if err := proveReasonRequirement(q, t.IDXBinaryLessEq, xa, xc); err != nil {
			return err
		}
		// c <= b
		if err := proveReasonRequirement(q, t.IDXBinaryLessEq, xc, xb); err != nil {
			return err
		}
		return nil
	}},

	{`"a <= b: a <= c; c == b"`, func(q *checker, n *a.Assert) error {
		op, xa, xb := parseBinaryOp(n.Condition())
		if op.Key() != t.KeyXBinaryLessEq {
			return errFailed
		}
		// a <= c
		xc := argValue(q.tm, n.Args(), "c")
		if xc == nil {
			return errFailed
		}
		if err := proveReasonRequirement(q, t.IDXBinaryLessEq, xa, xc); err != nil {
			return err
		}
		// c == b
		if err := proveReasonRequirement(q, t.IDXBinaryEqEq, xc, xb); err != nil {
			return err
		}
		return nil
	}},

	{`"a <= b: a == c; c <= b"`, func(q *checker, n *a.Assert) error {
		op, xa, xb := parseBinaryOp(n.Condition())
		if op.Key() != t.KeyXBinaryLessEq {
			return errFailed
		}
		// a == c
		xc := argValue(q.tm, n.Args(), "c")
		if xc == nil {
			return errFailed
		}
		if err := proveReasonRequirement(q, t.IDXBinaryEqEq, xa, xc); err != nil {
			return err
		}
		// c <= b
		if err := proveReasonRequirement(q, t.IDXBinaryLessEq, xc, xb); err != nil {
			return err
		}
		return nil
	}},

	{`"a < (b + c): a < c; 0 <= b"`, func(q *checker, n *a.Assert) error {
		op, xa, t0 := parseBinaryOp(n.Condition())
		if op.Key() != t.KeyXBinaryLessThan {
			return errFailed
		}
		op, xb, xc := parseBinaryOp(t0)
		if op.Key() != t.KeyXBinaryPlus {
			return errFailed
		}
		// a < c
		if err := proveReasonRequirement(q, t.IDXBinaryLessThan, xa, xc); err != nil {
			return err
		}
		// 0 <= b
		if err := proveReasonRequirement(q, t.IDXBinaryLessEq, zeroExpr, xb); err != nil {
			return err
		}
		return nil
	}},

	{`"a < (b + c): a < (b0 + c0); b0 <= b; c0 <= c"`, func(q *checker, n *a.Assert) error {
		op, xa, t0 := parseBinaryOp(n.Condition())
		if op.Key() != t.KeyXBinaryLessThan {
			return errFailed
		}
		op, xb, xc := parseBinaryOp(t0)
		if op.Key() != t.KeyXBinaryPlus {
			return errFailed
		}
		// a < (b0 + c0)
		xb0 := argValue(q.tm, n.Args(), "b0")
		if xb0 == nil {
			return errFailed
		}
		xc0 := argValue(q.tm, n.Args(), "c0")
		if xc0 == nil {
			return errFailed
		}
		t1 := a.NewExpr(a.FlagsTypeChecked, t.IDXBinaryPlus, 0, xb0.Node(), nil, xc0.Node(), nil)
		if err := proveReasonRequirement(q, t.IDXBinaryLessThan, xa, t1); err != nil {
			return err
		}
		// b0 <= b
		if err := proveReasonRequirement(q, t.IDXBinaryLessEq, xb0, xb); err != nil {
			return err
		}
		// c0 <= c
		if err := proveReasonRequirement(q, t.IDXBinaryLessEq, xc0, xc); err != nil {
			return err
		}
		return nil
	}},

	{`"(a + b) <= c: a <= (c - b)"`, func(q *checker, n *a.Assert) error {
		op, t0, xc := parseBinaryOp(n.Condition())
		if op.Key() != t.KeyXBinaryLessEq {
			return errFailed
		}
		op, xa, xb := parseBinaryOp(t0)
		if op.Key() != t.KeyXBinaryPlus {
			return errFailed
		}
		// a <= (c - b)
		t1 := a.NewExpr(a.FlagsTypeChecked, t.IDXBinaryMinus, 0, xc.Node(), nil, xb.Node(), nil)
		if err := proveReasonRequirement(q, t.IDXBinaryLessEq, xa, t1); err != nil {
			return err
		}
		return nil
	}},
}
