// Copyright 2017 The Wuffs Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

packageid "gif "

pub error "bad block"
pub error "bad extension label"
pub error "bad header"
pub error "bad literal width"

pub struct decoder?(
	width base.u32,
	height base.u32,

	// Call sequence states:
	//  - 0: initial state.
	//  - 1: image config decoded, including the first frame's bounds, but not
	//       the first frame's pixels.
	//  - 2: frame decoded.
	//
	// Call sequence state transitions:
	//  - 0 -> 1: via decode_config.
	//  - 1 -> 2: via decode_frame.
	//  - 2 -> 2: via decode_frame.
	call_sequence base.u8,

	end_of_data base.bool,
	previous_lzw_decode_ended_abruptly base.bool,
	previous_use_global_palette base.bool,

	background_color_index base.u8,

	interlace base.bool,

	// Absent an ANIMEXTS1.0 or NETSCAPE2.0 extension, the implicit number of
	// animation loops is 1.
	seen_num_loops base.bool,
	num_loops base.u32 = 1,

	frame_rect base.rect_ie_u32,

	uncompressed_ri base.u32[..4096],
	uncompressed_wi base.u32[..4096],
	uncompressed array[4096] base.u8,

	// palettes[0] and palettes[1] are the Global and Local Color Table.
	palettes array[2] array[4 * 256] base.u8,

	lzw lzw_decoder,
)

// TODO: should dst be an nptr instead of a ptr?
pub func decoder.decode_config?(dst ptr base.image_config, src base.io_reader)() {
	if this.call_sequence >= 1 {
		return error "invalid call sequence"
	}
	this.decode_header?(src:in.src)
	this.decode_lsd?(src:in.src)
	this.decode_up_to_id_part1?(src:in.src)

	// TODO: if this.end_of_data, return an error and/or set dst to zero?

	// TODO: rename initialize to set?
	//
	// TODO: a Wuffs (not just C) name for the
	// WUFFS_BASE__PIXEL_FORMAT__BGRA_NONPREMUL_INDEXED magic pixfmt constant.
	in.dst.initialize!(pixfmt:0x22088888, pixsub:0,
		width:this.width, height:this.height, num_loops:this.num_loops)

	this.call_sequence = 1
}

pub func decoder.decode_frame?(ib ptr base.image_buffer, dst base.io_writer, src base.io_reader)() {
	if this.call_sequence == 0 {
		return error "invalid call sequence"
	}

	if not this.end_of_data {
		if this.call_sequence == 1 {
			// TODO: memset dst's pixel_buffer (and palette) to zero?
			this.call_sequence = 2
		} else {
			this.decode_up_to_id_part1?(src:in.src)
		}
	}

	// This is a new "if", not an "else", because calling
	// this.decode_up_to_id_part1 can modify this.end_of_data.
	if this.end_of_data {
		while true {
			yield suspension "end of data"
		}
	}

	this.decode_id_part1?(ib:in.ib, dst:in.dst, src:in.src)
}

pub func decoder.decode_up_to_id_part1?(src base.io_reader)() {
	while true {
		var block_type base.u8 = in.src.read_u8?()
		if block_type == 0x21 {  // The spec calls 0x21 the "Extension Introducer".
			this.decode_extension?(src:in.src)
		} else if block_type == 0x2C {  // The spec calls 0x2C the "Image Separator".
			this.decode_id_part0?(src:in.src)
			break
		} else if block_type == 0x3B {  // The spec calls 0x3B the "Trailer".
			this.end_of_data = true
			break
		} else {
			return error "bad block"
		}
	}
}

// decode_header reads either "GIF87a" or "GIF89a".
//
// See the spec section 17 "Header" on page 7.
pri func decoder.decode_header?(src base.io_reader)() {
	var c array[6] base.u8
	var i base.u32
	while i < 6 {
		c[i] = in.src.read_u8?()
		i += 1
	}
	if (c[0] != 0x47) or (c[1] != 0x49) or (c[2] != 0x46) or (c[3] != 0x38) or
		((c[4] != 0x37) and (c[4] != 0x39)) or (c[5] != 0x61) {
		return error "bad header"
	}
}

// decode_lsd reads the Logical Screen Descriptor.
//
// See the spec section 18 "Logical Screen Descriptor" on page 8.
pri func decoder.decode_lsd?(src base.io_reader)() {
	var c array[7] base.u8
	var i base.u32
	while i < 7 {
		c[i] = in.src.read_u8?()
		i += 1
	}
	// TODO: use read_u16le.
	this.width = (c[0] as base.u32) | ((c[1] as base.u32) << 8)
	this.height = (c[2] as base.u32) | ((c[3] as base.u32) << 8)
	var flags base.u8 = c[4]
	this.background_color_index = c[5]

	// Read the optional Global Color Table.
	if (flags & 0x80) != 0 {
		var num_palette_entries base.u32[..256] = (1 as base.u32) << (1 + (flags & 0x07))
		i = 0
		while i < num_palette_entries {
			assert i < 256 via "a < b: a < c; c <= b"(c:num_palette_entries)
			// Convert from RGB to BGRA.
			this.palettes[0][(4 * i) + 2] = in.src.read_u8?()
			this.palettes[0][(4 * i) + 1] = in.src.read_u8?()
			this.palettes[0][(4 * i) + 0] = in.src.read_u8?()
			this.palettes[0][(4 * i) + 3] = 0xFF
			i += 1
		}
	}
}

// decode_extension reads an extension. The Extension Introducer byte has
// already been read.
//
// See the spec:
//  - section 23 "Graphic Control Extension" on page 15.
//  - section 24 "Comment Extension" on page 17.
//  - section 25 "Plain Text Extension" on page 18.
//  - section 26 "Application Extension" on page 21.
pri func decoder.decode_extension?(src base.io_reader)() {
	var label base.u8 = in.src.read_u8?()
	if label == 0xF9 {  // The spec calls 0xF9 the "Graphic Control Label".
		// TODO.
	} else if label == 0xFF {  // The spec calls 0xFF the "Application Extension Label".
		this.decode_ae?(src:in.src)
		return
	}
	// We skip over all other extensions, including 0x01 "Plain Text Label" and
	// 0xFE "Comment Label".
	this.skip_blocks?(src:in.src)
}

pri func decoder.skip_blocks?(src base.io_reader)() {
	while true {
		var block_size base.u8 = in.src.read_u8?()
		if block_size == 0 {
			return
		}
		in.src.skip32?(n:block_size as base.u32)
	}
}

// animexts1dot0 is "ANIMEXTS1.0" as bytes.
pri const animexts1dot0 array[11] base.u8 = $(
	0x41, 0x4E, 0x49, 0x4D, 0x45, 0x58, 0x54, 0x53, 0x31, 0x2E, 0x30,
)

// netscape2dot0 is "NETSCAPE2.0" as bytes.
pri const netscape2dot0 array[11] base.u8 = $(
	0x4E, 0x45, 0x54, 0x53, 0x43, 0x41, 0x50, 0x45, 0x32, 0x2E, 0x30,
)

// decode_ae reads an Application Extension.
pri func decoder.decode_ae?(src base.io_reader)() {
	// This "while true" always executes exactly once, as it ends with a
	// "break", but using "break"s throughout simplifies the control flow.
	while true {
		var c base.u8
		var block_size base.u8 = in.src.read_u8?()
		if block_size == 0 {
			return
		}

		// Look only for an 11 byte "ANIMEXTS1.0" or "NETSCAPE2.0" extension,
		// as per:
		//  - http://www.vurdalakov.net/misc/gif/animexts-looping-application-extension
		//  - http://www.vurdalakov.net/misc/gif/netscape-looping-application-extension
		if block_size != 11 {
			in.src.skip32?(n:block_size as base.u32)
			break
		}
		var not_animexts base.bool
		var not_netscape base.bool
		block_size = 0  // Re-purpose the block_size variable as a counter.
		while block_size < 11 {
			c = in.src.read_u8?()
			not_animexts = not_animexts or (c != animexts1dot0[block_size])
			not_netscape = not_netscape or (c != netscape2dot0[block_size])
			block_size += 1
		}
		if not_animexts and not_netscape {
			break
		}

		// Those 11 bytes should be followed by 0x03, 0x01 and then the loop
		// count.
		block_size = in.src.read_u8?()
		if block_size != 3 {
			in.src.skip32?(n:block_size as base.u32)
			break
		}
		c = in.src.read_u8?()
		if c != 0x01 {
			in.src.skip32?(n:2)
			break
		}
		this.num_loops = in.src.read_u16le?() as base.u32
		this.seen_num_loops = true

		// A loop count of N, in the wire format, actually means "repeat N
		// times after the first play", if N is positive. A zero N means to
		// loop forever. Playing the frames exactly once is denoted by the
		// *absence* of this NETSCAPE2.0 application extension.
		//
		// For example, if there are four frames: A, B, C, D, and N is 2, then
		// each frame is actually played N+1 or 3 times: ABCDABCDABCD.
		//
		// Thus, we increment N if it is positive. The comparison against
		// 0xFFFF will never fail, but is necessary for the overflow checker.
		if (0 < this.num_loops) and (this.num_loops <= 0xFFFF) {
			this.num_loops += 1
		}

		break
	}
	this.skip_blocks?(src:in.src)
}

// decode_id_partX reads an Image Descriptor. The Image Separator byte has
// already been read.
//
// See the spec section 20 "Image Descriptor" on page 11.
//
// The code is split into two parts because determining the overall image's
// width and height also requires decoding the first frame's bounds (but
// doesn't require decoding the first frame's pixels).
pri func decoder.decode_id_part0?(src base.io_reader)() {
	var frame_x base.u32 = in.src.read_u16le?() as base.u32
	var frame_y base.u32 = in.src.read_u16le?() as base.u32
	this.frame_rect.set_min_inclusive_x!(x:frame_x)
	this.frame_rect.set_min_inclusive_y!(y:frame_y)
	frame_x ~mod+= in.src.read_u16le?() as base.u32
	frame_y ~mod+= in.src.read_u16le?() as base.u32
	this.frame_rect.set_max_exclusive_x!(x:frame_x)
	this.frame_rect.set_max_exclusive_y!(y:frame_y)

	// Set the image's overall width and height to be the maximum of the
	// nominal image width and height (given in the Logical Screen Descriptor)
	// and the bottom right extent of the first frame. See
	// test/data/artificial/gif-frame-out-of-bounds.gif.make-artificial.txt for
	// more discussion.
	if this.call_sequence == 0 {
		this.width = this.width.max(x:frame_x)
		this.height = this.height.max(x:frame_y)
	}
}

// TODO: dst should be a ptr base.image_buffer, not a base.io_writer.
pri func decoder.decode_id_part1?(ib ptr base.image_buffer, dst base.io_writer, src base.io_reader)() {
	// TODO: use this.interlace.
	var flags base.u8 = in.src.read_u8?()
	this.interlace = (flags & 0x40) != 0

	// Read the optional Local Color Table.
	var use_local_palette base.bool = (flags & 0x80) != 0
	if use_local_palette {
		var num_palette_entries base.u32[..256] = (1 as base.u32) << (1 + (flags & 0x07))
		var i base.u32
		while i < num_palette_entries {
			assert i < 256 via "a < b: a < c; c <= b"(c:num_palette_entries)
			// Convert from RGB to BGRA.
			this.palettes[1][(4 * i) + 2] = in.src.read_u8?()
			this.palettes[1][(4 * i) + 1] = in.src.read_u8?()
			this.palettes[1][(4 * i) + 0] = in.src.read_u8?()
			this.palettes[1][(4 * i) + 3] = 0xFF
			i += 1
		}
	}

	// Other GIF implementations accept GIF files that aren't completely spec
	// compliant. For example, the test/data/gifplayer-muybridge.gif file
	// (created by the gifsicle program) is accepted by other GIF decoders.
	// However, in that file, frame #61's embedded LZW data is truncated,
	// finishing with only 8 of the 9 bits required of the LZW end code. The
	// end code itself, 0x81, is representable in only 8 bits, but the number
	// of bits for the decoder to read has ticked over from 8 to 9 just before
	// that end code is encountered.
	//
	// To accomodate such malformed GIFs, we detect when the previous frame's
	// LZW decoding ended abruptly. The previous LZW decode 'works', in that it
	// decodes as much pixel data as is available, but without seeing that end
	// code (i.e. returning the "ok" status code), the LZW decoder is stuck in
	// a coroutine-in-progress lzw_decoder.decode call, still waiting for that
	// end code. To cancel that coroutine, we reset the LZW decoder.
	if this.previous_lzw_decode_ended_abruptly {
		this.lzw.reset()
	}

	var lw base.u8 = in.src.read_u8?()
	if (lw < 2) or (8 < lw) {
		return error "bad literal width"
	}
	this.lzw.set_literal_width!(lw:lw as base.u32)

	this.previous_lzw_decode_ended_abruptly = true
	while true {
		var block_size base.u64 = in.src.read_u8?() as base.u64
		if block_size == 0 {
			break
		}
		this.previous_lzw_decode_ended_abruptly = true

		while:inner true {
			var w base.io_writer
			io_bind (in.src, w) {
				w.set!(s:this.uncompressed[this.uncompressed_wi:])
				// TODO: enforce that calling r.set_limit has a precondition
				// that r.is_bound(), and that you can't suspend inside an
				// io_bind? Otherwise, the cgen implementation becomes more
				// complicated if we must save and re-apply limits.
				//
				// Should calling r.set_mark also require r.is_bound()?
				in.src.set_limit!(l:block_size)
				in.src.set_mark!()
				var z base.status = try this.lzw.decode?(dst:w, src:in.src)
				this.uncompressed_wi = 4096 - (w.available().min(x:4096) as base.u32)
				block_size ~sat-= in.src.since_mark().length()
			}

			if z.is_ok() or (z == suspension "short write") {
				// Pass through the uncompressed bytes to in.dst.
				//
				// TODO: in.dst should be a ptr base.image_buffer and we should
				// composite the pixels instead of just copying them.
				//
				// TODO: delete the write_to_ib_instead_of_w hack. It should
				// always be true.
				var write_to_ib_instead_of_w base.bool = false
				if not write_to_ib_instead_of_w {
					while this.uncompressed_ri < this.uncompressed_wi {
						var pass_through slice base.u8 = this.uncompressed[this.uncompressed_ri:this.uncompressed_wi]
						var n_copied base.u64 = in.dst.copy_from_slice!(s:pass_through)
						if n_copied == pass_through.length() {
							this.uncompressed_ri = 0
							this.uncompressed_wi = 0
							break
						}
						this.uncompressed_ri = (this.uncompressed_ri + ((n_copied & 4095) as base.u32)) & 4095
						// TODO: "closed for writes" instead?
						yield suspension "short write"
					}

				} else {
					// TODO: don't assume a packed pixel format.
					var tab table base.u8 = in.ib.plane(p:0)
					if tab.width() == tab.stride() {
						var pixel_data slice base.u8 = tab.linearize()
						if pixel_data.length() == 0 {
							// TODO.
						}
					} else {
						// TODO.
					}
				}

				if z == suspension "short write" {
					continue:inner
				}
				// TODO: check that block_size is zero?
				this.previous_lzw_decode_ended_abruptly = false
				break:inner
			}
			if (block_size == 0) and (z == suspension "short read") {
				break:inner
			}
			yield z
		}
	}

	var palette slice base.u8
	if use_local_palette {
		palette = this.palettes[1][:]
	} else if not this.previous_use_global_palette {
		// This frame uses the global palette but the previous one didn't.
		palette = this.palettes[0][:]
	} else {
		// Both this frame and the previous one used the global palette. No
		// palette update is necessary.
	}
	// TODO: duration isn't always 0.
	in.ib.update!(dirty_rect:this.frame_rect, duration:0, palette:palette)

	this.previous_use_global_palette = not use_local_palette
}
