// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file.

// TODO: some mechanism for fixing the error code's value, such as a trailing
// "= 100", to maintain API stability.
pub error "bad GIF image"

pub struct lzw_decoder?(
	literal_width u32[2..8] = 8,
	stack[4096] u8,
	suffixes[4096] u8,
	prefixes[4096] u16,
)

pub func lzw_decoder.decode?(dst ptr buf1, src ptr buf1, src_final bool)() {
	// These variables don't change over the lifetime of this func.
	var clear_code u32[4..256] = (1 as u32) << this.literal_width
	var end_code u32[5..257] = clear_code + 1

	// These variables do change.
	var save_code u32[..4095] = end_code
	var width u32[..12] = this.literal_width + 1

	// These variables yield src's bits in Least Significant Bits order.
	var bits u32
	var n_bits u32

	while true,
		pre n_bits < 8,
	{
		assert n_bits < (width + 8) via "a < (b + c): a < c; 0 <= b"()
		while n_bits < width,
			inv n_bits < (width + 8),
			post n_bits >= width,
		{
			assert n_bits < 12 via "a < b: a < c; c <= b"(c:width)
			bits |= (in.src.read_u8?() as u32) << n_bits  // TODO: read_u8 should take src_final.
			n_bits += 8
		}
		var code u32[..4095] = bits.low_bits(n:width)
		bits >>= width
		n_bits -= width

		if code < clear_code {
			break
		} else if code == clear_code {
			save_code = end_code
			width = this.literal_width + 1
			continue
		} else if code == end_code {
			return
		} else if code <= save_code {
			return
		} else {
			return error "bad GIF image"
		}

		// TODO: implement.
		break
	}
}
