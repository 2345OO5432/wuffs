// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file.

// The flate spec is https://www.ietf.org/rfc/rfc1951.txt

packageid "flte"

pub error "bad Huffman code (over-subscribed)"
pub error "bad Huffman code (under-subscribed)"
pub error "bad Huffman code length count"
pub error "bad Huffman code length repetition"
pub error "bad Huffman code"
pub error "bad Huffman minimum code length"
pub error "bad distance code count"
pub error "bad flate block"
pub error "bad literal/length code count"
pub error "inconsistent stored block length"
pub error "internal error: inconsistent Huffman decoder state"
pub error "internal error: inconsistent n_bits"
pub error "missing end-of-block code"
pub error "no Huffman codes"

// The next two tables were created by script/print-flate-magic-numbers.go.
//
// The u32 values' meanings are the same as the decoder.huffs u32 values. In
// particular, bit 29 indicates a base number + extra bits, bits 23-8 are the
// base number and bits 7-4 are the number of those extra bits.
//
// Some trailing elements are 0x08000000. Bit 27 indicates an invalid value.

pri const lcode_magic_numbers[32] u32 = $(
	0x20000300, 0x20000400, 0x20000500, 0x20000600, 0x20000700, 0x20000800, 0x20000900, 0x20000A00,
	0x20000B10, 0x20000D10, 0x20000F10, 0x20001110, 0x20001320, 0x20001720, 0x20001B20, 0x20001F20,
	0x20002330, 0x20002B30, 0x20003330, 0x20003B30, 0x20004340, 0x20005340, 0x20006340, 0x20007340,
	0x20008350, 0x2000A350, 0x2000C350, 0x2000E350, 0x20010200, 0x08000000, 0x08000000, 0x08000000,
)

pri const dcode_magic_numbers[32] u32 = $(
	0x20000100, 0x20000200, 0x20000300, 0x20000400, 0x20000510, 0x20000710, 0x20000920, 0x20000D20,
	0x20001130, 0x20001930, 0x20002140, 0x20003140, 0x20004150, 0x20006150, 0x20008160, 0x2000C160,
	0x20010170, 0x20018170, 0x20020180, 0x20030180, 0x20040190, 0x20060190, 0x200801A0, 0x200C01A0,
	0x201001B0, 0x201801B0, 0x202001C0, 0x203001C0, 0x204001D0, 0x206001D0, 0x08000000, 0x08000000,
)

pub struct decoder?(
	// These fields yield src's bits in Least Significant Bits order.
	bits u32,
	n_bits u32,

	// huffs and n_huffs_bits are the lookup tables for Huffman decodings.
	//
	// There are up to 2 Huffman decoders active at any one time. As per this
	// package's README.md:
	//  - huffs[0] is used for clcode and lcode.
	//  - huffs[1] is used for dcode.
	//
	// The initial table key is the low n_huffs_bits of the decoder.bits field.
	// Keys longer than 9 bits require a two step lookup, the first step
	// examines the low 9 bits, the second step examines the remaining bits.
	// Two steps are required at most, as keys are at most 15 bits long.
	//
	// Using decoder.bits's low n_huffs_bits as a table key is valid even if
	// decoder.n_bits is less than n_huffs_bits, because the immediate next
	// step after indexing the table by the key is to compare decoder.n_bits to
	// the table value's number of decoder.bits to consume. If it compares
	// less, then more source bytes are read and the table lookup re-tried.
	//
	// The table value is:
	//  - bit     31 indicates a redirect to another part of the table.
	//  - bit     30 indicates the symbol is a literal.
	//  - bit     29 indicates the symbol is a base number + extra bits.
	//  - bit     28 indicates the symbol is the end-of-block.
	//  - bit     27 indicates an invalid value.
	//  - bits 26-24 are zero.
	//  - bits 23- 8 is the redirect offset, literal (in bits 15-8) or base number.
	//  - bits  7- 4 is the redirected table's bits or number of extra bits.
	//  - bits  3- 0 are the number of decoder.bits to consume.
	//
	// Exactly one of the eight bits 31-24 should be set.
	//
	// TODO: replace the magic "big enough" 1234 with something more
	// principled, perhaps discovered via an exhaustive search.
	huffs[2][1234] u32,
	n_huffs_bits[2] u32[..9],

	// code_lengths is used to pass out-of-band data to init_huff.
	//
	// code_lengths[in.n_codes0 + i] holds the number of bits in the i'th code.
	code_lengths[320] u8[..15],
)

pub func decoder.decode?(dst writer1, src reader1)() {
	var final u32
	while final == 0 {
		while this.n_bits < 3,
			post this.n_bits >= 3,
		{
			this.bits |= (in.src.read_u8?() as u32) << this.n_bits
			this.n_bits += 8
		}
		final = this.bits & 0x01
		var type u32 = (this.bits >> 1) & 0x03
		this.bits >>= 3
		this.n_bits -= 3

		if type == 0 {
			this.decode_uncompressed?(dst:in.dst, src:in.src)
			continue
		} else if type == 1 {
			this.init_fixed_huffman?()
		} else if type == 2 {
			this.init_dynamic_huffman?(src:in.src)
		} else {
			return error "bad flate block"
		}
		this.decode_huffman?(dst:in.dst, src:in.src)
	}
}

// decode_uncompressed decodes an uncompresed block as per the RFC section
// 3.2.4.
pri func decoder.decode_uncompressed?(dst writer1, src reader1)() {
	if this.n_bits >= 8 {
		return error "internal error: inconsistent n_bits"
	}
	this.n_bits = 0

	var n u32 = in.src.read_u32le?()
	if (n.low_bits(n:16) + n.high_bits(n:16)) != 0xFFFF {
		return error "inconsistent stored block length"
	}
	in.dst.copy_from32?(r:in.src, n:n.low_bits(n:16))
}

pri func decoder.decode_huffman?(dst writer1, src reader1)() {
	var bits u32 = this.bits
	var n_bits u32 = this.n_bits

	var table_entry u32
	var table_entry_n_bits u32[..15]
	var lmask u32[..511] = ((1 as u32) << this.n_huffs_bits[0]) - 1
	var dmask u32[..511] = ((1 as u32) << this.n_huffs_bits[1]) - 1
	while true {
		// Decode an lcode symbol from H-L.
		while true {
			table_entry = this.huffs[0][bits & lmask]
			table_entry_n_bits = table_entry & 0x0F
			if n_bits >= table_entry_n_bits {
				bits >>= table_entry_n_bits
				n_bits -= table_entry_n_bits
				break
			}
			assert n_bits < 15 via "a < b: a < c; c <= b"(c:table_entry_n_bits)
			bits |= (in.src.read_u8?() as u32) << n_bits
			n_bits += 8
		}
		// Check for a redirect.
		if (table_entry >> 31) != 0 {
			var redir_top u32[..0xFFFF] = (table_entry >> 8) & 0xFFFF
			var redir_mask u32[..0x7FFF] = ((1 as u32) << ((table_entry >> 4) & 0x0F)) - 1
			while true {
				if (redir_top + (bits & redir_mask)) >= 1234 {
					return error "internal error: inconsistent Huffman decoder state"
				}
				table_entry = this.huffs[0][redir_top + (bits & redir_mask)]
				table_entry_n_bits = table_entry & 0x0F
				if n_bits >= table_entry_n_bits {
					bits >>= table_entry_n_bits
					n_bits -= table_entry_n_bits
					break
				}
				assert n_bits < 15 via "a < b: a < c; c <= b"(c:table_entry_n_bits)
				bits |= (in.src.read_u8?() as u32) << n_bits
				n_bits += 8
			}
			if (table_entry >> 31) != 0 {
				return error "internal error: inconsistent Huffman decoder state"
			}
		}

		if (table_entry >> 30) != 0 {
			// Literal.
			in.dst.write_u8?(x:(table_entry >> 8) & 0xFF)
			continue
		} else if (table_entry >> 29) != 0 {
			// No-op; code continues past the if-else chain.
		} else if (table_entry >> 28) != 0 {
			// End of block.
			break
		} else if (table_entry >> 24) == 0x08 {
			return error "bad Huffman code"
		} else {
			return error "internal error: inconsistent Huffman decoder state"
		}

		// length = base number + extra bits.
		var length u32 = (table_entry >> 8) & 0xFFFF
		// TODO: this if shouldn't be necessary.
		if length > 0xFFFF {
			return error "internal error: inconsistent Huffman decoder state"
		}
		table_entry_n_bits = (table_entry >> 4) & 0x0F
		while n_bits < table_entry_n_bits,
			inv length <= 0xFFFF,
			post n_bits >= table_entry_n_bits,
		{
			assert n_bits < 15 via "a < b: a < c; c <= b"(c:table_entry_n_bits)
			bits |= (in.src.read_u8?() as u32) << n_bits
			n_bits += 8
		}
		length += bits.low_bits(n:table_entry_n_bits)
		bits >>= table_entry_n_bits
		n_bits -= table_entry_n_bits

		// Decode a dcode symbol from H-D.
		while true {
			table_entry = this.huffs[1][bits & dmask]
			table_entry_n_bits = table_entry & 15
			if n_bits >= table_entry_n_bits {
				bits >>= table_entry_n_bits
				n_bits -= table_entry_n_bits
				break
			}
			assert n_bits < 15 via "a < b: a < c; c <= b"(c:table_entry_n_bits)
			bits |= (in.src.read_u8?() as u32) << n_bits
			n_bits += 8
		}
		// Check for a redirect.
		if (table_entry >> 31) != 0 {
			redir_top = (table_entry >> 8) & 0xFFFF
			redir_mask = ((1 as u32) << ((table_entry >> 4) & 0x0F)) - 1
			while true {
				if (redir_top + (bits & redir_mask)) >= 1234 {
					return error "internal error: inconsistent Huffman decoder state"
				}
				table_entry = this.huffs[1][redir_top + (bits & redir_mask)]
				table_entry_n_bits = table_entry & 0x0F
				if n_bits >= table_entry_n_bits {
					bits >>= table_entry_n_bits
					n_bits -= table_entry_n_bits
					break
				}
				assert n_bits < 15 via "a < b: a < c; c <= b"(c:table_entry_n_bits)
				bits |= (in.src.read_u8?() as u32) << n_bits
				n_bits += 8
			}
			if (table_entry >> 31) != 0 {
				return error "internal error: inconsistent Huffman decoder state"
			}
		}

		// For H-D, all symbols should be base number + extra bits.
		if (table_entry >> 24) != 0x20 {
			if (table_entry >> 24) == 0x08 {
				return error "bad Huffman code"
			}
			return error "internal error: inconsistent Huffman decoder state"
		}

		// distance = base number + extra bits.
		var distance u32 = (table_entry >> 8) & 0xFFFF
		// TODO: this if shouldn't be necessary.
		if distance > 0xFFFF {
			return error "internal error: inconsistent Huffman decoder state"
		}
		table_entry_n_bits = (table_entry >> 4) & 0x0F
		while n_bits < table_entry_n_bits,
			inv distance <= 0xFFFF,
			post n_bits >= table_entry_n_bits,
		{
			assert n_bits < 15 via "a < b: a < c; c <= b"(c:table_entry_n_bits)
			bits |= (in.src.read_u8?() as u32) << n_bits
			n_bits += 8
		}
		distance += bits.low_bits(n:table_entry_n_bits)
		bits >>= table_entry_n_bits
		n_bits -= table_entry_n_bits

		// TODO: copy_history32 should also take some notion of how much of dst
		// is valid. When copying from a distance greater than that, we also
		// need to keep a sliding window of previous history.
		in.dst.copy_history32?(distance:distance, length:length)
	}

	this.bits = bits
	this.n_bits = n_bits
}

// init_fixed_huffman initializes this.huffs as per the RFC section 3.2.6.
pri func decoder.init_fixed_huffman?()() {
	var i u32
	while i < 144 {
		this.code_lengths[i] = 8
		i += 1
	}
	while i < 256 {
		this.code_lengths[i] = 9
		i += 1
	}
	while i < 280 {
		this.code_lengths[i] = 7
		i += 1
	}
	while i < 288 {
		this.code_lengths[i] = 8
		i += 1
	}
	while i < 320 {
		this.code_lengths[i] = 5
		i += 1
	}
	this.init_huff?(which:0, n_codes0:0, n_codes1:288, base_symbol:257)
	this.init_huff?(which:1, n_codes0:288, n_codes1:320, base_symbol:0)
}

// init_dynamic_huffman initializes this.huffs as per the RFC section 3.2.7.
pri func decoder.init_dynamic_huffman?(src reader1)() {
	var bits u32 = this.bits
	var n_bits u32 = this.n_bits
	while n_bits < 14,
		post n_bits >= 14,
	{
		bits |= (in.src.read_u8?() as u32) << n_bits
		n_bits += 8
	}
	var n_lit u32[257..288] = bits.low_bits(n:5) + 257
	if n_lit > 286 {
		return error "bad literal/length code count"
	}
	bits >>= 5
	var n_dist u32[1..32] = bits.low_bits(n:5) + 1
	if n_dist > 30 {
		return error "bad distance code count"
	}
	bits >>= 5
	var n_clen u32[4..19] = bits.low_bits(n:4) + 4
	bits >>= 4
	n_bits -= 14

	// Read the clcode Huffman table: H-CL.
	var i u32
	while i < n_clen {
		while n_bits < 3,
			inv i < n_clen,
			post n_bits >= 3,
		{
			bits |= (in.src.read_u8?() as u32) << n_bits
			n_bits += 8
		}
		assert i < 19 via "a < b: a < c; c <= b"(c:n_clen)
		this.code_lengths[code_order[i]] = (bits & 0x07) as u8
		bits >>= 3
		n_bits -= 3
		i += 1
	}
	while i < 19 {
		this.code_lengths[code_order[i]] = 0
		i += 1
	}
	this.init_huff?(which:0, n_codes0:0, n_codes1:19, base_symbol:0xFFF)

	// Decode the code lengths for the next two Huffman tables.
	var mask u32[..511] = ((1 as u32) << this.n_huffs_bits[0]) - 1
	i = 0
	while i < (n_lit + n_dist) {
		assert i < (288 + 32) via "a < (b + c): a < (b0 + c0); b0 <= b; c0 <= c"(b0:n_lit, c0:n_dist)

		// Decode a clcode symbol from H-CL.
		var table_entry u32
		while true,
			inv i < 320,
		{
			table_entry = this.huffs[0][bits & mask]
			var table_entry_n_bits u32[..15] = table_entry & 15
			if n_bits >= table_entry_n_bits {
				bits >>= table_entry_n_bits
				n_bits -= table_entry_n_bits
				break
			}
			assert n_bits < 15 via "a < b: a < c; c <= b"(c:table_entry_n_bits)
			bits |= (in.src.read_u8?() as u32) << n_bits
			n_bits += 8
		}
		// For H-CL, there should be no redirections and all symbols should be
		// literals.
		if (table_entry >> 24) != 0x40 {
			return error "internal error: inconsistent Huffman decoder state"
		}
		table_entry = (table_entry >> 8) & 0xFF

		// Write a literal code length.
		if table_entry < 16 {
			this.code_lengths[i] = table_entry as u8
			i += 1
			continue
		}

		// Write a repeated code length.
		var n_extra_bits u32[..7]
		var rep_symbol u8[..15]
		var rep_count u32
		if table_entry == 16 {
			n_extra_bits = 2
			if i <= 0 {
				return error "bad Huffman code length repetition"
			}
			rep_symbol = this.code_lengths[i - 1]
			rep_count = 3
			assert rep_count <= 11
		} else if table_entry == 17 {
			n_extra_bits = 3
			rep_symbol = 0
			rep_count = 3
			assert rep_count <= 11
		} else if table_entry == 18 {
			n_extra_bits = 7
			rep_symbol = 0
			rep_count = 11
			assert rep_count <= 11
		} else {
			return error "internal error: inconsistent Huffman decoder state"
		}
		while n_bits < n_extra_bits,
			inv i < 320,
			inv rep_count <= 11,
			post n_bits >= n_extra_bits,
		{
			assert n_bits < 7 via "a < b: a < c; c <= b"(c:n_extra_bits)
			bits |= (in.src.read_u8?() as u32) << n_bits
			n_bits += 8
		}
		rep_count += bits.low_bits(n:n_extra_bits)
		bits >>= n_extra_bits
		n_bits -= n_extra_bits

		while rep_count > 0 {
			// TODO: hoist this check up one level?
			if i >= (n_lit + n_dist) {
				return error "bad Huffman code length count"
			}
			assert i < (288 + 32) via "a < (b + c): a < (b0 + c0); b0 <= b; c0 <= c"(b0:n_lit, c0:n_dist)
			this.code_lengths[i] = rep_symbol
			i += 1
			rep_count -= 1
		}
	}

	if i != (n_lit + n_dist) {
		return error "bad Huffman code length count"
	}
	if this.code_lengths[256] == 0 {
		return error "missing end-of-block code"
	}

	this.init_huff?(which:0, n_codes0:0, n_codes1:n_lit, base_symbol:257)
	this.init_huff?(which:1, n_codes0:n_lit, n_codes1:n_lit + n_dist, base_symbol:0)

	this.bits = bits
	this.n_bits = n_bits
}

// TODO: make named constants for 15, 19, 319, etc.

// TODO: skip generating PUFFS_COROUTINE_SUSPENSION_POINTs for this function,
// and its callers, as it can only return errors, not suspensions.

pri func decoder.init_huff?(which u32[..1], n_codes0 u32[..320], n_codes1 u32[..320], base_symbol u32)() {
	// For the clcode example in this package's README.md:
	//  - n_codes0 = 0
	//  - n_codes1 = 19
	//  - code_lengths[ 0] = 3
	//  - code_lengths[ 1] = 0
	//  - code_lengths[ 2] = 0
	//  - code_lengths[ 3] = 5
	//  - code_lengths[ 4] = 3
	//  - code_lengths[ 5] = 3
	//  - code_lengths[ 6] = 3
	//  - code_lengths[ 7] = 3
	//  - code_lengths[ 8] = 3
	//  - code_lengths[ 9] = 3
	//  - code_lengths[10] = 0
	//  - code_lengths[11] = 0
	//  - code_lengths[12] = 0
	//  - code_lengths[13] = 0
	//  - code_lengths[14] = 0
	//  - code_lengths[15] = 0
	//  - code_lengths[16] = 0
	//  - code_lengths[17] = 4
	//  - code_lengths[18] = 5

	// Calculate counts.
	//
	// For the clcode example in this package's README.md:
	//  - counts[0] = 9
	//  - counts[1] = 0
	//  - counts[2] = 0
	//  - counts[3] = 7
	//  - counts[4] = 1
	//  - counts[5] = 2
	//  - all other counts elements are 0.
	var counts[16] u16[..320]
	var i u32 = in.n_codes0
	while i < in.n_codes1 {
		assert i < 320 via "a < b: a < c; c <= b"(c:in.n_codes1)
		// TODO: this if should be unnecessary. Have some way to assert that,
		// for all j, counts[j] <= i, and thus counts[j]++ will not overflow.
		if counts[this.code_lengths[i]] >= 320 {
			return error "internal error: inconsistent Huffman decoder state"
		}
		counts[this.code_lengths[i]] += 1
		i += 1
	}
	if ((counts[0] as u32) + in.n_codes0) == in.n_codes1 {
		return error "no Huffman codes"
	}

	// Check that the Huffman code completely covers all possible input bits.
	var remaining u32 = 1  // There is 1 possible 0-bit code.
	i = 1
	while i <= 15 {
		if remaining > (1 << 30) {
			return error "internal error: inconsistent Huffman decoder state"
		}
		// Each iteration doubles the number of possible remaining codes.
		remaining <<= 1
		if remaining < (counts[i] as u32) {
			return error "bad Huffman code (over-subscribed)"
		}
		remaining -= counts[i] as u32
		i += 1
	}
	if remaining != 0 {
		// TODO: when is a degenerate Huffman table valid?
		return error "bad Huffman code (under-subscribed)"
	}

	// Calculate offsets and n_symbols.
	//
	// For the clcode example in this package's README.md:
	//  - offsets[0] =  0
	//  - offsets[1] =  0
	//  - offsets[2] =  0
	//  - offsets[3] =  0
	//  - offsets[4] =  7
	//  - offsets[5] =  8
	//  - offsets[6] = 10
	//  - all other offsets elements are 10.
	//  - n_symbols = 10
	var offsets[16] u16[..320]
	var n_symbols u32[..320]
	i = 1
	while i <= 15 {
		offsets[i] = n_symbols as u16
		var count u32[..320] = counts[i] as u32
		if n_symbols > (320 - count) {
			return error "internal error: inconsistent Huffman decoder state"
		}
		assert (n_symbols + count) <= 320 via "(a + b) <= c: a <= (c - b)"()
		// TODO: change this to n_symbols += count, once the proof engine's
		// bounds checking can handle it.
		n_symbols = n_symbols + count
		i += 1
	}
	if n_symbols > 288 {
		return error "internal error: inconsistent Huffman decoder state"
	}

	// Calculate symbols.
	//
	// For the clcode example in this package's README.md:
	//  - symbols[0] =  0
	//  - symbols[1] =  4
	//  - symbols[2] =  5
	//  - symbols[3] =  6
	//  - symbols[4] =  7
	//  - symbols[5] =  8
	//  - symbols[6] =  9
	//  - symbols[7] = 17
	//  - symbols[8] =  3
	//  - symbols[9] = 18
	//
	// As a (local variable) side effect, offsets' values will be updated:
	//  - offsets[3] =  7, formerly 0
	//  - offsets[4] =  8, formerly 7
	//  - offsets[5] = 10, formerly 8
	var symbols[320] u16[..319]
	i = in.n_codes0
	while i < in.n_codes1,
		inv n_symbols <= 288,
	{
		assert i < 320 via "a < b: a < c; c <= b"(c:in.n_codes1)
		// TODO: this if check should be unnecessary.
		if i < in.n_codes0 {
			return error "internal error: inconsistent Huffman decoder state"
		}
		if this.code_lengths[i] != 0 {
			if offsets[this.code_lengths[i]] >= 320 {
				return error "internal error: inconsistent Huffman decoder state"
			}
			symbols[offsets[this.code_lengths[i]]] = (i - in.n_codes0) as u16
			offsets[this.code_lengths[i]] += 1
		}
		i += 1
	}

	// Calculate min_cl and max_cl.
	//
	// For the clcode example in this package's README.md:
	//  - min_cl = 3
	//  - max_cl = 5
	var min_cl u32[1..9] = 1
	while true,
		inv n_symbols <= 288,
	{
		if counts[min_cl] != 0 {
			break
		}
		if min_cl >= 9 {
			return error "bad Huffman minimum code length"
		}
		min_cl += 1
	}
	var max_cl u32[1..15] = 15
	while true,
		inv n_symbols <= 288,
	{
		if counts[max_cl] != 0 {
			break
		}
		if max_cl <= 1 {
			// TODO: when is a degenerate Huffman table valid?
			return error "no Huffman codes"
		}
		max_cl -= 1
	}
	if max_cl <= 9 {
		this.n_huffs_bits[in.which] = max_cl
	} else {
		this.n_huffs_bits[in.which] = 9
	}

	// Calculate this.huffs[in.which].
	//
	// For the clcode example in this package's README.md:
	//  - this.huffs[0][0b..000] = 0x40000003 (literal, symbols[0]=0x00, code_length=3)
	//  - this.huffs[0][0b..100] = 0x40000403 (literal, symbols[1]=0x04, code_length=3)
	//  - this.huffs[0][0b..010] = 0x40000503 (literal, symbols[2]=0x05, code_length=3)
	//  - this.huffs[0][0b..110] = 0x40000603 (literal, symbols[3]=0x06, code_length=3)
	//  - this.huffs[0][0b..001] = 0x40000703 (literal, symbols[4]=0x07, code_length=3)
	//  - this.huffs[0][0b..101] = 0x40000803 (literal, symbols[5]=0x08, code_length=3)
	//  - this.huffs[0][0b..011] = 0x40000903 (literal, symbols[6]=0x09, code_length=3)
	//  - this.huffs[0][0b.0111] = 0x40001104 (literal, symbols[7]=0x11, code_length=4)
	//  - this.huffs[0][0b01111] = 0x40000305 (literal, symbols[8]=0x03, code_length=5)
	//  - this.huffs[0][0b11111] = 0x40001805 (literal, symbols[9]=0x18, code_length=5)
	i = 0
	if (n_symbols != (offsets[max_cl] as u32)) or (n_symbols != (offsets[15] as u32)) {
		return error "internal error: inconsistent Huffman decoder state"
	}
	if (in.n_codes0 + (symbols[0] as u32)) >= 320 {
		return error "internal error: inconsistent Huffman decoder state"
	}

	var initial_high_bits u32 = 1 << 9
	if max_cl < 9 {
		initial_high_bits = (1 as u32) << max_cl
	}
	var prev_cl u32[..15] = this.code_lengths[in.n_codes0 + (symbols[0] as u32)] as u32
	var prev_redirect_key u32 = 0xFFFFFFFF
	var top u32[..1234]
	var next_top u32[..1234] = 512
	var code u32
	var key u32
	var value u32
	while true,
		pre code < (1 << 15),
		pre i < 288,
		inv n_symbols <= 288,
	{
		if (in.n_codes0 + (symbols[i] as u32)) >= 320 {
			return error "internal error: inconsistent Huffman decoder state"
		}
		var cl u32[..15] = this.code_lengths[in.n_codes0 + (symbols[i] as u32)] as u32
		if cl > prev_cl {
			code <<= cl - prev_cl
			if code >= (1 << 15) {
				return error "internal error: inconsistent Huffman decoder state"
			}
		}
		// For the remainder of this loop body, prev_cl is the original code
		// length, cl is possibly clipped by 9, if in the 2nd-level table.
		prev_cl = cl

		key = code
		if cl > 9 {
			// TODO: we shouldn't need a temporary variable.
			var tmp u32[..6] = cl - 9
			cl = tmp
			assert cl <= 9 via "a <= b: a == c; c <= b"(c:tmp)

			var redirect_key u32[..511] = (key >> tmp) & 511
			key = key.low_bits(n:tmp)
			if prev_redirect_key != redirect_key {
				prev_redirect_key = redirect_key

				// Calculate the number of bits needed for the 2nd level table.
				// This computation is similar to "check that the Huffman code
				// completely covers all possible input bits" above.
				remaining = (1 as u32) << cl
				var j u32 = prev_cl
				while j <= 15,
					inv cl <= 9,
					inv code < (1 << 15),
					inv i < 288,
					inv n_symbols <= 288,
				{
					if remaining <= (counts[j] as u32) {
						break
					}
					remaining -= counts[j] as u32
					if remaining > (1 << 30) {
						return error "internal error: inconsistent Huffman decoder state"
					}
					remaining <<= 1
					j += 1
				}
				if (j <= 9) or (15 < j) {
					return error "internal error: inconsistent Huffman decoder state"
				}
				tmp = j - 9
				initial_high_bits = (1 as u32) << tmp

				top = next_top
				if (top + ((1 as u32) << tmp)) > 1234 {
					return error "internal error: inconsistent Huffman decoder state"
				}
				next_top = top + ((1 as u32) << tmp)

				redirect_key = (reverse8[redirect_key >> 1] as u32) | ((redirect_key & 1) << 8)
				this.huffs[in.which][redirect_key] = 0x80000009 | (top << 8) | (tmp << 4)
			}
		}
		if (key >= (1 << 9)) or (counts[prev_cl] <= 0) {
			return error "internal error: inconsistent Huffman decoder state"
		}
		counts[prev_cl] -= 1

		var reversed_key u32[..511] = (reverse8[key >> 1] as u32) | ((key & 1) << 8)
		reversed_key >>= 9 - cl

		var symbol u32[..319] = symbols[i] as u32
		if symbol == 256 {
			// End-of-block.
			value = 0x10000000 | cl
		} else if (symbol < 256) and (in.which == 0) {
			// Literal.
			value = 0x40000000 | (symbol << 8) | cl
		} else if symbol >= in.base_symbol {
			// Base number + extra bits.
			symbol -= in.base_symbol
			if in.which == 0 {
				value = lcode_magic_numbers[symbol & 31] | cl
			} else {
				value = dcode_magic_numbers[symbol & 31] | cl
			}
		} else {
			return error "internal error: inconsistent Huffman decoder state"
		}

		// The table uses log2(initial_high_bits) bits, but reversed_key only
		// has cl bits. We duplicate the key-value pair across all possible
		// values of the high (log2(initial_high_bits) - cl) bits.
		var high_bits u32 = initial_high_bits
		var delta u32 = (1 as u32) << cl
		while high_bits >= delta,
			inv code < (1 << 15),
			inv i < 288,
			inv n_symbols <= 288,
		{
			high_bits -= delta
			if (top + ((high_bits | reversed_key) & 511)) >= 1234 {
				return error "internal error: inconsistent Huffman decoder state"
			}
			this.huffs[in.which][top + ((high_bits | reversed_key) & 511)] = value
		}

		i += 1
		if i >= n_symbols {
			break
		}
		assert i < 288 via "a < b: a < c; c <= b"(c:n_symbols)
		code += 1
		if code >= (1 << 15) {
			return error "internal error: inconsistent Huffman decoder state"
		}
	}
}
