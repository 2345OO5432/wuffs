// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file.

// The flate spec is https://www.ietf.org/rfc/rfc1951.txt

packageid "flte"

pub error "bad distance code count"
pub error "bad flate block"
pub error "bad literal/length code count"
pub error "inconsistent stored block length"
pub error "internal error: inconsistent init_huffman state"
pub error "internal error: inconsistent n_bits"
pub error "no Huffman codes"

pub error "TODO: fixed Huffman blocks"

pub struct decoder?(
	// These fields yield src's bits in Least Significant Bits order.
	bits u32,
	n_bits u32,

	huffs[2] huffman_decoder,
	code_lengths[289] u8[..15],

	// These temporary fields are used to debug work-in-progress code.
	wip0 u32,
	wip1 u32,
)

pub func decoder.decode?(dst writer1, src reader1)() {
	while true {
		while this.n_bits < 3,
			post this.n_bits >= 3,
		{
			this.bits |= (in.src.read_u8?() as u32) << this.n_bits
			this.n_bits += 8
		}
		var final u32 = this.bits & 0x01
		var type u32 = (this.bits >> 1) & 0x03
		this.bits >>= 3
		this.n_bits -= 3

		if type == 0 {
			this.decode_uncompressed?(dst:in.dst, src:in.src)
		} else if type == 1 {
			return error "TODO: fixed Huffman blocks"
		} else if type == 2 {
			this.decode_dynamic?(dst:in.dst, src:in.src)
		} else {
			return error "bad flate block"
		}

		if final != 0 {
			return
		}
	}
}

pri func decoder.decode_uncompressed?(dst writer1, src reader1)() {
	if this.n_bits >= 8 {
		return error "internal error: inconsistent n_bits"
	}
	this.n_bits = 0

	var n u32 = in.src.read_u32le?()
	if (n.low_bits(n:16) + n.high_bits(n:16)) != 0xFFFF {
		return error "inconsistent stored block length"
	}
	in.dst.copy_from32?(r:in.src, n:n.low_bits(n:16))
}

// decode_dynamic decodes dynamic Huffman codes as per the RFC section 3.2.7.
pri func decoder.decode_dynamic?(dst writer1, src reader1)() {
	var bits u32 = this.bits
	var n_bits u32 = this.n_bits
	while n_bits < 14,
		post n_bits >= 14,
	{
		bits |= (in.src.read_u8?() as u32) << n_bits
		n_bits += 8
	}
	var hlit u32[257..288] = bits.low_bits(n:5) + 257
	if hlit > 286 {
		return error "bad literal/length code count"
	}
	bits >>= 5
	var hdist u32[1..32] = bits.low_bits(n:5) + 1
	if hdist > 30 {
		return error "bad distance code count"
	}
	bits >>= 5
	var hclen u32[4..19] = bits.low_bits(n:4) + 4
	bits >>= 4
	n_bits -= 14

	// Read the code length code lengths. (This is not a typo).
	var i u32 = 0
	while i < hclen {
		while n_bits < 3,
			inv i < hclen,
			post n_bits >= 3,
		{
			bits |= (in.src.read_u8?() as u32) << n_bits
			n_bits += 8
		}
		assert i < 19 via "a < b: a < c; c <= b"(c:hclen)
		this.code_lengths[code_order[i]] = (bits & 0x07) as u8
		bits >>= 3
		n_bits -= 3
		i += 1
	}
	while i < 19 {
		this.code_lengths[code_order[i]] = 0
		i += 1
	}
	this.bits = bits
	this.n_bits = n_bits

	this.init_huffman?(which:0, n_codes:19)

	// TODO: implement.
	this.wip0 = hlit
	this.wip1 = hdist
}

// TODO: make init_huffman a huffman_decoder method instead of a decoder
// method?

// TODO: make named constants for 15, 289, etc.

// TODO: skip generating PUFFS_COROUTINE_SUSPENSION_POINTs for this function,
// and its callers, as it can only return errors, not suspensions.

pri func decoder.init_huffman?(which u32[..1], n_codes u32[..289])() {
	// For the clcode example in this package's README.md:
	//  - n_codes = 19
	//  - code_lengths[ 0] = 3
	//  - code_lengths[ 1] = 0
	//  - code_lengths[ 2] = 0
	//  - code_lengths[ 3] = 5
	//  - code_lengths[ 4] = 3
	//  - code_lengths[ 5] = 3
	//  - code_lengths[ 6] = 3
	//  - code_lengths[ 7] = 3
	//  - code_lengths[ 8] = 3
	//  - code_lengths[ 9] = 3
	//  - code_lengths[10] = 0
	//  - code_lengths[11] = 0
	//  - code_lengths[12] = 0
	//  - code_lengths[13] = 0
	//  - code_lengths[14] = 0
	//  - code_lengths[15] = 0
	//  - code_lengths[16] = 0
	//  - code_lengths[17] = 4
	//  - code_lengths[18] = 5

	var i u32
	while i < 16 {
		this.huffs[in.which].counts[i] = 0
		i += 1
	}
	i = 0
	while i < in.n_codes {
		assert i < 289 via "a < b: a < c; c <= b"(c:in.n_codes)
		// TODO: this if should be unnecessary. Have some way to assert that,
		// for all j, counts[j] <= i, and thus counts[j]++ will not overflow.
		if this.huffs[in.which].counts[this.code_lengths[i]] >= 289 {
			return error "internal error: inconsistent init_huffman state"
		}
		this.huffs[in.which].counts[this.code_lengths[i]] += 1
		i += 1
	}
	if (this.huffs[in.which].counts[0] as u32) == in.n_codes {
		return error "no Huffman codes"
	}

	// For the clcode example in this package's README.md:
	//  - counts[0] = 9
	//  - counts[1] = 0
	//  - counts[2] = 0
	//  - counts[3] = 7
	//  - counts[4] = 1
	//  - counts[5] = 2
	//  - all other counts elements are 0.

	// TODO: check for the total code_lengths being too short or too long.

	var offsets[16] u16[..289]
	var total u16[..289]
	i = 1
	while i <= 15 {
		offsets[i] = total
		var count u16[..289] = this.huffs[in.which].counts[i]
		if total > (289 - count) {
			return error "internal error: inconsistent init_huffman state"
		}
		assert (total + count) <= 289 via "(a + b) <= c: a <= (c - b)"()
		// TODO: change this to total += count, once the proof engine's bounds
		// checking can handle it.
		total = total + count
		i += 1
	}

	// For the clcode example in this package's README.md:
	//  - offsets[0] =  0
	//  - offsets[1] =  0
	//  - offsets[2] =  0
	//  - offsets[3] =  0
	//  - offsets[4] =  7
	//  - offsets[5] =  8
	//  - offsets[6] = 10
	//  - all other offsets elements are 10.

	i = 0
	while i < in.n_codes {
		assert i < 289 via "a < b: a < c; c <= b"(c:in.n_codes)
		if this.code_lengths[i] != 0 {
			this.huffs[in.which].symbols[offsets[this.code_lengths[i]]] = i as u16
			if offsets[this.code_lengths[i]] >= 289 {
				return error "internal error: inconsistent init_huffman state"
			}
			offsets[this.code_lengths[i]] += 1
		}
		i += 1
	}

	// For the clcode example in this package's README.md:
	//  - symbols[0] =  0
	//  - symbols[1] =  4
	//  - symbols[2] =  5
	//  - symbols[3] =  6
	//  - symbols[4] =  7
	//  - symbols[5] =  8
	//  - symbols[6] =  9
	//  - symbols[7] = 17
	//  - symbols[8] =  3
	//  - symbols[9] = 18
	//
	// As a (local variable) side effect, offsets' values have been updated:
	//  - offsets[3] =  7, formerly 0
	//  - offsets[4] =  8, formerly 7
	//  - offsets[5] = 10, formerly 8
}

pri struct huffman_decoder(
	counts[16] u16[..289],
	symbols[290] u16[..289],
)
