// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file.

// The flate spec is https://www.ietf.org/rfc/rfc1951.txt

packageid "flte"

pub error "bad Huffman code"
pub error "bad distance code count"
pub error "bad flate block"
pub error "bad literal/length code count"
pub error "inconsistent stored block length"
pub error "internal error: inconsistent Huffman decoder state"
pub error "internal error: inconsistent n_bits"
pub error "no Huffman codes"

pub error "TODO: fixed Huffman blocks"

pub struct decoder?(
	// These fields yield src's bits in Least Significant Bits order.
	bits u32,
	n_bits u32,

	// There are up to 2 Huffman tables active at any one time. As per this
	// package's README.md:
	//  - huffs[0] is used for clcode and lcode.
	//  - huffs[1] is used for dcode.
	huffs[2] huffman_decoder,

	code_lengths[289] u8[..15],

	// These temporary fields are used to debug work-in-progress code.
	wip0 u32,
	wip1 u32,
)

pub func decoder.decode?(dst writer1, src reader1)() {
	while true {
		while this.n_bits < 3,
			post this.n_bits >= 3,
		{
			this.bits |= (in.src.read_u8?() as u32) << this.n_bits
			this.n_bits += 8
		}
		var final u32 = this.bits & 0x01
		var type u32 = (this.bits >> 1) & 0x03
		this.bits >>= 3
		this.n_bits -= 3

		if type == 0 {
			this.decode_uncompressed?(dst:in.dst, src:in.src)
		} else if type == 1 {
			return error "TODO: fixed Huffman blocks"
		} else if type == 2 {
			this.decode_dynamic?(dst:in.dst, src:in.src)
		} else {
			return error "bad flate block"
		}

		if final != 0 {
			return
		}
	}
}

pri func decoder.decode_uncompressed?(dst writer1, src reader1)() {
	if this.n_bits >= 8 {
		return error "internal error: inconsistent n_bits"
	}
	this.n_bits = 0

	var n u32 = in.src.read_u32le?()
	if (n.low_bits(n:16) + n.high_bits(n:16)) != 0xFFFF {
		return error "inconsistent stored block length"
	}
	in.dst.copy_from32?(r:in.src, n:n.low_bits(n:16))
}

// decode_dynamic decodes dynamic Huffman codes as per the RFC section 3.2.7.
pri func decoder.decode_dynamic?(dst writer1, src reader1)() {
	this.init_huffs?(src:in.src)
}

pri func decoder.init_huffs?(src reader1)() {
	var bits u32 = this.bits
	var n_bits u32 = this.n_bits
	while n_bits < 14,
		post n_bits >= 14,
	{
		bits |= (in.src.read_u8?() as u32) << n_bits
		n_bits += 8
	}
	var n_lit u32[257..288] = bits.low_bits(n:5) + 257
	if n_lit > 286 {
		return error "bad literal/length code count"
	}
	bits >>= 5
	var n_dist u32[1..32] = bits.low_bits(n:5) + 1
	if n_dist > 30 {
		return error "bad distance code count"
	}
	bits >>= 5
	var n_clen u32[4..19] = bits.low_bits(n:4) + 4
	bits >>= 4
	n_bits -= 14

	// Read the clcode Huffman table: H-CL.
	var i u32 = 0
	while i < n_clen,
		inv n_dist <= 30,
		inv n_lit <= 286,
	{
		while n_bits < 3,
			inv i < n_clen,
			inv n_dist <= 30,
			inv n_lit <= 286,
			post n_bits >= 3,
		{
			bits |= (in.src.read_u8?() as u32) << n_bits
			n_bits += 8
		}
		assert i < 19 via "a < b: a < c; c <= b"(c:n_clen)
		this.code_lengths[code_order[i]] = (bits & 0x07) as u8
		bits >>= 3
		n_bits -= 3
		i += 1
	}
	while i < 19,
		inv n_dist <= 30,
		inv n_lit <= 286,
	{
		this.code_lengths[code_order[i]] = 0
		i += 1
	}
	this.init_huff?(which:0, n_codes:19)

	// Decode the code lengths for the next two Huffman tables.
	i = 0
	while i < (n_lit + n_dist),
		inv n_dist <= 30,
		inv n_lit <= 286,
	{
		assert i < (286 + 30) via "a < (b + c): a < (b0 + c0); b0 <= b; c0 <= c"(b0:n_lit, c0:n_dist)

		// Decode a clcode symbol from H-CL.
		var symbol u32[..289]
		var code u32
		var count u32
		var first u32
		var index u32
		var length u32 = 1
		while true,
			pre first <= 0xFFFF,
			pre index <= 0xFFFF,
			inv i < 316,
			inv n_dist <= 30,
			inv n_lit <= 286,
		{
			if length > 15 {
				return error "bad Huffman code"
			}

			// Read the next bit.
			while n_bits <= 0,
				inv first <= 0xFFFF,
				inv i < 316,
				inv index <= 0xFFFF,
				inv length <= 15,
				inv n_dist <= 30,
				inv n_lit <= 286,
				post n_bits > 0,
			{
				bits |= (in.src.read_u8?() as u32) << n_bits
				n_bits += 8
			}
			code |= bits & 1
			// TODO: improve the proof engine's bounds checking so that any
			// check returning "internal error: inconsistent Huffman decoder
			// state" can be removed. There is one here and more below.
			if code > 0xFFFF {
				return error "internal error: inconsistent Huffman decoder state"
			}
			bits >>= 1
			n_bits -= 1

			count = this.huffs[0].counts[length] as u32
			if count > 0xFFFF {
				return error "internal error: inconsistent Huffman decoder state"
			}

			// Compare the code so far to the counts.
			//
			// For the clcode example in this package's README.md:
			//  - counts[1] = 0
			//  - counts[2] = 0
			//  - counts[3] = 7
			//  - counts[4] = 1
			//  - counts[5] = 2
			//
			// Recall that the map from bits to clcode symbols is:
			//    bits        clcode
			//    0b000        0
			//    0b001        4
			//    0b010        5
			//    0b011        6
			//    0b100        7
			//    0b101        8
			//    0b110        9
			//    0b1110      17
			//    0b11110      3
			//    0b11111     18
			//
			// The loop iterations at this point have:
			//  - length=1, count=0, first= 0, index=0, code in [0.. 1].
			//  - length=2, count=0, first= 0, index=0, code in [0.. 3].
			//  - length=3, count=7, first= 0, index=0, code in [0.. 7].
			//  - length=4, count=1, first=14, index=7, code in [0..15].
			//  - length=5, count=2, first=30, index=8, code in [0..31].
			if code < (first + count) {
				index += code
				if index < first {
					return error "internal error: inconsistent Huffman decoder state"
				}
				index -= first
				if index >= 290 {
					return error "internal error: inconsistent Huffman decoder state"
				}
				symbol = this.huffs[0].symbols[index] as u32
				break
			}

			index += count
			if index > 0xFFFF {
				return error "internal error: inconsistent Huffman decoder state"
			}
			first = (first + count) << 1
			if first > 0xFFFF {
				return error "internal error: inconsistent Huffman decoder state"
			}
			code <<= 1

			length += 1
		}

		// Read any extra bits, as per the RFC 1951 section 3.2.7.
		var n_extra_bits u32[..7]
		if symbol == 16 {
			n_extra_bits = 2
		} else if symbol == 17 {
			n_extra_bits = 3
		} else if symbol == 18 {
			n_extra_bits = 7
		}
		while n_bits < n_extra_bits,
			inv i < 316,
			inv n_dist <= 30,
			inv n_lit <= 286,
			post n_bits >= n_extra_bits,
		{
			assert n_bits < 7 via "a < b: a < c; c <= b"(c:n_extra_bits)
			bits |= (in.src.read_u8?() as u32) << n_bits
			n_bits += 8
		}
		// TODO: do something with those extra bits.
		bits >>= n_extra_bits
		n_bits -= n_extra_bits

		i += 1
	}

	this.wip0 = n_lit
	this.wip1 = n_dist

	this.bits = bits
	this.n_bits = n_bits
}

// TODO: make init_huff a huffman_decoder method instead of a decoder
// method?

// TODO: make named constants for 15, 19, 289, etc.

// TODO: skip generating PUFFS_COROUTINE_SUSPENSION_POINTs for this function,
// and its callers, as it can only return errors, not suspensions.

pri func decoder.init_huff?(which u32[..1], n_codes u32[..289])() {
	// For the clcode example in this package's README.md:
	//  - n_codes = 19
	//  - code_lengths[ 0] = 3
	//  - code_lengths[ 1] = 0
	//  - code_lengths[ 2] = 0
	//  - code_lengths[ 3] = 5
	//  - code_lengths[ 4] = 3
	//  - code_lengths[ 5] = 3
	//  - code_lengths[ 6] = 3
	//  - code_lengths[ 7] = 3
	//  - code_lengths[ 8] = 3
	//  - code_lengths[ 9] = 3
	//  - code_lengths[10] = 0
	//  - code_lengths[11] = 0
	//  - code_lengths[12] = 0
	//  - code_lengths[13] = 0
	//  - code_lengths[14] = 0
	//  - code_lengths[15] = 0
	//  - code_lengths[16] = 0
	//  - code_lengths[17] = 4
	//  - code_lengths[18] = 5

	var i u32
	while i < 16 {
		this.huffs[in.which].counts[i] = 0
		i += 1
	}
	i = 0
	while i < in.n_codes {
		assert i < 289 via "a < b: a < c; c <= b"(c:in.n_codes)
		// TODO: this if should be unnecessary. Have some way to assert that,
		// for all j, counts[j] <= i, and thus counts[j]++ will not overflow.
		if this.huffs[in.which].counts[this.code_lengths[i]] >= 289 {
			return error "internal error: inconsistent Huffman decoder state"
		}
		this.huffs[in.which].counts[this.code_lengths[i]] += 1
		i += 1
	}
	if (this.huffs[in.which].counts[0] as u32) == in.n_codes {
		return error "no Huffman codes"
	}

	// For the clcode example in this package's README.md:
	//  - counts[0] = 9
	//  - counts[1] = 0
	//  - counts[2] = 0
	//  - counts[3] = 7
	//  - counts[4] = 1
	//  - counts[5] = 2
	//  - all other counts elements are 0.

	// TODO: check for the total code_lengths being too short or too long.

	var offsets[16] u16[..289]
	var total u16[..289]
	i = 1
	while i <= 15 {
		offsets[i] = total
		var count u16[..289] = this.huffs[in.which].counts[i]
		if total > (289 - count) {
			return error "internal error: inconsistent Huffman decoder state"
		}
		assert (total + count) <= 289 via "(a + b) <= c: a <= (c - b)"()
		// TODO: change this to total += count, once the proof engine's bounds
		// checking can handle it.
		total = total + count
		i += 1
	}

	// For the clcode example in this package's README.md:
	//  - offsets[0] =  0
	//  - offsets[1] =  0
	//  - offsets[2] =  0
	//  - offsets[3] =  0
	//  - offsets[4] =  7
	//  - offsets[5] =  8
	//  - offsets[6] = 10
	//  - all other offsets elements are 10.

	i = 0
	while i < in.n_codes {
		assert i < 289 via "a < b: a < c; c <= b"(c:in.n_codes)
		if this.code_lengths[i] != 0 {
			this.huffs[in.which].symbols[offsets[this.code_lengths[i]]] = i as u16
			if offsets[this.code_lengths[i]] >= 289 {
				return error "internal error: inconsistent Huffman decoder state"
			}
			offsets[this.code_lengths[i]] += 1
		}
		i += 1
	}

	// For the clcode example in this package's README.md:
	//  - symbols[0] =  0
	//  - symbols[1] =  4
	//  - symbols[2] =  5
	//  - symbols[3] =  6
	//  - symbols[4] =  7
	//  - symbols[5] =  8
	//  - symbols[6] =  9
	//  - symbols[7] = 17
	//  - symbols[8] =  3
	//  - symbols[9] = 18
	//
	// As a (local variable) side effect, offsets' values have been updated:
	//  - offsets[3] =  7, formerly 0
	//  - offsets[4] =  8, formerly 7
	//  - offsets[5] = 10, formerly 8
}

pri struct huffman_decoder(
	counts[16] u16[..289],
	symbols[290] u16[..289],
)
