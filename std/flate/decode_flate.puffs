// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file.

// The flate spec is https://www.ietf.org/rfc/rfc1951.txt

packageid "flte"

pub error "bad distance code count"
pub error "bad flate block"
pub error "bad literal/length code count"
pub error "inconsistent Huffman table"
pub error "inconsistent stored block length"
pub error "internal error: inconsistent n_bits"

pub error "TODO: fixed Huffman blocks"
pub error "TODO: dynamic Huffman blocks"

pub struct decoder?(
	// These fields yield src's bits in Least Significant Bits order.
	bits u32,
	n_bits u32,

	huff[2] huffman_decoder,
	code_lengths[289] u8[..15],

	// These temporary fields are used to debug work-in-progress code.
	wip0 u32,
	wip1 u32,
)

pub func decoder.decode?(dst writer1, src reader1)() {
	while true {
		while this.n_bits < 3,
			post this.n_bits >= 3,
		{
			this.bits |= (in.src.read_u8?() as u32) << this.n_bits
			this.n_bits += 8
		}
		var final u32 = this.bits & 0x01
		var type u32 = (this.bits >> 1) & 0x03
		this.bits >>= 3
		this.n_bits -= 3

		if type == 0 {
			this.decode_uncompressed?(dst:in.dst, src:in.src)
		} else if type == 1 {
			return error "TODO: fixed Huffman blocks"
		} else if type == 2 {
			this.decode_dynamic?(dst:in.dst, src:in.src)
		} else {
			return error "bad flate block"
		}

		if final != 0 {
			return
		}
	}
}

pri func decoder.decode_uncompressed?(dst writer1, src reader1)() {
	if this.n_bits >= 8 {
		return error "internal error: inconsistent n_bits"
	}
	this.n_bits = 0

	var n u32 = in.src.read_u32le?()
	if (n.low_bits(n:16) + n.high_bits(n:16)) != 0xFFFF {
		return error "inconsistent stored block length"
	}
	in.dst.copy_from32?(r:in.src, n:n.low_bits(n:16))
}

// decode_dynamic decodes dynamic Huffman codes as per the RFC section 3.2.7.
pri func decoder.decode_dynamic?(dst writer1, src reader1)() {
	var bits u32 = this.bits
	var n_bits u32 = this.n_bits
	while n_bits < 14,
		post n_bits >= 14,
	{
		bits |= (in.src.read_u8?() as u32) << n_bits
		n_bits += 8
	}
	var hlit u32[257..288] = bits.low_bits(n:5) + 257
	if hlit > 286 {
		return error "bad literal/length code count"
	}
	bits >>= 5
	var hdist u32[1..32] = bits.low_bits(n:5) + 1
	if hdist > 30 {
		return error "bad distance code count"
	}
	bits >>= 5
	var hclen u32[4..19] = bits.low_bits(n:4) + 4
	bits >>= 4
	n_bits -= 14

	// Read the code length code lengths. (This is not a typo).
	var i u32 = 0
	while i < hclen {
		while n_bits < 3,
			inv i < hclen,
			post n_bits >= 3,
		{
			bits |= (in.src.read_u8?() as u32) << n_bits
			n_bits += 8
		}
		assert i < 19 via "a < b: a < c; c <= b"(c:hclen)
		this.code_lengths[code_order[i]] = (bits & 0x07) as u8
		bits >>= 3
		n_bits -= 3
		i += 1
	}
	while i < 19 {
		this.code_lengths[code_order[i]] = 0
		i += 1
	}
	this.bits = bits
	this.n_bits = n_bits

	this.init_huffman?(n_codes:19)

	// TODO: implement.
	this.wip0 = hlit
	this.wip1 = hdist
}

// TODO: make init_huffman a huffman_decoder method instead of a decoder
// method?

// TODO: make named constants for 15, 289, etc.

// TODO: skip generating PUFFS_COROUTINE_SUSPENSION_POINTs for this function,
// and its callers, as it can only return errors, not suspensions.

pri func decoder.init_huffman?(n_codes u32[..289])() {
	var counts[16] u32[..289]
	var i u32
	while i < in.n_codes {
		assert i < 289 via "a < b: a < c; c <= b"(c:in.n_codes)
		// TODO: this if should be unnecessary. Have some way to assert that,
		// for all j, counts[j] <= i, and thus counts[j]++ will not overflow.
		if counts[this.code_lengths[i]] >= 289 {
			return error "inconsistent Huffman table"
		}
		counts[this.code_lengths[i]] += 1
		i += 1
	}
	if counts[0] == in.n_codes {
		// There are no codes.
		return error "inconsistent Huffman table"
	}

	// For the clcode_lengths example in this package's README.md:
	//  - counts[3] = 7
	//  - counts[4] = 1
	//  - counts[5] = 2
	//  - all other counts elements are zero.

	// TODO: check for the total code_lengths being too short or too long.
}

pri struct huffman_decoder(
)
