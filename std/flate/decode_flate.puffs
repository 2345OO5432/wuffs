// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file.

// The flate spec is https://www.ietf.org/rfc/rfc1951.txt

packageid "flte"

pub error "bad Huffman code length count"
pub error "bad Huffman code length repetition"
pub error "bad Huffman code"
pub error "bad distance code count"
pub error "bad flate block"
pub error "bad literal/length code count"
pub error "inconsistent stored block length"
pub error "internal error: inconsistent Huffman decoder state"
pub error "internal error: inconsistent n_bits"
pub error "missing end-of-block code"
pub error "no Huffman codes"

pub error "TODO: fixed Huffman blocks"
pub error "TODO: indirect Huffman tables"

pub struct decoder?(
	// These fields yield src's bits in Least Significant Bits order.
	bits u32,
	n_bits u32,

	// huffs and n_huffs_bits are the lookup tables for Huffman decodings.
	//
	// There are up to 2 Huffman decoders active at any one time. As per this
	// package's README.md:
	//  - huffs[0] is used for clcode and lcode.
	//  - huffs[1] is used for dcode.
	//
	// The initial table key is the low n_huffs_bits of the decoder.bits field.
	// Keys longer than 9 bits require a two step lookup, the first step
	// examines the low 9 bits, the second step examines the remaining bits.
	// Two steps are required at most, as keys are at most 15 bits long.
	//
	// Using decoder.bits's low n_huffs_bits as a table key is valid even if
	// decoder.n_bits is less than n_huffs_bits, because the immediate next
	// step after indexing the table by the key is to compare decoder.n_bits to
	// the table value's number of decoder.bits to consume. If it compares
	// less, then more source bytes are read and the table lookup re-tried.
	//
	// The table value is:
	//  - bit     31 indicates a redirect to another part of the table.
	//  - bit     30 indicates the symbol is a literal.
	//  - bit     29 indicates the symbol is a base number + extra bits.
	//  - bit     28 indicates the symbol is the end-of-block.
	//  - bits 27-24 is the redirect offset or the number of extra bits.
	//  - bits 23- 8 is the literal (in bits 15-8) or base number.
	//  - bits  7- 4 are unused.
	//  - bits  3- 0 are the number of decoder.bits to consume.
	//
	// Exactly one of the four bits 31-28 should be set.
	huffs[2][512] u32,
	n_huffs_bits[2] u32[..9],

	// These fields are used as scratch space when constructing the huffs
	// tables.
	code_lengths[316] u8[..15],
	counts[16] u16[..289],
	symbols[290] u16[..289],
)

pub func decoder.decode?(dst writer1, src reader1)() {
	while true {
		while this.n_bits < 3,
			post this.n_bits >= 3,
		{
			this.bits |= (in.src.read_u8?() as u32) << this.n_bits
			this.n_bits += 8
		}
		var final u32 = this.bits & 0x01
		var type u32 = (this.bits >> 1) & 0x03
		this.bits >>= 3
		this.n_bits -= 3

		if type == 0 {
			this.decode_uncompressed?(dst:in.dst, src:in.src)
		} else if type == 1 {
			return error "TODO: fixed Huffman blocks"
		} else if type == 2 {
			this.decode_dynamic?(dst:in.dst, src:in.src)
		} else {
			return error "bad flate block"
		}

		if final != 0 {
			return
		}
	}
}

pri func decoder.decode_uncompressed?(dst writer1, src reader1)() {
	if this.n_bits >= 8 {
		return error "internal error: inconsistent n_bits"
	}
	this.n_bits = 0

	var n u32 = in.src.read_u32le?()
	if (n.low_bits(n:16) + n.high_bits(n:16)) != 0xFFFF {
		return error "inconsistent stored block length"
	}
	in.dst.copy_from32?(r:in.src, n:n.low_bits(n:16))
}

// decode_dynamic decodes dynamic Huffman codes as per the RFC section 3.2.7.
pri func decoder.decode_dynamic?(dst writer1, src reader1)() {
	this.init_huffs?(src:in.src)
}

pri func decoder.init_huffs?(src reader1)() {
	var bits u32 = this.bits
	var n_bits u32 = this.n_bits
	while n_bits < 14,
		post n_bits >= 14,
	{
		bits |= (in.src.read_u8?() as u32) << n_bits
		n_bits += 8
	}
	var n_lit u32[257..288] = bits.low_bits(n:5) + 257
	if n_lit > 286 {
		return error "bad literal/length code count"
	}
	bits >>= 5
	var n_dist u32[1..32] = bits.low_bits(n:5) + 1
	if n_dist > 30 {
		return error "bad distance code count"
	}
	bits >>= 5
	var n_clen u32[4..19] = bits.low_bits(n:4) + 4
	bits >>= 4
	n_bits -= 14

	// Read the clcode Huffman table: H-CL.
	var i u32 = 0
	while i < n_clen,
		inv n_dist <= 30,
		inv n_lit <= 286,
	{
		while n_bits < 3,
			inv i < n_clen,
			inv n_dist <= 30,
			inv n_lit <= 286,
			post n_bits >= 3,
		{
			bits |= (in.src.read_u8?() as u32) << n_bits
			n_bits += 8
		}
		assert i < 19 via "a < b: a < c; c <= b"(c:n_clen)
		this.code_lengths[code_order[i]] = (bits & 0x07) as u8
		bits >>= 3
		n_bits -= 3
		i += 1
	}
	while i < 19,
		inv n_dist <= 30,
		inv n_lit <= 286,
	{
		this.code_lengths[code_order[i]] = 0
		i += 1
	}
	this.init_huff?(which:0, n_codes:19)

	// Decode the code lengths for the next two Huffman tables.
	i = 0
	while i < (n_lit + n_dist),
		inv n_dist <= 30,
		inv n_lit <= 286,
	{
		assert i < (286 + 30) via "a < (b + c): a < (b0 + c0); b0 <= b; c0 <= c"(b0:n_lit, c0:n_dist)

		// Decode a clcode symbol from H-CL.
		var symbol u32[..289]
		var code u32
		var count u32
		var first u32
		var index u32
		var length u32 = 1
		while true,
			pre first <= 0xFFFF,
			pre index <= 0xFFFF,
			inv i < 316,
			inv n_dist <= 30,
			inv n_lit <= 286,
		{
			if length > 15 {
				return error "bad Huffman code"
			}

			// Read the next bit.
			while n_bits <= 0,
				inv first <= 0xFFFF,
				inv i < 316,
				inv index <= 0xFFFF,
				inv length <= 15,
				inv n_dist <= 30,
				inv n_lit <= 286,
				post n_bits > 0,
			{
				bits |= (in.src.read_u8?() as u32) << n_bits
				n_bits += 8
			}
			code |= bits & 1
			// TODO: improve the proof engine's bounds checking so that any
			// check returning "internal error: inconsistent Huffman decoder
			// state" can be removed. There is one here and more below.
			if code > 0xFFFF {
				return error "internal error: inconsistent Huffman decoder state"
			}
			bits >>= 1
			n_bits -= 1

			count = this.counts[length] as u32
			if count > 0xFFFF {
				return error "internal error: inconsistent Huffman decoder state"
			}

			// Compare the code so far to the counts.
			//
			// For the clcode example in this package's README.md:
			//  - counts[1] = 0
			//  - counts[2] = 0
			//  - counts[3] = 7
			//  - counts[4] = 1
			//  - counts[5] = 2
			//
			// Recall that the map from bits to clcode symbols is:
			//    bits        clcode
			//    0b000        0
			//    0b001        4
			//    0b010        5
			//    0b011        6
			//    0b100        7
			//    0b101        8
			//    0b110        9
			//    0b1110      17
			//    0b11110      3
			//    0b11111     18
			//
			// The loop iterations at this point have:
			//  - length=1, count=0, first= 0, index=0, code in [0.. 1].
			//  - length=2, count=0, first= 0, index=0, code in [0.. 3].
			//  - length=3, count=7, first= 0, index=0, code in [0.. 7].
			//  - length=4, count=1, first=14, index=7, code in [0..15].
			//  - length=5, count=2, first=30, index=8, code in [0..31].
			if code < (first + count) {
				index += code
				if index < first {
					return error "internal error: inconsistent Huffman decoder state"
				}
				index -= first
				if index >= 290 {
					return error "internal error: inconsistent Huffman decoder state"
				}
				symbol = this.symbols[index] as u32
				break
			}

			index += count
			if index > 0xFFFF {
				return error "internal error: inconsistent Huffman decoder state"
			}
			first = (first + count) << 1
			if first > 0xFFFF {
				return error "internal error: inconsistent Huffman decoder state"
			}
			code <<= 1

			length += 1
		}

		// Write a literal code length.
		if symbol < 16 {
			this.code_lengths[i] = symbol as u8
			i += 1
			continue
		}

		// Write a repeated code length.
		var n_extra_bits u32[..7]
		var rep_symbol u8[..15]
		var rep_count u32
		if symbol == 16 {
			n_extra_bits = 2
			if i <= 0 {
				return error "bad Huffman code length repetition"
			}
			rep_symbol = this.code_lengths[i - 1]
			rep_count = 3
			assert rep_count <= 11
		} else if symbol == 17 {
			n_extra_bits = 3
			rep_symbol = 0
			rep_count = 3
			assert rep_count <= 11
		} else {
			n_extra_bits = 7
			rep_symbol = 0
			rep_count = 11
			assert rep_count <= 11
		}
		while n_bits < n_extra_bits,
			inv i < 316,
			inv rep_count <= 11,
			inv n_dist <= 30,
			inv n_lit <= 286,
			post n_bits >= n_extra_bits,
		{
			assert n_bits < 7 via "a < b: a < c; c <= b"(c:n_extra_bits)
			bits |= (in.src.read_u8?() as u32) << n_bits
			n_bits += 8
		}
		rep_count += bits.low_bits(n:n_extra_bits)
		bits >>= n_extra_bits
		n_bits -= n_extra_bits

		while rep_count > 0,
			inv n_dist <= 30,
			inv n_lit <= 286,
		{
			// TODO: hoist this check up one level?
			if i >= (n_lit + n_dist) {
				return error "bad Huffman code length count"
			}
			assert i < (286 + 30) via "a < (b + c): a < (b0 + c0); b0 <= b; c0 <= c"(b0:n_lit, c0:n_dist)
			this.code_lengths[i] = rep_symbol
			i += 1
			rep_count -= 1
		}
	}

	if i != (n_lit + n_dist) {
		return error "bad Huffman code length count"
	}
	if this.code_lengths[256] == 0 {
		return error "missing end-of-block code"
	}

	this.bits = bits
	this.n_bits = n_bits
}

// TODO: make named constants for 15, 19, 289, etc.

// TODO: skip generating PUFFS_COROUTINE_SUSPENSION_POINTs for this function,
// and its callers, as it can only return errors, not suspensions.

pri func decoder.init_huff?(which u32[..1], n_codes u32[..289])() {
	// For the clcode example in this package's README.md:
	//  - n_codes = 19
	//  - code_lengths[ 0] = 3
	//  - code_lengths[ 1] = 0
	//  - code_lengths[ 2] = 0
	//  - code_lengths[ 3] = 5
	//  - code_lengths[ 4] = 3
	//  - code_lengths[ 5] = 3
	//  - code_lengths[ 6] = 3
	//  - code_lengths[ 7] = 3
	//  - code_lengths[ 8] = 3
	//  - code_lengths[ 9] = 3
	//  - code_lengths[10] = 0
	//  - code_lengths[11] = 0
	//  - code_lengths[12] = 0
	//  - code_lengths[13] = 0
	//  - code_lengths[14] = 0
	//  - code_lengths[15] = 0
	//  - code_lengths[16] = 0
	//  - code_lengths[17] = 4
	//  - code_lengths[18] = 5

	var i u32
	while i < 16 {
		this.counts[i] = 0
		i += 1
	}
	i = 0
	while i < in.n_codes {
		assert i < 289 via "a < b: a < c; c <= b"(c:in.n_codes)
		// TODO: this if should be unnecessary. Have some way to assert that,
		// for all j, counts[j] <= i, and thus counts[j]++ will not overflow.
		if this.counts[this.code_lengths[i]] >= 289 {
			return error "internal error: inconsistent Huffman decoder state"
		}
		this.counts[this.code_lengths[i]] += 1
		i += 1
	}
	if (this.counts[0] as u32) == in.n_codes {
		return error "no Huffman codes"
	}

	// For the clcode example in this package's README.md:
	//  - counts[0] = 9
	//  - counts[1] = 0
	//  - counts[2] = 0
	//  - counts[3] = 7
	//  - counts[4] = 1
	//  - counts[5] = 2
	//  - all other counts elements are 0.

	// TODO: check for the total code_lengths being too short or too long.

	var offsets[16] u16[..289]
	var total u16[..289]
	i = 1
	while i <= 15 {
		offsets[i] = total
		var count u16[..289] = this.counts[i]
		if total > (289 - count) {
			return error "internal error: inconsistent Huffman decoder state"
		}
		assert (total + count) <= 289 via "(a + b) <= c: a <= (c - b)"()
		// TODO: change this to total += count, once the proof engine's bounds
		// checking can handle it.
		total = total + count
		i += 1
	}

	// For the clcode example in this package's README.md:
	//  - offsets[0] =  0
	//  - offsets[1] =  0
	//  - offsets[2] =  0
	//  - offsets[3] =  0
	//  - offsets[4] =  7
	//  - offsets[5] =  8
	//  - offsets[6] = 10
	//  - all other offsets elements are 10.

	i = 0
	while i < in.n_codes {
		assert i < 289 via "a < b: a < c; c <= b"(c:in.n_codes)
		if this.code_lengths[i] != 0 {
			this.symbols[offsets[this.code_lengths[i]]] = i as u16
			if offsets[this.code_lengths[i]] >= 289 {
				return error "internal error: inconsistent Huffman decoder state"
			}
			offsets[this.code_lengths[i]] += 1
		}
		i += 1
	}

	// For the clcode example in this package's README.md:
	//  - symbols[0] =  0
	//  - symbols[1] =  4
	//  - symbols[2] =  5
	//  - symbols[3] =  6
	//  - symbols[4] =  7
	//  - symbols[5] =  8
	//  - symbols[6] =  9
	//  - symbols[7] = 17
	//  - symbols[8] =  3
	//  - symbols[9] = 18
	//
	// As a (local variable) side effect, offsets' values have been updated:
	//  - offsets[3] =  7, formerly 0
	//  - offsets[4] =  8, formerly 7
	//  - offsets[5] = 10, formerly 8

	var max_cl u32[1..15] = 15
	while true {
		if this.counts[max_cl] != 0 {
			break
		}
		if max_cl <= 1 {
			// TODO: when is a degenerate Huffman table valid?
			return error "no Huffman codes"
		}
		max_cl -= 1
	}
	if max_cl > 9 {
		return error "TODO: indirect Huffman tables"
	}

	// For the clcode example in this package's README.md:
	//  - max_cl = 5

	i = 0
	var n_symbols u32[..289] = offsets[max_cl] as u32
	var prev_cl u32[..15] = this.code_lengths[this.symbols[0]] as u32
	var code u32
	while i < n_symbols,
		inv code < (1 << 9),
		inv max_cl <= 9,
	{
		assert i < 289 via "a < b: a < c; c <= b"(c:n_symbols)
		var cl u32[..15] = this.code_lengths[this.symbols[i]] as u32
		if cl > max_cl {
			return error "internal error: inconsistent Huffman decoder state"
		}
		assert cl <= 9 via "a <= b: a <= c; c <= b"(c:max_cl)
		if cl > prev_cl {
			code <<= cl - prev_cl
			if code >= (1 << 9) {
				return error "internal error: inconsistent Huffman decoder state"
			}
		}

		var reversed_code u32[..511] = (reverse8[code >> 1] as u32) | ((code & 1) << 8)
		reversed_code >>= 9 - cl

		// TODO: don't assume that the value is a literal.
		var value u32 = ((this.symbols[i] as u32) << 8) | cl
		value |= 0x40000000

		// The table uses max_cl bits, but reversed_code only has cl bits. We
		// duplicate the key-value pair across all possible values of the high
		// (max_cl - cl) bits.
		var high_bits u32 = (1 as u32) << max_cl
		var delta u32 = (1 as u32) << cl
		while high_bits >= delta,
			inv code < (1 << 9),
			inv i < 289,
			inv max_cl <= 9,
		{
			high_bits -= delta
			this.huffs[in.which][(high_bits | reversed_code) & 511] = value
		}

		code += 1
		if code >= (1 << 9) {
			return error "internal error: inconsistent Huffman decoder state"
		}
		prev_cl = cl
		i += 1
	}

	// For the clcode example in this package's README.md:
	//  - huffs[0][0b..000] maps to value 0x40000003 (literal, symbols[0]=0x00, code_length=3)
	//  - huffs[0][0b..100] maps to value 0x40000403 (literal, symbols[1]=0x04, code_length=3)
	//  - huffs[0][0b..010] maps to value 0x40000503 (literal, symbols[2]=0x05, code_length=3)
	//  - huffs[0][0b..110] maps to value 0x40000603 (literal, symbols[3]=0x06, code_length=3)
	//  - huffs[0][0b..001] maps to value 0x40000703 (literal, symbols[4]=0x07, code_length=3)
	//  - huffs[0][0b..101] maps to value 0x40000803 (literal, symbols[5]=0x08, code_length=3)
	//  - huffs[0][0b..011] maps to value 0x40000903 (literal, symbols[6]=0x09, code_length=3)
	//  - huffs[0][0b.0111] maps to value 0x40001104 (literal, symbols[7]=0x11, code_length=4)
	//  - huffs[0][0b01111] maps to value 0x40000305 (literal, symbols[8]=0x03, code_length=5)
	//  - huffs[0][0b11111] maps to value 0x40001805 (literal, symbols[9]=0x18, code_length=5)
}
