// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file.

// The flate spec is https://www.ietf.org/rfc/rfc1951.txt

packageid "flte"

pub error "bad distance code count"
pub error "bad flate block"
pub error "bad literal/length code count"
pub error "inconsistent stored block length"
pub error "internal error: inconsistent n_bits"

pub error "TODO: fixed Huffman blocks"
pub error "TODO: dynamic Huffman blocks"

pub struct decoder?(
	// These fields yield src's bits in Least Significant Bits order.
	bits u32,
	n_bits u32,

	code_length_code_lengths[19] u8[..7],

	// These temporary fields are used to debug work-in-progress code.
	wip0 u32,
	wip1 u32,
)

pub func decoder.decode?(dst writer1, src reader1)() {
	while true {
		while this.n_bits < 3,
			post this.n_bits >= 3,
		{
			this.bits |= (in.src.read_u8?() as u32) << this.n_bits
			this.n_bits += 8
		}
		var final u32 = this.bits & 0x01
		var type u32 = (this.bits >> 1) & 0x03
		this.bits >>= 3
		this.n_bits -= 3

		if type == 0 {
			this.decode_uncompressed?(dst:in.dst, src:in.src)
		} else if type == 1 {
			return error "TODO: fixed Huffman blocks"
		} else if type == 2 {
			this.decode_dynamic?(dst:in.dst, src:in.src)
		} else {
			return error "bad flate block"
		}

		if final != 0 {
			return
		}
	}
}

pub func decoder.decode_uncompressed?(dst writer1, src reader1)() {
	if this.n_bits >= 8 {
		return error "internal error: inconsistent n_bits"
	}
	this.n_bits = 0

	var n u32 = in.src.read_u32le?()
	if (n.low_bits(n:16) + n.high_bits(n:16)) != 0xFFFF {
		return error "inconsistent stored block length"
	}
	in.dst.copy_from32?(r:in.src, n:n.low_bits(n:16))
}

// decode_dynamic decodes dynamic Huffman codes as per the RFC section 3.2.7.
pub func decoder.decode_dynamic?(dst writer1, src reader1)() {
	var bits u32 = this.bits
	var n_bits u32 = this.n_bits
	while n_bits < 14,
		post n_bits >= 14,
	{
		bits |= (in.src.read_u8?() as u32) << n_bits
		n_bits += 8
	}
	var hlit u32[257..288] = bits.low_bits(n:5) + 257
	if hlit > 286 {
		return error "bad literal/length code count"
	}
	bits >>= 5
	var hdist u32[1..32] = bits.low_bits(n:5) + 1
	if hdist > 30 {
		return error "bad distance code count"
	}
	bits >>= 5
	var hclen u32[4..19] = bits.low_bits(n:4) + 4
	bits >>= 4
	n_bits -= 14

	// Read the code length code lengths. (This is not a typo).
	var i u32 = 0
	while i < hclen {
		while n_bits < 3,
			inv i < hclen,
			post n_bits >= 3,
		{
			bits |= (in.src.read_u8?() as u32) << n_bits
			n_bits += 8
		}
		assert i < 19 via "a < b: a < c; c <= b"(c:hclen)
		this.code_length_code_lengths[code_order[i]] = (bits & 0x07) as u8
		bits >>= 3
		n_bits -= 3
		i += 1
	}
	while i < 19 {
		this.code_length_code_lengths[code_order[i]] = 0
		i += 1
	}

	// TODO: implement.
	this.wip0 = hlit
	this.wip1 = hdist

	this.bits = bits
	this.n_bits = n_bits
}
