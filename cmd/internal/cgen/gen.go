// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file.

// +build ignore

// gen.go converts preamble.h to data.go.
//
// Invoke it via "go generate".

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
)

const columns = 1024

func main() {
	if err := main1(); err != nil {
		os.Stderr.WriteString(err.Error() + "\n")
		os.Exit(1)
	}
}

func main1() error {
	const inFilename = "preamble.h"
	in, err := ioutil.ReadFile(inFilename)
	if err != nil {
		return err
	}

	const afterEditing = "// After editing this file,"
	if !bytes.HasPrefix(in, []byte(afterEditing)) {
		return fmt.Errorf("%s's contents do not start with %q", inFilename, afterEditing)
	}
	if i := bytes.Index(in, []byte("\n\n")); i >= 0 {
		in = in[i+2:]
	}

	out := &bytes.Buffer{}
	out.WriteString("// Code generated by running \"go generate\". DO NOT EDIT.\n")
	out.WriteString("\n")
	out.WriteString("// Use of this source code is governed by a BSD-style license that can be found\n")
	out.WriteString("// in the LICENSE file.\n")
	out.WriteString("\n")
	out.WriteString("package cgen\n")
	out.WriteString("\n")
	out.WriteString("const preamble = \"\" +\n")
	for len(in) > 0 {
		s := in
		if len(s) > columns {
			s = s[:columns]
		}
		in = in[len(s):]
		fmt.Fprintf(out, "%q +\n", s)
	}
	out.WriteString("\"\"\n")

	formatted, err := format.Source(out.Bytes())
	if err != nil {
		return err
	}
	return ioutil.WriteFile("data.go", formatted, 0644)
}
