// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file.

// +build ignore

package main

// gen.go converts base.* to data.go.
//
// Invoke it via "go generate".

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
)

const columns = 1024

func main() {
	if err := main1(); err != nil {
		os.Stderr.WriteString(err.Error() + "\n")
		os.Exit(1)
	}
}

func main1() error {
	files := []struct {
		filename, varname string
	}{
		{"base-header.h", "baseHeader"},
		{"base-impl.h", "baseImpl"},
	}

	out := &bytes.Buffer{}
	out.WriteString("// Code generated by running \"go generate\". DO NOT EDIT.\n")
	out.WriteString("\n")
	out.WriteString("// Use of this source code is governed by a BSD-style license that can be found\n")
	out.WriteString("// in the LICENSE file.\n")
	out.WriteString("\n")
	out.WriteString("package cgen\n")
	out.WriteString("\n")

	for _, f := range files {
		in, err := ioutil.ReadFile(f.filename)
		if err != nil {
			return err
		}

		const afterEditing = "// After editing this file,"
		if !bytes.HasPrefix(in, []byte(afterEditing)) {
			return fmt.Errorf("%s's contents do not start with %q", f.filename, afterEditing)
		}
		if i := bytes.Index(in, []byte("\n\n")); i >= 0 {
			in = in[i+2:]
		}

		fmt.Fprintf(out, "const %s = \"\" +\n", f.varname)
		for len(in) > 0 {
			s := in
			if len(s) > columns {
				s = s[:columns]
			}
			in = in[len(s):]
			fmt.Fprintf(out, "%q +\n", s)
		}
		out.WriteString("\"\"\n\n")
	}

	formatted, err := format.Source(out.Bytes())
	if err != nil {
		return err
	}
	return ioutil.WriteFile("data.go", formatted, 0644)
}
