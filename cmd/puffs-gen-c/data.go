// Code generated by running "go generate". DO NOT EDIT.

// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file.

package main

const baseHeader = "" +
	"#ifndef PUFFS_BASE_HEADER_H\n#define PUFFS_BASE_HEADER_H\n\n// Use of this source code is governed by a BSD-style license that can be found\n// in the LICENSE file.\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <string.h>\n\n// Puffs requires a word size of at least 32 bits because it assumes that\n// converting a u32 to usize will never overflow. For example, the size of a\n// decoded image is often represented, explicitly or implicitly in an image\n// file, as a u32, and it is convenient to compare that to a buffer size.\n#if __WORDSIZE < 32\n#error \"Puffs requires a word size of at least 32 bits\"\n#endif\n\n// PUFFS_VERSION is the major.minor version number as a uint32. The major\n// number is the high 16 bits. The minor number is the low 16 bits.\n//\n// The intention is to bump the version number at least on every API / ABI\n// backwards incompatible change.\n//\n// For now, the API and ABI are simply unstable and can change at any time.\n//\n// TODO: don't hard code this in base-header.h.\n#define PUFFS_VERSION (0x00001)" +
	"\n\n// puffs_base_buf1 is a 1-dimensional buffer (a pointer and capacity) plus\n// additional indexes into that buffer.\n//\n// A value with all fields NULL or zero is a valid, empty buffer.\ntypedef struct {\n  uint8_t* ptr;  // Pointer.\n  size_t cap;    // Capacity.\n  size_t wi;     // Write index. Invariant: wi <= cap.\n  size_t ri;     // Read  index. Invariant: ri <= wi.\n} puffs_base_buf1;\n\n#endif  // PUFFS_BASE_HEADER_H\n" +
	""

const baseImpl = "" +
	"#ifndef PUFFS_BASE_IMPL_H\n#define PUFFS_BASE_IMPL_H\n\n#define PUFFS_LOW_BITS(x, n) ((x) & ((1 << (n)) - 1))\n\n#endif  // PUFFS_BASE_IMPL_H\n" +
	""
